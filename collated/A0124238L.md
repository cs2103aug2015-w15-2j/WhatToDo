# A0124238L
###### backend\ConfigHandler.java
``` java
 */

package backend;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;

import java.nio.file.FileSystemException;

import java.util.ArrayList;

public class ConfigHandler {
	private static final String TEXT_FILE_DIVIDER = ";";

	private static final String FILE_NAME = "whattodo.txt";
	private static final String COLLATED_FILE_PATH_FORMAT = "%s"
			+ File.separator + "%s";

	private static final String CONFIG_FILE_PATH = "config" + File.separator
			+ "config.txt";

	private static final String ALIAS_FILE_PATH = "config" + File.separator
			+ "alias.txt";
	private static final String FORMAT_ALIAS = "%s" + TEXT_FILE_DIVIDER + "%s";

	private static final String MESSAGE_ERROR_CREATE_FILE = "Error encountered when creating file.";

	private static final String EMPTY_STRING = "";
	private static final String NEWLINE = "\n";

	private static final int PARAM_START_LOOP_ZERO = 0;
	private static final int PARAM_FIRST_WORD = 0;
	private static final int PARAM_LESS_ONE = 1;
	private static final int PARAM_DOES_NOT_EXIST = -1;

	// For reading files.
	private BufferedReader configFileReader;
	private BufferedReader aliasFileReader;

	// For writing files.
	private PrintWriter configFileWriter;
	private PrintWriter aliasFileWriter;

	/**
	 * Retrieves the path of whattodo.txt from config file, creating it if missing.
	 * 
	 * @return                      file path of whattodo.txt
	 * @throws FileSystemException  when error in creating config file
	 */
	public String getPathFromConfig() throws FileSystemException {
		createConfigFileIfMissing();

		String readFilePath;

		try {
			readFilePath = readFromConfigFile();
		} catch (IOException exception) {
			return FILE_NAME;
		}

		if (!hasDirectorySpecifiedInPath(readFilePath)) {
			return FILE_NAME;
		}

		return String
				.format(COLLATED_FILE_PATH_FORMAT, readFilePath, FILE_NAME);
	}

	/**
	 * Updates the config file with new location of file path for whattodo.txt
	 * 
	 * @param newLocation             new file path of whattodo.txt
	 * @throws FileNotFoundException  when cannot find config file
	 */
	public void updateConfigFile(String newLocation)
			throws FileNotFoundException {
		configFileWriter = new PrintWriter(CONFIG_FILE_PATH);

		configFileWriter.print(newLocation);

		configFileWriter.close();
	}

	/**
	 * Creates Alias file in config folder
	 * 
	 * @throws FileSystemException   when error in creating file
	 */
	public void createAliasFile() throws FileSystemException {
		File file = new File(ALIAS_FILE_PATH);

		createNewFileIfFileDoesNotExist(file);
	}

	/**
	 * Adds in an alias->commandType pair to the alias file.
	 * 
	 * @param aliasLine          the alias to be added
	 * @param actualCommandType  the command type the alias is paired with
	 * @throws IOException       when error in reading or writing to file or finding alias file
	 */
	public void updateAliasFile(String aliasLine, String actualCommandType)
			throws IOException {
		ArrayList<String> fileContents = readAliasFileToArrayList();

		String lineToAdd = String.format(FORMAT_ALIAS, aliasLine,
				actualCommandType);
		fileContents.add(lineToAdd);

		writeContentsToAliasFile(fileContents);
	}

	/**
	 * Removes specified alias and its corresponding pair from alias file
	 * 
	 * @param aliasLine       the alias to be removed
	 * @throws IOException    when error in reading or writing to file or finding alias file
	 */
	public void removeFromAliasFile(String aliasLine) throws IOException {
		ArrayList<String> fileContents = readAliasFileToArrayList();

		removeAliasFromArrayList(aliasLine, fileContents);

		writeContentsToAliasFile(fileContents);
	}

	/**
	 * Shows all the contents of the alias file
	 * 
	 * @return              all the contents of alias file as a String
	 * @throws IOException  when error in reading the file or finding alias file
	 */
	public String displayAliasFile() throws IOException {
		initializeAliasReader();

		StringBuilder fileContents = new StringBuilder();

		formatAliasContentsAsString(fileContents);

		return fileContents.toString();
	}

	/**
	 * Clears all contents of the alias file
	 * 
	 * @throws IOException   when unable to find alias file. 
	 */
	public void clearAliasFile() throws IOException {
		emptyAliasFile();
	}

	/**
	 * Replaces the contents of the alias file with specified String contents
	 * 
	 * @param textToOverwrite   the text to replace the contents of alias file with
	 * @throws IOException      when error in writing to file or finding alias file
	 */
	public void overwriteAliasFile(String textToOverwrite) throws IOException {
		String[] linesToReplace = textToOverwrite.split(NEWLINE);

		ArrayList<String> fileContents = convertToArrayList(linesToReplace);

		writeContentsToAliasFile(fileContents);
	}

	/*
	 * Private Methods start here
	 */

	private void initialiseAliasWriter() throws FileNotFoundException {
		aliasFileWriter = new PrintWriter(ALIAS_FILE_PATH);
	}

	private ArrayList<String> convertToArrayList(String[] linesToConvert) {
		ArrayList<String> convertedContents = new ArrayList<String>();

		for (int i = PARAM_START_LOOP_ZERO; i < linesToConvert.length; i++) {
			convertedContents.add(linesToConvert[i]);
		}

		return convertedContents;
	}

	private void createConfigFileIfMissing() throws FileSystemException {
		File file = new File(CONFIG_FILE_PATH);

		createDirectoryIfMissing(file);

		createNewFileIfFileDoesNotExist(file);
	}

	private void formatAliasContentsAsString(StringBuilder fileContents)
			throws IOException {
		while (true) {
			String lineRead = aliasFileReader.readLine();

			if (isEndOfFile(lineRead)) {
				break;
			} else {
				fileContents.append(lineRead);
				fileContents.append(NEWLINE);
			}
		}

		aliasFileReader.close();
	}

	private ArrayList<String> readAliasFileToArrayList() throws IOException {
		initializeAliasReader();

		ArrayList<String> fileContents = new ArrayList<String>();

		while (true) {
			String lineRead = aliasFileReader.readLine();

			if (isEndOfFile(lineRead)) {
				break;
			} else {
				fileContents.add(lineRead);
			}
		}

		aliasFileReader.close();
		return fileContents;
	}

	private void writeContentsToAliasFile(ArrayList<String> fileContents)
			throws FileNotFoundException {
		initialiseAliasWriter();

		int lastLine = fileContents.size() - PARAM_LESS_ONE;

		if (lastLine == PARAM_DOES_NOT_EXIST) {
			aliasFileWriter.print(EMPTY_STRING);
			aliasFileWriter.close();
			return;
		}

		for (int i = PARAM_START_LOOP_ZERO; i < lastLine; i++) {
			aliasFileWriter.println(fileContents.get(i));
		}
		aliasFileWriter.print(fileContents.get(lastLine));

		aliasFileWriter.close();
	}

	private void emptyAliasFile() throws FileNotFoundException {
		aliasFileWriter = new PrintWriter(ALIAS_FILE_PATH);

		aliasFileWriter.print(EMPTY_STRING);

		aliasFileWriter.close();
	}

	private void removeAliasFromArrayList(String aliasLine,
			ArrayList<String> fileContents) {
		for (int i = PARAM_START_LOOP_ZERO; i < fileContents.size(); i++) {
			String aliasFromFile = getFirstWord(fileContents.get(i));
			if (aliasFromFile.equals(aliasLine)) {
				fileContents.remove(i);
				break;
			}
		}
	}

	private void initializeAliasReader() throws FileNotFoundException {
		FileReader fileToBeRead = new FileReader(ALIAS_FILE_PATH);
		aliasFileReader = new BufferedReader(fileToBeRead);
	}

	private void createDirectoryIfMissing(File file) {
		file.getParentFile().mkdirs();
	}

	private void createNewFileIfFileDoesNotExist(File file)
			throws FileSystemException {
		try {
			file.createNewFile();
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_CREATE_FILE);
		}
	}

	private String readFromConfigFile() throws IOException {
		FileReader fileToBeRead = new FileReader(CONFIG_FILE_PATH);
		configFileReader = new BufferedReader(fileToBeRead);

		String lineRead = configFileReader.readLine();
		configFileReader.close();

		return lineRead;
	}

	private boolean hasDirectorySpecifiedInPath(String readFilePath) {
		if (isEndOfFile(readFilePath)) {
			return false;
		} else if (readFilePath.trim().equals(EMPTY_STRING)) {
			return false;
		} else {
			return true;
		}
	}

	private boolean isEndOfFile(String lineRead) {
		return lineRead == null;
	}

	private String getFirstWord(String text) {
		String parameters[] = splitParameters(text);
		String firstWord = parameters[PARAM_FIRST_WORD];

		return firstWord;
	}

	private String[] splitParameters(String line) {
		return line.split(TEXT_FILE_DIVIDER);
	}
}
```
###### backend\Storage.java
``` java
 */

package backend;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;

import java.nio.file.FileSystemException;

import java.util.ArrayList;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import struct.FloatingTask;
import struct.Event;
import struct.Task;

public class Storage {
	private static final String FILE_NAME = "whattodo.txt";
	private static final String COLLATED_FILE_PATH_FORMAT = "%s"
			+ File.separator + "%s";

	private static final String MESSAGE_CHANGE_STORAGE_SUCCESS = "You are now writing to \"%s\"";
	private static final String MESSAGE_SAME_FILE = "Your file location remains unchanged.";

	private static final String MESSAGE_ERROR_CREATE_FILE = "Error encountered when creating file.";
	private static final String MESSAGE_ERROR_READ_FILE = "Error encountered when reading file.";
	private static final String MESSAGE_ERROR_WRITE_FILE = "Error encountered when writing to file.";
	private static final String MESSAGE_ERROR_INVALID_LINE_ACCESS = "Cannot find line %d in text file.";
	private static final String MESSAGE_ERROR_ALREADY_DONE = "Error encountered: the %s \"%s\" has already"
			+ " been completed.";

	private static final String MESSAGE_ERROR_CHANGING_FILE_PATH = "File location specified is invalid.";
	private static final String MESSAGE_ERROR_CHANGING_FILE_PATH_UNKNOWN = "Unknown error encountered when "
			+ "changing file path.";
	private static final String MESSAGE_ERROR_CHANGING_FILE_PATH_CONFLICT = "Conflicting text files found in"
			+ " both old and new file paths. Please delete either one.";

	private static final String MESSAGE_LOG_UNKNOWN_TYPE = "Unknown type found in line %d";
	private static final String MESSAGE_LOG_CHANGE_PATH = "Unknown Exception found";
	private static final String MESSAGE_LOG_UNKNOWN_SITUATION = "Unknown situation: %d";
	private static final String MESSAGE_LOG_LINE_VALIDATION = "Line Number: %d, file lines: %d";

	private static final String TEXT_FILE_DIVIDER = ";";

	private static final String STRING_TASK = "task";
	private static final String STRING_FLOAT_TASK = "float";
	private static final String STRING_EVENT = "event";

	private static final String NEWLINE = "\n";
	private static final String EMPTY_STRING = "";

	private static final int PARAM_LINE_NUMBER_ZERO = 0;
	private static final int PARAM_START_LOOP_ZERO = 0;
	private static final int PARAM_LESS_ONE = 1;
	private static final int PARAM_DOES_NOT_EXIST = -1;
	private static final int PARAM_FIRST_WORD = 0;
	private static final int PARAM_COMPARE_TO = 0;

	// For Logging.
	private static final Level LEVEL_TO_SHOW = Level.INFO;

	// Used to offset difference in 1-based and 0-based counting.
	private static final int PARAM_OFFSET = 1;

	// Situations for changing file path location.
	private static final int SITUATION_MOVE_FILE = 0;
	private static final int SITUATION_CHANGE_LOCATION = 1;
	private static final int SITUATION_CONFLICT_FILES = 2;
	private static final int SITUATION_SAME_FILE = 3;

	// This string stores the whole file name with directory.
	private String filePath;

	// For reading from file.
	private BufferedReader fileReader;

	// For writing into file.
	private PrintWriter fileWriter;

	// For handling operations within config folder.
	private ConfigHandler configHandler;

	// For Logging
	private Logger logger;

	/**
	 * Constructor
	 * 
	 * @throws FileSystemException
	 *             when error in creating file.
	 */
	public Storage() throws FileSystemException {
		initialiseHandler();

		filePath = configHandler.getPathFromConfig();

		createToDoListFile();

		configHandler.createAliasFile();

		initialiseLogger();
	}

	public String getFilePath() {
		return getAbsoluteFilePath();
	}

	/**
	 * Changes location to store text file to given newLocation string.
	 * Directories/Folders will be created if missing. * Returns error message
	 * when given newLocation is invalid name for directory or file.
	 * 
	 * @param newLocation
	 *            file path of location to change to
	 * @return status message to indicate if changing is a success.
	 */
	public String changeFileStorageLocation(String newLocation) {
		String feedback = changeFilePath(newLocation);

		return feedback;
	}

	/**
	 * Adds a task with deadline to the text file (to-do list). Tasks in the
	 * file will be sorted by deadlines.
	 * 
	 * @param newTask
	 *            the Task object to be added to file.
	 * @throws FileSystemException
	 *             when encounter error in reading file.
	 */
	public void addTask(Task newTask) throws FileSystemException {
		assert (newTask.getName() != EMPTY_STRING);
		assert (newTask.getDeadline().formatDateShort() != EMPTY_STRING);

		try {
			addTaskToFile(newTask);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Adds a floating task to the text file (to-do list). Floating tasks in the
	 * file will be sorted in alphabetical order.
	 * 
	 * @param newFloatingTask
	 *            the FloatingTask object to be added to file.
	 * @throws FileSystemException
	 *             when encounter error in reading file.
	 */
	public void addFloatingTask(FloatingTask newFloatingTask)
			throws FileSystemException {
		assert (newFloatingTask.getName() != EMPTY_STRING);

		try {
			addFloatTaskToFile(newFloatingTask);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Adds an event to the text file (to-do-list). Events in the file will be
	 * sorted by start date/time, followed by end date/time.
	 * 
	 * @param newEvent
	 *            the Event object to be added to file.
	 * @throws FileSystemException
	 *             when encounter error in reading file.
	 */
	public void addEvent(Event newEvent) throws FileSystemException {
		assert (newEvent.getName() != EMPTY_STRING);
		assert (newEvent.getEventStartDate().formatDateShort() != EMPTY_STRING);
		assert (newEvent.getEventEndDate().formatDateShort() != EMPTY_STRING);
		assert (newEvent.getEventStartTime() != EMPTY_STRING);
		assert (newEvent.getEventEndTime() != EMPTY_STRING);

		try {
			addEventToFile(newEvent);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Deletes a line in the text file with specified line number. (1-based
	 * counting)
	 * 
	 * @param lineNumber
	 *            line number in text file to be deleted.
	 * @return the text at specified line number.
	 * @throws FileSystemException
	 *             when line number less than 0 or more than number of lines
	 *             present in text file, or when error in reading file.
	 */
	public String deleteLine(int lineNumber) throws FileSystemException {
		try {
			String deletedLine = deleteLineFromFile(lineNumber);

			return deletedLine;
		} catch (IllegalArgumentException exception) {
			throw new FileSystemException(exception.getMessage());
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Displays the contents in the text file (to-do list).
	 * 
	 * @return the contents of text file in a String.
	 * @throws FileSystemException
	 *             when encounter error in reading file.
	 */
	public String display() throws FileSystemException {
		try {
			return showAllFileContents();
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Overwrites the entire text file with given string input.
	 * 
	 * @param textToWrite
	 *            text used to overwrite the text file with.
	 * @throws FileSystemException
	 *             when unable to write to file.
	 */
	public void overwriteFile(String textToWrite) throws FileSystemException {
		try {
			writeContentsToFile(textToWrite);
		} catch (FileNotFoundException exception) {
			throw new FileSystemException(MESSAGE_ERROR_WRITE_FILE);
		}
	}

	/**
	 * Marks the task/event/float at given line number in text file as done.
	 * (1-based counting)
	 * 
	 * @param lineNumber
	 *            line number in text file to be marked as done.
	 * @return the text at specified line number before marking as done.
	 * @throws FileSystemException
	 *             when line number less than 0 or more than number of lines
	 *             present in text file, or when error in reading file, or when
	 *             task/event is already done.
	 */
	public String markAsDone(int lineNumber) throws FileSystemException {
		try {
			String markedLine = markAsCompleted(lineNumber);

			return markedLine;
		} catch (IllegalArgumentException exception) {
			throw new FileSystemException(exception.getMessage());
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Retrieves the type of item (float/task/event) in the text file with
	 * specified line number. (1-based counting)
	 * 
	 * @param lineNumber
	 *            line number in text file to be found/queried.
	 * @return the item type at specified line number.
	 * @throws FileSystemException
	 *             when line number less than 0 or more than number of lines
	 *             present in text file, or when error in reading file.
	 */
	public String findTypeInLine(int lineNumber) throws FileSystemException {
		try {
			String itemType = findItemTypeFromFile(lineNumber);

			return itemType;
		} catch (IllegalArgumentException exception) {
			throw new FileSystemException(exception.getMessage());
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Retrieves the attribute at specified line number of specified type.
	 * 
	 * @param lineNumber
	 *            line number in text file to be retrieved.
	 * @param type
	 *            type of attribute to get from line.
	 * @return the attribute of given type at given line. null if no such
	 *         attribute exists at given line.
	 * @throws FileSystemException
	 *             when line number less than 0 or more than number of lines
	 *             present in text file, or when error in reading file.
	 */
	public String getAttribute(int lineNumber, int type)
			throws FileSystemException {
		try {
			String attribute = findAttribute(lineNumber, type);

			return attribute;
		} catch (IllegalArgumentException exception) {
			throw new FileSystemException(exception.getMessage());
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Adds a line alias->actual command mapping to the alias file in config
	 * folder.
	 * 
	 * @param aliasLine
	 *            user-specified alias.
	 * @param actualCommandType
	 *            actual command type to be mapped to.
	 * @throws FileSystemException
	 *             when error in writing to file.
	 */
	public void addToAliasFile(String aliasLine, String actualCommandType)
			throws FileSystemException {
		assert (aliasLine.indexOf(TEXT_FILE_DIVIDER) == PARAM_DOES_NOT_EXIST);
		assert (actualCommandType.indexOf(TEXT_FILE_DIVIDER) == PARAM_DOES_NOT_EXIST);

		try {
			configHandler.updateAliasFile(aliasLine, actualCommandType);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_WRITE_FILE);
		}
	}

	/**
	 * Deletes a line with specified alias, removing the mapping too from alias
	 * file in config folder. This method will not do anything if specified
	 * alias is not found in file.
	 * 
	 * @param aliasLine
	 *            user-specified alias.
	 * @throws FileSystemException
	 *             when error in writing to file.
	 */
	public void deleteFromAliasFile(String aliasLine)
			throws FileSystemException {
		assert (aliasLine.indexOf(TEXT_FILE_DIVIDER) == PARAM_DOES_NOT_EXIST);

		try {
			configHandler.removeFromAliasFile(aliasLine);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_WRITE_FILE);
		}
	}

	/**
	 * Displays the entire content of the alias file.
	 * 
	 * @return the contents of alias file as a String.
	 * @throws FileSystemException
	 *             when error in reading file.
	 */
	public String readAliasFile() throws FileSystemException {
		try {
			String fileContents = configHandler.displayAliasFile();

			return fileContents;
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_READ_FILE);
		}
	}

	/**
	 * Clears the entire content of the alias file.
	 * 
	 * @throws FileSystemException
	 *             when error in writing file.
	 */
	public void clearAliasFile() throws FileSystemException {
		try {
			configHandler.clearAliasFile();
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_WRITE_FILE);
		}
	}

	/**
	 * Overwrites the entire content of the alias file with given text.
	 * 
	 * @param textToOverwrite
	 *            text to overwrite alias file with.
	 * @throws FileSystemException
	 *             when error in writing file.
	 */
	public void overwriteAliasFile(String textToOverwrite)
			throws FileSystemException {
		try {
			configHandler.overwriteAliasFile(textToOverwrite);
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_WRITE_FILE);
		}
	}

	// Private Methods Start Here.

	private void initialiseLogger() {
		logger = Logger.getLogger(Storage.class.getName());

		logger.setLevel(LEVEL_TO_SHOW);
		logger.setUseParentHandlers(false);

		ConsoleHandler handler = new ConsoleHandler();
		handler.setLevel(LEVEL_TO_SHOW);

		logger.addHandler(handler);
	}

	private void addFloatTaskToFile(FloatingTask newFloatTask)
			throws IOException {
		ArrayList<String> fileContents = new ArrayList<String>();

		initialiseReader();

		addFloatToCorrectPlace(newFloatTask, fileContents);

		writeContentsToFile(fileContents);
		fileReader.close();
	}

	private void addFloatToCorrectPlace(FloatingTask newFloatTask,
			ArrayList<String> fileContents) throws IOException {
		boolean hasAddedLine = false;
		String lineToAdd = newFloatTask.toString();

		while (true) {
			String lineRead = fileReader.readLine();

			if (isEndOfFile(lineRead)) {
				if (!hasAddedLine) {
					fileContents.add(lineToAdd);
				}
				break;
			} else if (hasAddedLine) {
				fileContents.add(lineRead);
			} else {
				hasAddedLine = processAddLineForFloat(newFloatTask,
						fileContents, lineToAdd, lineRead);
			}
		}
	}

	private boolean processAddLineForFloat(FloatingTask newFloatTask,
			ArrayList<String> fileContents, String lineToAdd, String lineRead) {
		boolean hasAddedLine = false;
		String typeOfLineRead = getFirstWord(lineRead);

		if (!typeOfLineRead.equals(STRING_FLOAT_TASK)) {
			insertLine(fileContents, lineToAdd, lineRead);
			hasAddedLine = true;
		} else {
			FloatingTask currentReadTask = new FloatingTask(lineRead);
			if (currentReadTask.compareTo(newFloatTask) < PARAM_COMPARE_TO) {
				fileContents.add(lineRead);
			} else {
				insertLine(fileContents, lineToAdd, lineRead);
				hasAddedLine = true;
			}
		}
		return hasAddedLine;
	}

	private void addTaskToFile(Task newTask) throws IOException {
		ArrayList<String> fileContents = new ArrayList<String>();

		initialiseReader();

		addTaskToCorrectPlace(newTask, fileContents);

		writeContentsToFile(fileContents);
		fileReader.close();
	}

	private void addTaskToCorrectPlace(Task newTask,
			ArrayList<String> fileContents) throws IOException {
		boolean hasAddedLine = false;
		String lineToAdd = newTask.toString();

		while (true) {
			String lineRead = fileReader.readLine();

			if (isEndOfFile(lineRead)) {
				if (!hasAddedLine) {
					fileContents.add(lineToAdd);
				}
				break;
			} else if (hasAddedLine) {
				fileContents.add(lineRead);
			} else {
				hasAddedLine = processAddLineForTask(newTask, fileContents,
						lineToAdd, lineRead);
			}
		}
	}

	private boolean processAddLineForTask(Task newTask,
			ArrayList<String> fileContents, String lineToAdd, String lineRead) {
		boolean hasAddedLine = false;
		String typeOfLineRead = getFirstWord(lineRead);

		if (typeOfLineRead.equals(STRING_FLOAT_TASK)) {
			fileContents.add(lineRead);
		} else if (typeOfLineRead.equals(STRING_TASK)) {
			Task currentReadTask = new Task(lineRead);
			if (newTask.compareTo(currentReadTask) > PARAM_COMPARE_TO) {
				fileContents.add(lineRead);
			} else {
				insertLine(fileContents, lineToAdd, lineRead);
				hasAddedLine = true;
			}
		} else {
			insertLine(fileContents, lineToAdd, lineRead);
			hasAddedLine = true;
		}
		return hasAddedLine;
	}

	private void addEventToFile(Event newEvent) throws IOException {
		ArrayList<String> fileContents = new ArrayList<String>();
		initialiseReader();

		addEventToCorrectPlace(newEvent, fileContents);

		writeContentsToFile(fileContents);
		fileReader.close();
	}

	private void addEventToCorrectPlace(Event newEvent,
			ArrayList<String> fileContents) throws IOException {
		boolean hasAddedLine = false;
		String lineToAdd = newEvent.toString();

		while (true) {
			String lineRead = fileReader.readLine();

			if (isEndOfFile(lineRead)) {
				if (!hasAddedLine) {
					fileContents.add(lineToAdd);
				}
				break;
			} else if (hasAddedLine) {
				fileContents.add(lineRead);
			} else {
				hasAddedLine = processAddLineForEvent(newEvent, fileContents,
						lineToAdd, lineRead);
			}
		}
	}

	private boolean processAddLineForEvent(Event newEvent,
			ArrayList<String> fileContents, String lineToAdd, String lineRead) {
		boolean hasAddedLine = false;
		String typeOfLineRead = getFirstWord(lineRead);

		if (!typeOfLineRead.equals(STRING_EVENT)) {
			fileContents.add(lineRead);
		} else {
			Event currentReadEvent = new Event(lineRead);
			if (newEvent.compareTo(currentReadEvent) > PARAM_COMPARE_TO) {
				fileContents.add(lineRead);
			} else {
				insertLine(fileContents, lineToAdd, lineRead);
				hasAddedLine = true;
			}
		}
		return hasAddedLine;
	}

	private void insertLine(ArrayList<String> fileContents, String lineToAdd,
			String lineRead) {
		fileContents.add(lineToAdd);
		fileContents.add(lineRead);
	}

	private String deleteLineFromFile(int lineNumber) throws IOException,
			IllegalArgumentException {
		ArrayList<String> fileContents = new ArrayList<String>();

		addFileContentsToArrayList(fileContents);

		throwIllegalArgExceptionIfInvalid(lineNumber, fileContents);

		String lineToDelete = fileContents.remove(lineNumber - PARAM_OFFSET);

		writeContentsToFile(fileContents);

		return lineToDelete;
	}

	private String findAttribute(int lineNumber, int type) throws IOException,
			IllegalArgumentException {
		ArrayList<String> fileContents = new ArrayList<String>();

		addFileContentsToArrayList(fileContents);

		throwIllegalArgExceptionIfInvalid(lineNumber, fileContents);

		String lineToFind = fileContents.get(lineNumber - PARAM_OFFSET);

		String attribute = getAttributeFromLine(type, lineToFind);

		return attribute;
	}

	private String getAttributeFromLine(int type, String lineToFind) {
		String attribute;
		int numParameters = countParameters(lineToFind);

		if (hasValidType(type, numParameters)) {
			attribute = getSpecificWord(type, lineToFind);
		} else {
			attribute = null;
		}
		return attribute;
	}

	private boolean hasValidType(int type, int numParameters) {
		if (numParameters > type && type >= PARAM_FIRST_WORD) {
			return true;
		} else {
			return false;
		}
	}

	private String findItemTypeFromFile(int lineNumber) throws IOException,
			IllegalArgumentException {
		ArrayList<String> fileContents = new ArrayList<String>();

		addFileContentsToArrayList(fileContents);

		throwIllegalArgExceptionIfInvalid(lineNumber, fileContents);

		String lineToFind = fileContents.get(lineNumber - PARAM_OFFSET);
		String itemType = getFirstWord(lineToFind);

		return itemType;
	}

	private void throwIllegalArgExceptionIfInvalid(int lineNumber,
			ArrayList<String> fileContents) {
		if (!isValidLineNumber(lineNumber, fileContents)) {
			String errorMessage = String.format(
					MESSAGE_ERROR_INVALID_LINE_ACCESS, lineNumber);
			throw new IllegalArgumentException(errorMessage);
		}
	}

	private void addFileContentsToArrayList(ArrayList<String> fileContents)
			throws IOException {
		initialiseReader();

		while (true) {
			String lineRead = fileReader.readLine();

			if (isEndOfFile(lineRead)) {
				break;
			} else {
				fileContents.add(lineRead);
			}
		}

		fileReader.close();
	}

	private boolean isValidLineNumber(int lineNumber,
			ArrayList<String> fileContents) {
		if (lineNumber <= PARAM_LINE_NUMBER_ZERO) {
			logger.log(Level.FINE, String.format(MESSAGE_LOG_LINE_VALIDATION,
					lineNumber, fileContents.size()));
			return false;
		} else if (lineNumber > fileContents.size()) {
			logger.log(Level.FINE, String.format(MESSAGE_LOG_LINE_VALIDATION,
					lineNumber, fileContents.size()));
			return false;
		} else {
			return true;
		}
	}

	private String showAllFileContents() throws IOException {
		String fileContents = readContentFromFile();

		return fileContents;
	}

	private String readContentFromFile() throws IOException {
		StringBuilder fileContents = new StringBuilder();

		readLineByLine(fileContents);

		return fileContents.toString();
	}

	private void readLineByLine(StringBuilder fileContents) throws IOException {
		initialiseReader();

		while (true) {
			String lineRead = fileReader.readLine();

			if (isEndOfFile(lineRead)) {
				break;
			} else {
				fileContents.append(lineRead);
				fileContents.append(NEWLINE);
			}
		}

		fileReader.close();
	}

	private String markAsCompleted(int lineNumber) throws IOException,
			IllegalArgumentException {
		ArrayList<String> fileContents = new ArrayList<String>();

		addFileContentsToArrayList(fileContents);

		throwIllegalArgExceptionIfInvalid(lineNumber, fileContents);

		String lineToMarkDone = fileContents.get(lineNumber - PARAM_OFFSET);
		String typeToMarkDone = getFirstWord(lineToMarkDone);

		if (typeToMarkDone.equals(STRING_TASK)) {
			markTaskAsComplete(lineNumber, lineToMarkDone, typeToMarkDone);
		} else if (typeToMarkDone.equals(STRING_EVENT)) {
			markEventAsComplete(lineNumber, lineToMarkDone, typeToMarkDone);
		} else if (typeToMarkDone.equals(STRING_FLOAT_TASK)) {
			markFloatAsComplete(lineNumber, lineToMarkDone, typeToMarkDone);
		} else {
			logger.log(Level.WARNING,
					String.format(MESSAGE_LOG_UNKNOWN_TYPE, lineNumber));
			throw new IOException();
		}

		return lineToMarkDone;
	}

	private void markFloatAsComplete(int lineNumber, String lineToMarkDone,
			String typeToMarkDone) throws IOException {
		FloatingTask choosenFloat = new FloatingTask(lineToMarkDone);

		if (choosenFloat.isDone()) {
			String errorMessage = String.format(MESSAGE_ERROR_ALREADY_DONE,
					typeToMarkDone, choosenFloat.getName());
			throw new IllegalArgumentException(errorMessage);
		}

		choosenFloat.setDone(true);

		deleteLineFromFile(lineNumber);
		addFloatTaskToFile(choosenFloat);
	}

	private void markTaskAsComplete(int lineNumber, String lineToMarkDone,
			String typeToMarkDone) throws IOException {
		Task choosenTask = new Task(lineToMarkDone);

		if (choosenTask.isDone()) {
			String errorMessage = String.format(MESSAGE_ERROR_ALREADY_DONE,
					typeToMarkDone, choosenTask.getName());
			throw new IllegalArgumentException(errorMessage);
		}

		choosenTask.setDone(true);

		deleteLineFromFile(lineNumber);
		addTaskToFile(choosenTask);
	}

	private void markEventAsComplete(int lineNumber, String lineToMarkDone,
			String typeToMarkDone) throws IOException {
		Event choosenEvent = new Event(lineToMarkDone);

		if (choosenEvent.isDone()) {
			String errorMessage = String.format(MESSAGE_ERROR_ALREADY_DONE,
					typeToMarkDone, choosenEvent.getName());
			throw new IllegalArgumentException(errorMessage);
		}

		choosenEvent.setDone(true);

		deleteLineFromFile(lineNumber);
		addEventToFile(choosenEvent);
	}

	private boolean isEndOfFile(String lineRead) {
		return lineRead == null;
	}

	private String changeFilePath(String newLocation) {
		int changePathSituation;

		try {
			closeStreamsIfOpen();
			changePathSituation = checkChangePathSituation(newLocation);
		} catch (IOException exception) {
			logger.log(Level.WARNING, MESSAGE_LOG_CHANGE_PATH);
			return MESSAGE_ERROR_CHANGING_FILE_PATH_UNKNOWN;
		}

		String feedback;

		switch (changePathSituation) {
			case SITUATION_SAME_FILE :
				return MESSAGE_SAME_FILE;
			case SITUATION_MOVE_FILE :
				feedback = moveFile(newLocation);
				return feedback;
			case SITUATION_CHANGE_LOCATION :
				feedback = changeLocation(newLocation);
				return feedback;
			case SITUATION_CONFLICT_FILES :
				return MESSAGE_ERROR_CHANGING_FILE_PATH_CONFLICT;
			default :
				logger.log(Level.WARNING, String.format(
						MESSAGE_LOG_UNKNOWN_SITUATION, changePathSituation));
				return MESSAGE_ERROR_CHANGING_FILE_PATH_UNKNOWN;
		}
	}

	private void closeStreamsIfOpen() throws IOException {
		if (fileReader != null) {
			fileReader.close();
		}
		if (fileWriter != null) {
			fileWriter.close();
		}
	}

	private String changeLocation(String newLocation) {
		File oldFilePath = new File(getAbsoluteFilePath());

		try {
			configHandler.updateConfigFile(newLocation);
		} catch (FileNotFoundException exception) {
			logger.log(Level.WARNING, MESSAGE_LOG_CHANGE_PATH);
			return MESSAGE_ERROR_CHANGING_FILE_PATH_UNKNOWN;
		}

		updateFilePath(newLocation);

		oldFilePath.delete();

		return String.format(MESSAGE_CHANGE_STORAGE_SUCCESS, getFilePath());
	}

	private String moveFile(String newLocation) {
		File oldFilePath = new File(getAbsoluteFilePath());
		ArrayList<String> fileContents = new ArrayList<String>();

		try {
			addFileContentsToArrayList(fileContents);

			updateFilePath(newLocation);

			copyContentsToNewFile(newLocation, fileContents);
		} catch (IOException exception) {
			filePath = oldFilePath.getPath();
			return MESSAGE_ERROR_CHANGING_FILE_PATH;
		}

		oldFilePath.delete();

		return String.format(MESSAGE_CHANGE_STORAGE_SUCCESS, getFilePath());
	}

	private void updateFilePath(String newLocation) {
		if (hasDirectorySpecifiedInPath(newLocation)) {
			filePath = String.format(COLLATED_FILE_PATH_FORMAT, newLocation,
					FILE_NAME);
		} else {
			filePath = FILE_NAME;
		}
	}

	private int checkChangePathSituation(String newPathLocation)
			throws IOException {
		String newCompletePath = String.format(COLLATED_FILE_PATH_FORMAT,
				newPathLocation, FILE_NAME);

		if (isSameFile(newCompletePath)) {
			return SITUATION_SAME_FILE;
		}

		if (isExistingFile(newCompletePath)) {
			if (isEmptyFile(newCompletePath)) {
				return SITUATION_MOVE_FILE;
			} else if (isEmptyFile(filePath)) {
				return SITUATION_CHANGE_LOCATION;
			} else {
				return SITUATION_CONFLICT_FILES;
			}
		} else {
			return SITUATION_MOVE_FILE;
		}
	}

	private boolean isSameFile(String newCompletePath) {
		String nameOfOldFile = getAbsoluteFilePath();
		String nameOfNewFile = new File(newCompletePath).getAbsolutePath();

		return nameOfOldFile.equals(nameOfNewFile);
	}

	private boolean isExistingFile(String filePathLocation) {
		File fileToCheck = new File(filePathLocation);
		if (fileToCheck.exists()) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isEmptyFile(String filePathLocation) throws IOException {
		String lineRead = readFirstLine(filePathLocation);

		if (isEndOfFile(lineRead)) {
			return true;
		} else {
			return false;
		}
	}

	private void copyContentsToNewFile(String newLocation,
			ArrayList<String> fileContents) throws IOException {
		createToDoListFile();
		writeContentsToFile(fileContents);
		configHandler.updateConfigFile(newLocation);
	}

	private String[] splitParameters(String line) {
		return line.split(TEXT_FILE_DIVIDER);
	}

	private String getFirstWord(String text) {
		return getSpecificWord(PARAM_FIRST_WORD, text);
	}

	private String getSpecificWord(int wordNumber, String text) {
		String parameters[] = splitParameters(text);
		String specificWord = parameters[wordNumber];

		return specificWord;
	}

	private int countParameters(String text) {
		String parameters[] = splitParameters(text);
		int numberParameters = parameters.length;

		return numberParameters;
	}

	private void initialiseHandler() throws FileSystemException {
		assert (configHandler == null);

		configHandler = new ConfigHandler();
	}

	private boolean hasDirectorySpecifiedInPath(String readFilePath) {
		if (isEndOfFile(readFilePath)) {
			return false;
		} else if (readFilePath.trim().equals(EMPTY_STRING)) {
			return false;
		} else {
			return true;
		}
	}

	private String readFirstLine(String givenFilePath) throws IOException {
		FileReader fileToBeRead = new FileReader(givenFilePath);
		BufferedReader customFileReader = new BufferedReader(fileToBeRead);

		String lineRead = customFileReader.readLine();
		customFileReader.close();

		return lineRead;
	}

	private void createToDoListFile() throws FileSystemException {
		File file = new File(filePath);

		if (hasDirectorySpecifiedInPath()) {
			createDirectoryIfMissing(file);
		}

		createNewFileIfFileDoesNotExist(file);
	}

	private boolean hasDirectorySpecifiedInPath() {
		return !filePath.equals(FILE_NAME);
	}

	private void createDirectoryIfMissing(File file) {
		file.getParentFile().mkdirs();
	}

	private void createNewFileIfFileDoesNotExist(File file)
			throws FileSystemException {
		try {
			file.createNewFile();
		} catch (IOException exception) {
			throw new FileSystemException(MESSAGE_ERROR_CREATE_FILE);
		}
	}

	private String getAbsoluteFilePath() {
		return new File(filePath).getAbsolutePath();
	}

	private void initialiseReader() throws FileNotFoundException {
		FileReader fileToBeRead = new FileReader(filePath);
		fileReader = new BufferedReader(fileToBeRead);
	}

	private void initialiseWriter() throws FileNotFoundException {
		fileWriter = new PrintWriter(filePath);
	}

	private void writeContentsToFile(ArrayList<String> fileContents)
			throws FileNotFoundException {
		initialiseWriter();

		int lastLine = fileContents.size() - PARAM_LESS_ONE;

		if (lastLine == PARAM_DOES_NOT_EXIST) {
			fileWriter.print(EMPTY_STRING);
			fileWriter.close();
			return;
		}

		for (int i = PARAM_START_LOOP_ZERO; i < lastLine; i++) {
			fileWriter.println(fileContents.get(i));
		}
		fileWriter.print(fileContents.get(lastLine));

		fileWriter.close();
	}

	private void writeContentsToFile(String textToWrite)
			throws FileNotFoundException {
		initialiseWriter();

		String[] linesToWrite = textToWrite.split(NEWLINE);

		int lastLine = linesToWrite.length - PARAM_LESS_ONE;

		for (int i = PARAM_START_LOOP_ZERO; i < lastLine; i++) {
			fileWriter.println(linesToWrite[i]);
		}
		fileWriter.print(linesToWrite[lastLine]);

		fileWriter.close();
	}
}
```
###### gui\CommandHistory.java
``` java
 */

package gui;

import java.util.ArrayList;

public class CommandHistory {
	private static final int PARAM_FIRST_INDEX = 0;
	private static final int PARAM_SIZE_HIST = 1;
	private static final int PARAM_DEFAULT = -1;
	private static final int OFFSET = 1;
	
	private static final String EMPTY_STRING = "";

    private ArrayList<String> history;
    private int currentIndex;

    /**
     * CommandHistory constructor
     */
    public CommandHistory() {
        history = new ArrayList<String>();
        currentIndex = history.size() - OFFSET;
    }

    /**
     * This method adds a new command to the command history
     * 
     * @param newCommand
     * 		      The command to be added
     */
    public void add(String newCommand) {
        history.add(newCommand);
        currentIndex++;
    }
    
    /**
     * This method resets the index to the most recent command entered
     */
    public void resetIndex() {
        currentIndex = history.size() - OFFSET;
    }

    /**
     * This method returns the previous command entered by the user
     * 
     * @return The previous command relative to the current index of command history
     */
    protected String getPrevious() {

    	// If command history is empty
    	if (history.isEmpty()) {
    		return EMPTY_STRING;
    	} else if (currentIndex == PARAM_FIRST_INDEX) {
    		// currentIndex = 0, meaning the user has viewed till the very first command
    		return history.get(currentIndex);
    	} else if (currentIndex == history.size() - OFFSET) {
    		// currentIndex = history.size() - 1, meaning the user has viewed till the 
    		// very last command
    		String returnCommand = history.get(currentIndex);
    		// If the returned command is the same as the one already displayed, display the
    		// previous command instead. Only works for history.size() > 1
    		if (isSameAsDisplayed(returnCommand) && history.size() > PARAM_SIZE_HIST) {
    			currentIndex--;
    			returnCommand = history.get(currentIndex);
    		}
    		return returnCommand;
    	} else if (currentIndex == PARAM_DEFAULT) {
    		currentIndex++;
    		return history.get(currentIndex);
    	} else {
    		currentIndex--;
    		String returnCommand = history.get(currentIndex);
    		return returnCommand;
    	}
    }

    /**
     * This method returns the next command entered by the user
     * 
     * @return The next command relative to the current index of command history
     */
    protected String getNext() {

    	// If command history is empty
    	if (history.isEmpty()) {
    		return EMPTY_STRING;
    	} else if (currentIndex == history.size() - OFFSET) {
    		// currentIndex = history.size() - 1, meaning the user has viewed 
    		// till the very last command
    		return history.get(currentIndex);
    	} else if (currentIndex == PARAM_FIRST_INDEX) {
    		// currentIndex = 0, meaning the user has viewed till the very first command
    		String returnCommand = history.get(currentIndex);
    		// If the returned command is the same as the one already displayed, display the
    		// next command instead. Only works for history.size() > 1
    		if (isSameAsDisplayed(returnCommand) && history.size() > PARAM_SIZE_HIST) {
    			currentIndex++;
    			returnCommand = history.get(currentIndex);
    		}
    		return returnCommand;
    	} else if (currentIndex == history.size()) {
    		currentIndex--;
    		return history.get(currentIndex);
    	} else {
    		currentIndex++;
    		String returnCommand = history.get(currentIndex);
    		return returnCommand;
    	}
    }
    
	// ================================================================================
    // Private method used to perform misc operations required for command history
    // ================================================================================
    
    /**
     * This method checks if the command to be returned is the same as the
     * one currently being displayed in the text field
     * 
     * @param returnCommand
     * 			  The command that is returned by either getPrevious() or getNext()
     * @return true if returnCommand is the same as the command displayed in the 
     * 		   text field, false otherwise
     */
    private boolean isSameAsDisplayed(String returnCommand) {
    	String displayed = InterfaceController.getTextField().getText();
    	return returnCommand.equals(displayed);
    }
    
	// ================================================================================
    // Rewrites for JUnit testing, same functionality but removed dependency on GUI
    // Uses a String to simulate the text field output that CommandHistory modifies
    // ================================================================================
    
    private String simulatedTextField;
    
    public void updateField(String update) {
    	simulatedTextField = update;
    }
    
    public String getText() {
    	return simulatedTextField;
    }
    
    public String getPreviousTest() {
    	
    	// If command history is empty
    	if (history.isEmpty()) {
    		return EMPTY_STRING;
    	} else if (currentIndex == PARAM_FIRST_INDEX) {
    		// currentIndex = 0, meaning the user has viewed till the very first command
    		return history.get(currentIndex);
    	} else if (currentIndex == history.size() - OFFSET) {
    		// currentIndex = history.size() - 1, meaning the user has viewed till the 
    		// very last command
    		String returnCommand = history.get(currentIndex);
    		// If the returned command is the same as the one already displayed, display the
    		// previous command instead. Only works for history.size() > 1
    		if (returnCommand.equals(simulatedTextField) && history.size() > PARAM_SIZE_HIST) {
    			currentIndex--;
    			returnCommand = history.get(currentIndex);
    		}
    		return returnCommand;
    	} else if (currentIndex == PARAM_DEFAULT) {
    		currentIndex++;
    		return history.get(currentIndex);
    	} else {
    		currentIndex--;
    		String returnCommand = history.get(currentIndex);
    		return returnCommand;
    	}
    }

    public String getNextTest() {

    	// If command history is empty
    	if (history.isEmpty()) {
    		return EMPTY_STRING;
    	} else if (currentIndex == history.size() - OFFSET) {
    		// currentIndex = history.size() - 1, meaning the user has viewed 
    		// till the very last command
    		return history.get(currentIndex);
    	} else if (currentIndex == PARAM_FIRST_INDEX) {
    		// currentIndex = 0, meaning the user has viewed till the very first command
    		String returnCommand = history.get(currentIndex);
    		// If the returned command is the same as the one already displayed, display the
    		// next command instead. Only works for history.size() > 1
    		if (returnCommand.equals(simulatedTextField) && history.size() > PARAM_SIZE_HIST) {
    			currentIndex++;
    			returnCommand = history.get(currentIndex);
    		}
    		return returnCommand;
    	} else if (currentIndex == history.size()) {
    		currentIndex--;
    		return history.get(currentIndex);
    	} else {
    		currentIndex++;
    		String returnCommand = history.get(currentIndex);
    		return returnCommand;
    	}
    }
}
```
###### gui\Listeners.java
``` java
 */

package gui;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import struct.View;

public class Listeners {
	
	private static final String SPACE = " ";
	
	private static final int PARAM_ONE_WORD = 1;
	
    // ======================================================================
    // Getters to allow GUI components in InterfaceController to access the
    // private ChangeListener classes
    // ======================================================================
	
	// ChangeListeners
	protected static AutoCompleteListener getAutoCompleteListener() {
		return new AutoCompleteListener();
	}
	
	protected static LostFocusListener getLostFocusListener() {
		return new LostFocusListener();
	}
	
	protected static CloseHelpListener getCloseHelpListener() {
		return new CloseHelpListener();
	}
	
	protected static ScrollListener getScrollListener(View scrollpane) {
		return new ScrollListener(scrollpane);
	}
	
	protected static WidthPositionListener getWidthPositionListener() {
		return new WidthPositionListener();
	}
	
	protected static HeightPositionListener getHeightPositionListener() {
		return new HeightPositionListener();
	}
	
	protected static HeightListener getHeightListener() {
		return new HeightListener();
	}
	
	protected static WidthListener getWidthListener() {
		return new WidthListener();
	}
	
    // ======================================================================
    // Private ChangeListener class definitions
    // ======================================================================
	
    /**
     * This method implements a listener that displays and updates the autocomplete
     * popup in real time based on the current input that is being entered by the 
     * user
     */
    protected static class AutoCompleteListener implements ChangeListener<String> {
    	@Override
    	public void changed(ObservableValue<? extends String> observable, 
    			String oldValue, String newValue) {
    		// Only perform autocompletion when the string is within one word
    		// and is not empty
    		if (newValue.split(SPACE).length == PARAM_ONE_WORD && !newValue.equals(LogicController.NULL_STRING)) {
    			AutoComplete.updatePopup(newValue);
    		} else {
    			AutoComplete.closePopup();
    		}
    	}
    }
    
    /**
     * This class implements a listener for the main stage that decides whether
     * to keep the autocomplete listener open when focus on the main stage is lost
     */
    private static class LostFocusListener implements ChangeListener<Boolean> {
    	boolean showingBeforeLostFocus = false;
    	
    	@Override
    	public void changed(ObservableValue<? extends Boolean> observable, 
    			Boolean oldValue, Boolean newValue) {
    		        	
    		if (!newValue) {
    			showingBeforeLostFocus = AutoComplete.isShowing();
    			AutoComplete.closePopup();
    		} else {
    			if (showingBeforeLostFocus) {
    				AutoComplete.showPopup();
    			}
    		}
    	}
    }
    
    /**
     * This class implements a listener for the help stage to detect if the window
     * has been closed with a mouse click, and respond with the correct method call
     * to compensate (set isShowing status and toggling the button)
     */
    private static class CloseHelpListener implements ChangeListener<Boolean> {
    	@Override
    	public void changed(ObservableValue<? extends Boolean> observable, 
    			Boolean oldValue, Boolean newValue) {
    		// If the help window was closed by user's mouse click
    		if (newValue == false) {
    			// Do not toggle to avoid resetting the help open/close state
    			HelpController.closeHelpDialog();
    		}
    	}
    }
    
    /**
     * This class implements a listener for the scroll pane in the history view that
     * automatically scrolls the window to the most recently added element at the bottom
     */
    private static class ScrollListener implements ChangeListener<Number> {
    	View scrollpane;
    	
    	ScrollListener(View scrollpane) {
    		this.scrollpane = scrollpane;
    	}
    	
    	@Override
    	public void changed(ObservableValue<? extends Number> observable, 
    			Number oldValue, Number newValue) {
    		
    		// Set the v-value of the scroll pane to the height of the content box
    		switch (scrollpane) {
    		case HISTORY:
    			HistoryViewController.getHistScroll().setVvalue((Double)newValue);
    			break;
    		default:
    			// Ignore, should not enter
    			break;
    		}
    	}
    }
    
    /**
     * This class implements a listener for the autocomplete popup that adjusts its
     * horizontal position based on the location of the window
     */
    private static class WidthPositionListener implements ChangeListener<Number> {
    	@Override
    	public void changed(ObservableValue<? extends Number> observable, 
    			Number oldValue, Number newValue) {
    		AutoComplete.setX((double)newValue);
    	}
    }
    
    /**
     * This class implements a listener for the autocomplete popup that adjusts its
     * vertical position based on the location of the window
     */
    private static class HeightPositionListener implements ChangeListener<Number> {
    	@Override
    	public void changed(ObservableValue<? extends Number> observable, 
    			Number oldValue, Number newValue) {
    		AutoComplete.setY((double)newValue);
    	}
    }
    
    /**
     * This class implements a listener for the main window to resize all of its
     * internal components when the overall height changes
     */
    private static class HeightListener implements ChangeListener<Number> {
    	@Override
    	public void changed(ObservableValue<? extends Number> observable,
    			Number oldValue, Number newValue) {

    		// Set the height of the sidebar separator to window height
    		InterfaceController.getSbLine().setEndY((Double)newValue);

    		// Set the height of the scroll pane separator to
    		// window height - height of the filepath bar(31) -
    		// height of feedback bar(31) - height of text bar(40) - 
    		// height of viewLine(1)
    		DefaultViewController.getDefScrollLine().setEndY((Double)newValue - 
    				InterfaceController.HEIGHT_FILEPATH - 
    				InterfaceController.HEIGHT_FEEDBACK - 
    				InterfaceController.HEIGHT_TEXT_BOX - 
    				InterfaceController.HEIGHT_HORIZ_LINE);
    		
    		AutoComplete.setY(MainApp.stage.getY());
    	}
    }

    /**
     * This class implements a listener for the main window to resize all of its
     * internal components when the overall width changes
     */
    private static class WidthListener implements ChangeListener<Number> {
    	@Override
    	public void changed(ObservableValue<? extends Number> observable,
    			Number oldValue, Number newValue) {

    		// Set the width of the feedback, filepath and view box separators to
    		// window width - size of sidebar(50) - width of line(1)
    		InterfaceController.getFeedbackLine().setEndX(
    				(Double)newValue - InterfaceController.WIDTH_SIDEBAR);
    		InterfaceController.getViewLine().setEndX(
    				(Double)newValue - InterfaceController.WIDTH_SIDEBAR);
    		InterfaceController.getFilepathLine().setEndX(
    				(Double)newValue - InterfaceController.WIDTH_SIDEBAR);
    	}
    }
}
```
###### gui\ViewIndexMap.java
``` java
 */

package gui;

import java.util.ArrayList;

import struct.View;

public class ViewIndexMap {

	private static final int INDEX_OFFSET = -1;
	
	// Each of the individual elements is the file index of the ith
	// element in the array.
	// Array index = view index
	// Array element = file index
	private static ArrayList<Integer> defMap;
	private static ArrayList<Integer> allMap;
	private static ArrayList<Integer> searchMap;
	private static ArrayList<Integer> unresMap;
	private static ArrayList<Integer> doneMap;
	
	public static void initAllMaps() {
		
		defMap = new ArrayList<Integer>();
		allMap = new ArrayList<Integer>();
		searchMap = new ArrayList<Integer>();
		unresMap = new ArrayList<Integer>();
		doneMap = new ArrayList<Integer>();
		
		// Add an element to index 0 to offset the starting index
		defMap.add(INDEX_OFFSET);
		allMap.add(INDEX_OFFSET);
		searchMap.add(INDEX_OFFSET);
		unresMap.add(INDEX_OFFSET);
		doneMap.add(INDEX_OFFSET);
	}
	
	// ============================================================
	// Getters to access the individual view maps
	// ============================================================
	
	public static int getFromDefMap(int viewIndex) {
		if (viewIndex >= defMap.size()) {
			return INDEX_OFFSET;
		} else if (viewIndex <= 0) {
			return viewIndex;
		} else {
			return defMap.get(viewIndex);
		}
	}
	
	public static int getFromAllMap(int viewIndex) {
		if (viewIndex >= allMap.size()) {
			return INDEX_OFFSET;
		} else if (viewIndex <= 0) {
			return viewIndex;
		} else {
			return allMap.get(viewIndex);
		}
	}
	
	static int getFromSearchMap(int viewIndex) {
		if (viewIndex >= searchMap.size()) {
			return INDEX_OFFSET;
		} else if (viewIndex <= 0) {
			return viewIndex;
		} else {
			return searchMap.get(viewIndex);
		}
	}

	static int getFromUnresMap(int viewIndex) {
		if (viewIndex >= unresMap.size()) {
			return INDEX_OFFSET;
		} else if (viewIndex <= 0) {
			return viewIndex;
		} else {
			return unresMap.get(viewIndex);
		}
	}
	
	public static int getFromDoneMap(int viewIndex) {
		if (viewIndex >= doneMap.size()) {
			return INDEX_OFFSET;
		} else if (viewIndex <= 0) {
			return viewIndex;
		} else {
			return doneMap.get(viewIndex);
		}
	}
	
	/**
	 * This method calls the correct get() operation based on the current view
	 * the user is in
	 * 
	 * @param viewIndex
	 * 		      The index as seen by the user displayed by the view
	 * @return The index of the element within the text file
	 */
	public static int get(int viewIndex) {
		switch (InterfaceController.getCurrentView()) {
			case DEFAULT:
				return getFromDefMap(viewIndex);
			case ALL:
				return getFromAllMap(viewIndex);
			case UNRESOLVED:
				return getFromUnresMap(viewIndex);
			case SEARCH:
				return getFromSearchMap(viewIndex);
			case DONE:
				return getFromDoneMap(viewIndex);
			default:
				// Should not enter
				return INDEX_OFFSET;
		}
	}
	
	// ============================================================
	// Setters to access the individual view maps
	// ============================================================
	
	public static void addToDefMap(int fileIndex) {
		defMap.add(fileIndex);
	}
	
	public static void addToAllMap(int fileIndex) {
		allMap.add(fileIndex);
	}
	
	public static void addToSearchMap(int fileIndex) {
		searchMap.add(fileIndex);
	}
	
	public static void addToUnresMap(int fileIndex) {
		unresMap.add(fileIndex);
	}
	
	public static void addToDoneMap(int fileIndex) {
		doneMap.add(fileIndex);
	}
	
	/**
	 * This method calls the correct add() method based on input view
	 * 
	 * @param targetView
	 * 		      The View to add the file index to
	 * @param fileIndex
	 * 		      The index on the element within the file
	 */
	public static void add(View targetView, int fileIndex) {
		switch (targetView) {
			case DEFAULT:
				addToDefMap(fileIndex);
				break;
			case ALL:
				addToAllMap(fileIndex);
				break;
			case UNRESOLVED:
				addToUnresMap(fileIndex);
				break;
			case SEARCH:
				addToSearchMap(fileIndex);
				break;
			case DONE:
				addToDoneMap(fileIndex);
				break;
			default:
				// Should not enter
				break;
		}
	}
	
	public static void setDefMap(int viewIndex, int fileIndex) {
		defMap.set(viewIndex, fileIndex);
	}
	
	public static void setAllMap(int viewIndex, int fileIndex) {
		allMap.set(viewIndex, fileIndex);
	}
	
	public static void setSearchMap(int viewIndex, int fileIndex) {
		searchMap.set(viewIndex, fileIndex);
	}
	
	public static void setUnresMap(int viewIndex, int fileIndex) {
		unresMap.set(viewIndex, fileIndex);
	}
	
	public static void setDoneMap(int viewIndex, int fileIndex) {
		doneMap.set(viewIndex, fileIndex);
	}
	
	// ============================================================
	// Reset functions to reset the view maps during updates
	// ============================================================
	
	public static void resetDefMap() {
		defMap = new ArrayList<Integer>();
		defMap.add(INDEX_OFFSET);
	}
	
	public static void resetAllMap() {
		allMap = new ArrayList<Integer>();
		allMap.add(INDEX_OFFSET);
	}
	
	public static void resetSearchMap() {
		searchMap = new ArrayList<Integer>();
		searchMap.add(INDEX_OFFSET);
	}
	
	public static void resetUnresMap() {
		unresMap = new ArrayList<Integer>();
		unresMap.add(INDEX_OFFSET);
	}
	
	public static void resetDoneMap() {
		doneMap = new ArrayList<Integer>();
		doneMap.add(INDEX_OFFSET);
	}
}
```
###### struct\Alias.java
``` java
 */

package struct;

public class Alias implements Comparable<Alias> {

	private static final String SEPARATOR = " : ";
	
	private String alias;
	private String original;

	public Alias(String alias, String original) {
		this.alias = alias;
		this.original = original;
	}

	public String getAlias() {
		return alias;
	}

	public String getOriginal() {
		return original;
	}

	public boolean isUserDefined() {
		return !alias.equals(original);
	}

	@Override
	public String toString() {
		// Display both the alias and original if it is user defined
		if (isUserDefined()) {
			return alias + SEPARATOR + original;
		} else {
			return alias;
		}
	}

	@Override
	public int compareTo(Alias b) {
		if (this.alias.equals(b.alias)) {
			return this.original.compareTo(b.original);
		} else {
			return this.alias.compareTo(b.alias);
		}
	}
}
```
###### struct\Date.java
``` java
 */

package struct;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Date implements Comparable<Date>{
	private static final String EMPTY_STRING = "";
	private static final String DAY_MONTH_YEAR = "ddMMyy";
	private static final String DATE_LONG_FORMAT = "EEE, dd MMM yyyy";
	private static final String DATE_LONG_SHORT_YEAR_FORMAT = "EEE, dd MMM yy";
	private static final String DATE_LONG_NO_YEAR_FORMAT = "EEE, dd MMM";
	
	private static final String DAY_STRING = "EEEE";
	
	private static final int INVALID = -1;
	private static final int FIRST_DATE = 1;
	private static final int YEAR_2000 = 2000;
	private static final int PARAM_FIRST_CHAR = 0;
	private static final int PARAM_THIRD_CHAR = 2;
	private static final int PARAM_FIFTH_CHAR = 4;
	
	private static final int SAME_DATE = 0;
	private static final int EARLIER_DATE = -1;
	private static final int LATER_DATE = 1;
	
	private static final int OFFSET = 1;
	private static final int NUM_PARAM_DATE = 6;
	
    // fullDate is in the format ddMMyy
    private String fullDate;
    private int day, month, year;
    
	//============================================
	// Constructors
	//============================================

    public Date() {
        this.fullDate = EMPTY_STRING;
        this.day = INVALID;
        this.month = INVALID;
        this.year = INVALID;
    }
    
    public Date(String fullDate){
    	this.fullDate = fullDate;
        this.day = Integer.parseInt(fullDate.substring(PARAM_FIRST_CHAR, PARAM_THIRD_CHAR));
        this.month = Integer.parseInt(fullDate.substring(PARAM_THIRD_CHAR, PARAM_FIFTH_CHAR));
        this.year = YEAR_2000 + Integer.parseInt(fullDate.substring(PARAM_FIFTH_CHAR));
    }
    
    //============================================
    // Static methods 
    //============================================
    
    public static String todayDateShort(){
    	Calendar cal = Calendar.getInstance(); 
    	
    	SimpleDateFormat sdf = new SimpleDateFormat(DAY_MONTH_YEAR); 
    	return sdf.format(cal.getTime());
    }
    
    public static String tomorrowDateShort(){
    	Calendar cal = Calendar.getInstance(); 
    	cal.add(Calendar.DATE, FIRST_DATE); 
    	
    	SimpleDateFormat sdf = new SimpleDateFormat(DAY_MONTH_YEAR); 
    	return sdf.format(cal.getTime());
    }
    
    public static String todayDateLong(){
    	Calendar cal = Calendar.getInstance(); 
    	
    	SimpleDateFormat sdf = new SimpleDateFormat(DATE_LONG_FORMAT); 
    	return sdf.format(cal.getTime());
    }
    
    public static String tomorrowDateLong(){
    	Calendar cal = Calendar.getInstance();
    	cal.add(Calendar.DATE, FIRST_DATE); 
    	
    	SimpleDateFormat sdf = new SimpleDateFormat(DATE_LONG_FORMAT); 
    	return sdf.format(cal.getTime());
    }
    
    public static Date todayDate(){
    	 return new Date(Date.todayDateShort()); 
    }
    
    public static Date tomorrowDate() {
    	return new Date(Date.tomorrowDateShort());
    }

	//============================================
	// Public methods
	//============================================    
    
    /**
	 * compareTo
	 * @return -1 if this < other 
	 * 		    1 if this > other 
	 * 		    0 if this == other         
	 */
    public int compareTo(Date other){
    	int thisDateInt = getIntReverseDate(this); 
    	int otherDateInt = getIntReverseDate(other); 
    	if(thisDateInt < otherDateInt){
    		return EARLIER_DATE; 
    	}
    	else if(thisDateInt > otherDateInt){
    		return LATER_DATE; 
    	}
    	else{
    		return SAME_DATE; 
    	}
    }
    
    public String getDayString() {
        Calendar cal = Calendar.getInstance(); 
        cal.set(this.year, this.month - OFFSET, this.day);
        
        SimpleDateFormat sdf = new SimpleDateFormat(DAY_STRING);
        return sdf.format(cal.getTime());
    }
    
    /**
     * Returns a Date object corresponding to daysToAdd days after 
     * this Date. Note: This Date object is not updated.
     * 
     * Example:
     * Date newDate = new Date("290915");
     * Date oneDayLater = newDate.plusDay(1);
     * 
     * newDate will be still at "290915" whereas oneDayLater is at "300915"
     * 
     * @param daysToAdd   number of days to add to this Date.
     * @return            Date object after daysToAdd days from this Date.
     */
    public Date plusDay(int daysToAdd) {	
        Calendar cal = Calendar.getInstance(); 
        cal.set(this.year, this.month - OFFSET, this.day);
        cal.add(Calendar.DATE, daysToAdd);
        
        SimpleDateFormat sdf = new SimpleDateFormat(DAY_MONTH_YEAR);
        return new Date(sdf.format(cal.getTime()));
    }

    public String formatDateShort() {
        return fullDate;
    }
    
    public String formatDateMedium(){ 
    	Calendar cal = Calendar.getInstance(); 
    	int todayYear = cal.get(Calendar.YEAR);
    	cal.set(this.year, this.month - OFFSET, this.day);
    	
    	SimpleDateFormat sdf = getDateFormat(todayYear);
    	return sdf.format(cal.getTime());
    }
    
    public String formatDateLong(){ 
    	Calendar cal = Calendar.getInstance(); 
    	cal.set(this.year, this.month - OFFSET, this.day);
    	
    	SimpleDateFormat sdf = new SimpleDateFormat(DATE_LONG_FORMAT); 
    	return sdf.format(cal.getTime());
    }

	//============================================
	// Private methods 
	//============================================
    
    private int getIntReverseDate(Date date){
    	String dateString = date.formatDateShort(); 
    	return getIntDate(getReverseDate(dateString));
    }
    
    /**
     * Converts a DDMMYY formatted date into a YYMMDD formatted date for easier
     * integer comparison.
     *
     * @param date
     *            The date entered by the user in DDMMYY format
     * @return date in YYMMDD format
     */
    private String getReverseDate(String date) {
        return date.substring(PARAM_FIFTH_CHAR) + date.substring(PARAM_THIRD_CHAR, PARAM_FIFTH_CHAR)
        		+ date.substring(PARAM_FIRST_CHAR, PARAM_THIRD_CHAR);
    }
    
    /**
     * Converts a date string into an integer for direct comparison. Works only
     * with YYMMDD format.
     *
     * @param yymmdd
     *            The date to be converted into an integer
     * @return yymmdd as an integer
     */
    private int getIntDate(String yymmdd) {
    	assert(yymmdd.length() == NUM_PARAM_DATE);
    	
        return Integer.parseInt(yymmdd);
    }
    
	private SimpleDateFormat getDateFormat(int todayYear) {
    	if(todayYear == this.year){
    		return new SimpleDateFormat(DATE_LONG_NO_YEAR_FORMAT); 
    	}
    	else{ 
    		return new SimpleDateFormat(DATE_LONG_SHORT_YEAR_FORMAT); 
    	}
	}
}
```
###### struct\FloatingTask.java
``` java
 */

package struct;

public class FloatingTask extends TodoItem implements Comparable<FloatingTask>{
	
	private static final String SEMICOLON = ";";
	
	private static final String FORMAT_TO_STRING = "float;%s;%s";
	
	private static final String STRING_FLOAT = "float";
	private static final String STRING_DONE = "done";
	private static final String STRING_NOT_DONE = "todo";
	
	private static final int PARAM_TYPE = 0;
	private static final int PARAM_NAME = 1;
	private static final int PARAM_DONE = 2;
	private static final int NUM_PARAM_FLOAT_TASK = 3;

	//============================================
	// Constructors
	//============================================
	
	public FloatingTask() {
		super(); 
	}
	
	public FloatingTask(String line){ 
		line.trim();
    	String[] lineComponents = line.split(SEMICOLON);
    	
    	assert(lineComponents[PARAM_TYPE].equals(STRING_FLOAT));
    	assert(lineComponents.length == NUM_PARAM_FLOAT_TASK);
    	
    	this.name = lineComponents[PARAM_NAME]; 
    	this.isDone = lineComponents[PARAM_DONE].equals(STRING_DONE); 
	}
	
	public FloatingTask(String name, boolean isDone){
		super(name, isDone);
	}
	
	//============================================
	// Public Methods
	//============================================
	
	/**
	 * compareTo
	 * @return negative number if this < other 
	 * 		   positive number if this > other 
	 * 		   zero if this == other         
	 */
	public int compareTo(FloatingTask other){ 
		return this.getName().compareTo(other.getName());
	}
	
	/**
	 * toString 
	 * @return formatted string to write into txt file
	 */
	public String toString(){
		String status;
		if (this.isDone) {
			status = STRING_DONE;
		} else {
			status = STRING_NOT_DONE;
		}
		return String.format(FORMAT_TO_STRING, this.name, status); 
	}	
}
```
###### struct\TodoItem.java
``` java
 */

package struct;

public abstract class TodoItem {
	
	protected String name; 
	protected boolean isDone;
	
	//============================================
	// Constructor
	//============================================
	
	public TodoItem(){
		this.name = ""; 
		this.isDone = false;
	}
	
	public TodoItem(String name, boolean isDone) {
		this.name = name;
		this.isDone = isDone;
	}
	
	//============================================
	// Getters
	//============================================	

	public String getName() {
		return name;
	}

	public boolean isDone() {
		return isDone;
	}

	//============================================
	// Setters
	//============================================

	public void setName(String name) {
		this.name = name;
	}

	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}

}
```
###### struct\View.java
``` java
 */

package struct;

public enum View {
	SUMMARY, DEFAULT, ALL, HISTORY, UNRESOLVED, DONE, SEARCH, HELP, EXIT
}
```
###### test\StorageTest.java
``` java
 */

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;

import java.nio.file.FileSystemException;

import backend.Storage;

import struct.Date;
import struct.FloatingTask;
import struct.Event;
import struct.Task;

public class StorageTest {

	@Test
	// Tests if tasks are sorted properly.
	public void testAddTask() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addTask(new Task("banana", false, new Date("251215")));
		storage.addTask(new Task("apple", false, new Date("251115")));
		storage.addTask(new Task("guava", false, new Date("101215")));
		storage.addTask(new Task("orange", false, new Date("261115")));
		storage.addTask(new Task("pear", false, new Date("241215")));
		storage.addTask(new Task("avocado", false, new Date("010115")));
		storage.addTask(new Task("watermelon", false, new Date("010116")));
		storage.addTask(new Task("animal", false, new Date("010115")));
		storage.addTask(new Task("wintermelon", false, new Date("010116")));
		storage.addTask(new Task("kiwi", false, new Date("251215")));

		assertEquals(
				"task;animal;todo;010115\ntask;avocado;todo;010115\ntask;apple;todo;251115\n"
						+ "task;orange;todo;261115\ntask;guava;todo;101215\ntask;pear;todo;241215\n"
						+ "task;banana;todo;251215\ntask;kiwi;todo;251215\ntask;watermelon;todo;010116\n"
						+ "task;wintermelon;todo;010116\n", storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Tests if Floating Task are sorted properly.
	public void testAddFloatingTask() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dancing at the bar", false));
		storage.addFloatingTask(new FloatingTask("train a dragon", false));
		storage.addFloatingTask(new FloatingTask("fly a kite", false));
		storage.addFloatingTask(new FloatingTask("eat something nice", false));
		storage.addFloatingTask(new FloatingTask("kill a monster", false));
		storage.addFloatingTask(new FloatingTask("uniqlo shopping", false));
		storage.addFloatingTask(new FloatingTask("catch a dreamcatcher", false));

		assertEquals(
				"float;catch a dreamcatcher;todo\nfloat;dancing at the bar;todo\n"
						+ "float;eat something nice;todo\n"
						+ "float;fly a kite;todo\nfloat;kill a monster;todo\n"
						+ "float;train a dragon;todo\nfloat;uniqlo shopping;todo\n",
				storage.display());

		storage.addFloatingTask(new FloatingTask("catch a catcher", false));
		storage.addFloatingTask(new FloatingTask("catch a dreamer", false));

		assertEquals(
				"float;catch a catcher;todo\nfloat;catch a dreamcatcher;todo\n"
						+ "float;catch a dreamer;todo\nfloat;dancing at the bar;todo\n"
						+ "float;eat something nice;todo\n"
						+ "float;fly a kite;todo\nfloat;kill a monster;todo\n"
						+ "float;train a dragon;todo\nfloat;uniqlo shopping;todo\n",
				storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Tests if events are sorted properly.
	public void testAddEvent() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Test different start time.
		storage.addEvent(new Event("prom night", false, new Date("101015"),
				new Date("101015"), "1700", "2359"));
		storage.addEvent(new Event("class chalet", false, new Date("101015"),
				new Date("101015"), "0800", "2359"));

		assertEquals("event;class chalet;todo;101015;0800;101015;2359\n"
				+ "event;prom night;todo;101015;1700;101015;2359\n",
				storage.display());

		// Test different start date.
		storage.addEvent(new Event("preparation event", false, new Date(
				"091015"), new Date("101015"), "0800", "2359"));

		assertEquals("event;preparation event;todo;091015;0800;101015;2359\n"
				+ "event;class chalet;todo;101015;0800;101015;2359\n"
				+ "event;prom night;todo;101015;1700;101015;2359\n",
				storage.display());

		// Test different end time.
		storage.addEvent(new Event("just weird", false, new Date("091015"),
				new Date("101015"), "0800", "2358"));

		assertEquals("event;just weird;todo;091015;0800;101015;2358\n"
				+ "event;preparation event;todo;091015;0800;101015;2359\n"
				+ "event;class chalet;todo;101015;0800;101015;2359\n"
				+ "event;prom night;todo;101015;1700;101015;2359\n",
				storage.display());

		// Test different end date.
		storage.addEvent(new Event("stoning", false, new Date("091015"),
				new Date("121015"), "0800", "2359"));

		assertEquals("event;just weird;todo;091015;0800;101015;2358\n"
				+ "event;preparation event;todo;091015;0800;101015;2359\n"
				+ "event;stoning;todo;091015;0800;121015;2359\n"
				+ "event;class chalet;todo;101015;0800;101015;2359\n"
				+ "event;prom night;todo;101015;1700;101015;2359\n",
				storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	public void testDeleteLine() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("float task", false));
		storage.addTask(new Task("i am a task", false, new Date("121212")));
		storage.addEvent(new Event("event time", false, new Date("101015"),
				new Date("101015"), "1700", "2359"));

		// This is a boundary case for deleting first line.
		assertEquals("float;float task;todo", storage.deleteLine(1));
		assertEquals(
				"task;i am a task;todo;121212\nevent;event time;todo;101015;1700;101015;2359\n",
				storage.display());

		// This is a boundary case for last line.
		assertEquals("event;event time;todo;101015;1700;101015;2359",
				storage.deleteLine(2));
		assertEquals("task;i am a task;todo;121212\n", storage.display());

		// This is a boundary case for delete only item left.
		assertEquals("task;i am a task;todo;121212", storage.deleteLine(1));

		// This is a boundary case for display nothing.
		assertEquals("", storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test(expected = FileSystemException.class)
	// Tests if deleting line 0 will throw exception
	public void testDeleteZero() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for delete line 0 (invalid)
		storage.deleteLine(0);
	}

	@Test(expected = FileSystemException.class)
	// Tests if deleting negative line numbers will throw exception
	public void testDeleteNegative() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy2", false));

		// This is a boundary case for deleting negative numbers
		storage.deleteLine(-1);
	}

	@Test(expected = FileSystemException.class)
	// Tests if deleting line numbers beyond number of items will throw
	// exception
	public void testDeleteTooLarge() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for deleting line numbers beyond number of
		// items.
		storage.deleteLine(2);
	}

	@Test
	public void testFindTypeInLine() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Setup for testing
		storage.addTask(new Task("arrange meeting", false, new Date("020116")));
		storage.addEvent(new Event("Company D&D", false, new Date("211215"),
				new Date("211215"), "1800", "2300"));
		storage.addFloatingTask(new FloatingTask("buy a painting", false));

		// This is a boundary case for first line.
		assertEquals("float", storage.findTypeInLine(1));

		// This is a boundary case for last line.
		assertEquals("event", storage.findTypeInLine(3));

		// This is a general case.
		assertEquals("task", storage.findTypeInLine(2));

		// Checks file remains unchanged.
		assertEquals(
				"float;buy a painting;todo\n"
						+ "task;arrange meeting;todo;020116\nevent;"
						+ "Company D&D;todo;211215;1800;211215;2300\n",
				storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test(expected = FileSystemException.class)
	// Tests if finding line numbers beyond number of items will throw exception
	public void testFindTypeInLineTooLarge() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for finding line numbers beyond number of
		// items
		storage.findTypeInLine(2);
	}

	@Test(expected = FileSystemException.class)
	// Tests if finding line number 0 will throw exception
	public void testFindTypeInLineZero() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for finding line 0
		storage.findTypeInLine(0);
	}

	@Test(expected = FileSystemException.class)
	// Tests if finding negative line numbers will throw exception
	public void testFindTypeInLineNegative() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for finding negative numbers
		storage.findTypeInLine(-1);
	}

	@Test
	public void testMarkAsDone() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Setup for testing
		storage.addTask(new Task("arrange meeting", false, new Date("020116")));
		storage.addEvent(new Event("Company D&D", false, new Date("211215"),
				new Date("211215"), "1800", "2300"));
		storage.addFloatingTask(new FloatingTask("buy a painting", false));

		// Mark each type of item as done.
		storage.markAsDone(1);
		assertEquals(
				"float;buy a painting;done\ntask;arrange meeting;todo;020116\n"
						+ "event;Company D&D;todo;211215;1800;211215;2300\n",
				storage.display());
		storage.markAsDone(3);
		assertEquals(
				"float;buy a painting;done\ntask;arrange meeting;todo;020116\n"
						+ "event;Company D&D;done;211215;1800;211215;2300\n",
				storage.display());
		storage.markAsDone(2);
		assertEquals(
				"float;buy a painting;done\ntask;arrange meeting;done;020116\n"
						+ "event;Company D&D;done;211215;1800;211215;2300\n",
				storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Tests if the correct exceptions with corresponding messages are thrown,
	// when marking already completed items as done.
	public void testMarkAsDoneExceptions() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Setup for testing
		storage.addTask(new Task("arrange meeting", true, new Date("020116")));
		storage.addEvent(new Event("Company D&D", true, new Date("211215"),
				new Date("211215"), "1800", "2300"));
		storage.addFloatingTask(new FloatingTask("buy a painting", true));

		// Mark each type of item as done.
		try {
			storage.markAsDone(1);
		} catch (FileSystemException exception) {
			assertEquals(
					"Error encountered: the float \"buy a painting\" has already been completed.",
					exception.getMessage());
		}
		try {
			storage.markAsDone(2);
		} catch (FileSystemException exception) {
			assertEquals(
					"Error encountered: the task \"arrange meeting\" has already been completed.",
					exception.getMessage());
		}
		try {
			storage.markAsDone(3);
		} catch (FileSystemException exception) {
			assertEquals(
					"Error encountered: the event \"Company D&D\" has already been completed.",
					exception.getMessage());
		}

		// Clear File for next test.
		storage.overwriteFile("");
	}
	
	@Test(expected = FileSystemException.class)
	// Tests if mark done line numbers beyond number of items will throw exception
	public void testMarkAsDoneTooLarge() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for marking done line numbers beyond number of
		// items
		storage.markAsDone(2);
	}

	@Test(expected = FileSystemException.class)
	// Tests if marking done line number 0 will throw exception
	public void testMarkAsDoneZero() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for marking done line 0
		storage.markAsDone(0);
	}

	@Test(expected = FileSystemException.class)
	// Tests if marking done negative line numbers will throw exception
	public void testMarkAsDoneNegative() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addFloatingTask(new FloatingTask("dummy", false));

		// This is a boundary case for marking done negative numbers
		storage.markAsDone(-1);
	}

	@Test
	public void testGetAttribute() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Setup for testing.
		storage.addTask(new Task("i am a task", false, new Date("121212")));
		storage.addEvent(new Event("event time", false, new Date("101015"),
				new Date("111015"), "1700", "2359"));
		storage.addFloatingTask(new FloatingTask("float task", false));

		// General Case for floating task
		assertEquals("float", storage.getAttribute(1, 0));
		assertEquals("float task", storage.getAttribute(1, 1));
		assertEquals("todo", storage.getAttribute(1, 2));

		// These are boundary cases where type = 3 and -1 for float task.
		assertEquals(null, storage.getAttribute(1, 3));
		assertEquals(null, storage.getAttribute(1, -1));

		// General Case for task
		assertEquals("task", storage.getAttribute(2, 0));
		assertEquals("i am a task", storage.getAttribute(2, 1));
		assertEquals("todo", storage.getAttribute(2, 2));
		assertEquals("121212", storage.getAttribute(2, 3));

		// These are boundary cases where type = 4 and -1 for task.
		assertEquals(null, storage.getAttribute(2, 4));
		assertEquals(null, storage.getAttribute(2, -1));

		// General Case for event
		assertEquals("event", storage.getAttribute(3, 0));
		assertEquals("event time", storage.getAttribute(3, 1));
		assertEquals("todo", storage.getAttribute(3, 2));
		assertEquals("101015", storage.getAttribute(3, 3));
		assertEquals("1700", storage.getAttribute(3, 4));
		assertEquals("111015", storage.getAttribute(3, 5));
		assertEquals("2359", storage.getAttribute(3, 6));

		// These are boundary cases where type = 7 and -1 for event.
		assertEquals(null, storage.getAttribute(3, 7));
		assertEquals(null, storage.getAttribute(3, -1));

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Test the methods for Alias File
	public void testAlias() throws FileSystemException {
		Storage storage = new Storage();
		storage.clearAliasFile();

		// Test if add and delete works.
		storage.addToAliasFile("insert", "add");
		storage.addToAliasFile("remove", "delete");
		storage.addToAliasFile("plus", "add");
		storage.deleteFromAliasFile("insert");
		assertEquals("remove;delete\nplus;add\n", storage.readAliasFile());

		// Test if deleting non-existent alias affects file.
		storage.deleteFromAliasFile("flying");
		assertEquals("remove;delete\nplus;add\n", storage.readAliasFile());

		// Test if boundary case of empty file is displaying correctly.
		storage.deleteFromAliasFile("plus");
		storage.deleteFromAliasFile("remove");
		assertEquals("", storage.readAliasFile());

		// Test add and delete 1 item.
		storage.addToAliasFile("wakaka", "done");
		assertEquals("wakaka;done\n", storage.readAliasFile());
		storage.deleteFromAliasFile("wakaka");
		assertEquals("", storage.readAliasFile());
	}

	@Test
	public void testClearAliasFile() throws FileSystemException {
		Storage storage = new Storage();
		storage.clearAliasFile();

		storage.addToAliasFile("plus", "add");
		storage.addToAliasFile("rm", "delete");
		storage.addToAliasFile("jia", "add");
		storage.deleteFromAliasFile("plus");
		assertEquals("rm;delete\njia;add\n", storage.readAliasFile());

		// General Case
		storage.clearAliasFile();
		assertEquals("", storage.readAliasFile());

		// Clearing empty file.
		storage.clearAliasFile();
		assertEquals("", storage.readAliasFile());
	}

	@Test
	public void testOverwriteAliasFile() throws FileSystemException {
		Storage storage = new Storage();
		storage.clearAliasFile();

		storage.addToAliasFile("plus", "add");

		// This is a boundary case for overwriting with empty string.
		storage.overwriteAliasFile("");
		assertEquals("", storage.readAliasFile());

		// General Case
		storage.addToAliasFile("find", "search");

		storage.overwriteAliasFile("assign;set\nwhy;help\n");
		assertEquals("assign;set\nwhy;help\n", storage.readAliasFile());

		storage.overwriteAliasFile("");
		assertEquals("", storage.readAliasFile());
	}

	@Test
	// Tests that changing file path to folder without text file.
	public void testChangeFilePath() throws FileSystemException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addTask(new Task("sample task", false, new Date("121212")));
		storage.changeFileStorageLocation("src" + File.separator + "test"
				+ File.separator);

		assertEquals("task;sample task;todo;121212\n", storage.display());

		storage.changeFileStorageLocation("");
		assertEquals("task;sample task;todo;121212\n", storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Tests that changing file path to folder with empty text file.
	public void testChangeFilePathToEmpty() throws IOException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addTask(new Task("sample task", false, new Date("121212")));

		// Simulate empty text file
		File file = new File("src" + File.separator + "test" + File.separator
				+ "whattodo.txt");
		assertEquals(true, file.createNewFile());

		storage.changeFileStorageLocation("src" + File.separator + "test");
		assertEquals("task;sample task;todo;121212\n", storage.display());

		// Revert back
		storage.changeFileStorageLocation("");
		assertEquals("task;sample task;todo;121212\n", storage.display());

		// Clear File for next test.
		storage.overwriteFile("");
	}

	@Test
	// Tests that changing file path to folder with conflicting text file.
	public void testChangeFilePathConflicting() throws IOException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		storage.addTask(new Task("sample task", false, new Date("121212")));

		// Simulate conflict file.
		File file = new File("src" + File.separator + "test" + File.separator
				+ "whattodo.txt");
		assertEquals(true, file.createNewFile());
		PrintWriter writer = new PrintWriter("src" + File.separator + "test"
				+ File.separator + "whattodo.txt");
		writer.print("float;koala bear;todo");
		writer.close();

		assertEquals(
				"Conflicting text files found in"
						+ " both old and new file paths. Please delete either one.",
				storage.changeFileStorageLocation("src" + File.separator
						+ "test"));

		assertEquals("task;sample task;todo;121212\n", storage.display());

		// Clear for next tests.
		storage.overwriteFile("");
		file.delete();
	}
	
	@Test
	// Tests that changing file path to folder with written text file.
	public void testChangeFilePathMove() throws IOException {
		Storage storage = new Storage();
		storage.overwriteFile("");

		// Simulate written text file.
		File file = new File("src" + File.separator + "test" + File.separator
				+ "whattodo.txt");
		assertEquals(true, file.createNewFile());
		PrintWriter writer = new PrintWriter("src" + File.separator + "test"
				+ File.separator + "whattodo.txt");
		writer.print("float;koala bear;todo");
		writer.close();

		storage.changeFileStorageLocation("src" + File.separator + "test");

		assertEquals("float;koala bear;todo\n", storage.display());
		
		storage.changeFileStorageLocation("");

		// Clear for next tests.
		storage.overwriteFile("");
		file.delete();
	}
}
```
