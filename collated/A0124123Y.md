# A0124123Y
###### gui\AllViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Line;
import struct.View;

public class AllViewController {

	// ================================================================================
    // JavaFX controls used in the all interface
    // ================================================================================
	
	// Used for initAllTaskView
    private static VBox allTaskBox, allTaskContentBox;
    private static HBox allTaskHeaderBox;
    private static ScrollPane allTaskScroll;

    // Used for initAllEventView
    private static VBox allEventBox, allEventContentBox;
    private static HBox allEventHeaderBox;
    private static ScrollPane allEventScroll;

    // Used for initAllView
    private static Line allScrollLine;
    
    private static final String HEADER_ALL_TASKS = "UPCOMING TASKS: ALL";
    private static final String HEADER_ALL_EVENTS = "UPCOMING EVENTS: ALL";

    /**
     * This method initializes all the interface components for the all view,
     * primarily the task window and the event window
     */
    protected static void initAllView() {
        initAllTaskView(InterfaceController.getLogic().getAllTasks());
        initAllEventView(InterfaceController.getLogic().getAllEvents());
        
        allScrollLine = new Line(0, 0, 0, InterfaceController.WIDTH_DEFAULT_BUTTON);
        InterfaceController.allBox = new HBox(allTaskBox, allScrollLine, allEventBox);
        
        // Component formatting
        allTaskScroll.prefViewportWidthProperty().bind(
        		InterfaceController.allBox.widthProperty().divide(2));
        allEventScroll.prefViewportWidthProperty().bind(
        		InterfaceController.allBox.widthProperty().divide(2));
        
        allTaskScroll.maxWidthProperty().bind(
        		InterfaceController.allBox.widthProperty().divide(2));
        allEventScroll.maxWidthProperty().bind(
        		InterfaceController.allBox.widthProperty().divide(2));
        
        allScrollLine.endYProperty().bind(DefaultViewController.getDefScrollLine().endYProperty());
        
        // CSS
        allScrollLine.getStyleClass().add("line");
    }
    
    /**
     * This method updates the all view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 	2. 	updateMainInterface() in InterfaceController to update the view when
     * 		a view change command is issued (button/hotkey/text command)
     */
    protected static void updateAllView() {
    	// Clear the previous content already displayed
        allTaskContentBox.getChildren().clear();
        allEventContentBox.getChildren().clear();
        ViewIndexMap.resetAllMap();
        
        // Get the results of the file from logic
        String[] tasks = InterfaceController.getLogic().getAllTasks();
        String[] events = InterfaceController.getLogic().getAllEvents();
    	int numOfElements = InterfaceController.getLogic().getAllElementsCount();
    	int numOfResults = 1;
    	
    	numOfResults = InterfaceController.updateTasks(
    			tasks, numOfElements, numOfResults, View.ALL, allTaskContentBox);
    	numOfResults = InterfaceController.updateEvents(
    			events, numOfElements, numOfResults, View.ALL, allEventContentBox);
    }
    
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
    
    /**
     * This method initializes the task view for the all view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getAllTasks()
     */
    private static void initAllTaskView(String[] tasks) {
    	Label allTaskHeader = new Label(HEADER_ALL_TASKS);
        allTaskHeaderBox = new HBox(allTaskHeader);
        allTaskContentBox = new VBox();
        
    	int numOfElements = InterfaceController.getLogic().getAllElementsCount();
        initAllTasks(tasks, numOfElements);
        
        allTaskScroll = new ScrollPane(allTaskContentBox);
        allTaskBox = new VBox(allTaskHeaderBox, allTaskScroll);
        
        // Component formatting
        allTaskHeaderBox.setAlignment(Pos.CENTER);
        allTaskScroll.setFitToWidth(true);
        VBox.setVgrow(allTaskScroll, Priority.ALWAYS);
        allTaskBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(allTaskHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(allTaskHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(allTaskScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        allTaskScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        allTaskHeader.getStyleClass().add("box-title-label");
        allTaskHeaderBox.getStyleClass().add("box-title-all-task");
    }

    /**
     * This method initializes the event view for the all view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getAllEvents()
     */
    private static void initAllEventView(String[] events) {
    	Label allEventHeader = new Label(HEADER_ALL_EVENTS);
        allEventHeaderBox = new HBox(allEventHeader);
        allEventContentBox = new VBox();
        
    	int numOfElements = InterfaceController.getLogic().getAllElementsCount();
        initAllEvents(events, numOfElements);
        
        allEventScroll = new ScrollPane(allEventContentBox);
        allEventBox = new VBox(allEventHeaderBox, allEventScroll);
        
        // Component formatting
        allEventHeaderBox.setAlignment(Pos.CENTER);
        allEventScroll.setFitToWidth(true);
        VBox.setVgrow(allEventScroll, Priority.ALWAYS);
        allEventBox.setAlignment(Pos.CENTER);

        HBox.setMargin(allEventHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(allEventHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(allEventScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        allEventScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        allEventHeader.getStyleClass().add("box-title-label");
        allEventHeaderBox.getStyleClass().add("box-title-all-event");
    }

	/**
	 * This method initializes the task content of the all view with data
	 * 
	 * @param tasks
	 * 			  The array of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initAllTasks(String[] tasks, int numOfElements) {
		for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, 1, true, View.ALL);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            allTaskContentBox.getChildren().add(tempBox);
        }
	}
	
	/**
	 * This method initializes the event content of the all view with data
	 * 
	 * @param events
	 * 			  The array of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initAllEvents(String[] events, int numOfElements) {
		for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, 1, false, View.ALL);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            allEventContentBox.getChildren().add(tempBox);
        }
	}
}
```
###### gui\AutoComplete.java
``` java
 */

package gui;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.ListView;
import javafx.scene.layout.Pane;
import javafx.stage.Popup;
import struct.Alias;

public class AutoComplete {

	// ================================================================================
    // JavaFX controls used for the popup
    // ================================================================================
	
	// Used for initPopupList
	private static ListView<Alias> popupList;
	
	// Used for initPopup
	private static Popup popup;
	
	// Variables to store the command strings
	private static ArrayList<Alias> shortcutCommands;
	private static ArrayList<Alias> operationCommands;
	private static ArrayList<Alias> aliasCommands;
	
	private static boolean isActivated = false;
	private static boolean isShowing = false;
	private static int numOfResults = -1;
	
	private static final String KEYWORD_ALIAS = "alias";
	
	private static final double WIDTH_POPUP = 200;
	private static final double HEIGHT_POPUP = 150;
	
	// ================================================================================
    // Protected methods used to initialize the popup and perform operations on the
	// popup
    // ================================================================================
	
	protected static void initPopup() {
		
		initAllCommands();
		initPopupList();

		// Only show the popup list if there are results
		popup = new Popup();
	}
	
	/**
	 * This method updates the popup in real time based on what the user is currently
	 * typing in the text field
	 * 
	 * @param searchTerm
	 * 			  The String that the user is currently typing
	 */
	protected static void updatePopup(String searchTerm) {
		// Update aliasCommands
		updateAliases();
		
		if (searchTerm.toLowerCase().equals(KEYWORD_ALIAS)) {
			showAllAliases();
		} else {
			showMatchingAliases(searchTerm);
		}
		
		// Only show the popup list if there are results
		if (numOfResults > 0) {
			String textFieldInput = InterfaceController.getTextField().getText();
			String firstResult = popupList.getItems().get(0).getAlias();
			// Do not show if there is only one exact match
			if (numOfResults == 1 && textFieldInput.equals(firstResult)) {
				isShowing = false;
				popup.hide();
			} else {
				// Wrap popupList in a Pane to prevent sizing problems
				Pane popupPane = new Pane(popupList);
				popupPane.getStyleClass().add("pane");

				popup.getScene().setRoot(popupPane);
				isShowing = true;
				popup.show(MainApp.stage);

				// Calculate window locations to set autocomplete anchor
				setX(MainApp.stage.getX());
				setY(MainApp.stage.getY());

				switchFocus();
			}
		} else {
			isShowing = false;
			popup.hide();
		}
	}
	
	/**
	 * Selects the autocomplete suggestion that the user is currently hovered on
	 * 
	 * @return A String that is returned from the ListView after the user has pressed
	 * the ENTER key while it is selected
	 */
	protected static String getSelectedItem() {
		// Run a check to see if the returned item is a shortcut command
		// Any command but a shortcut command should have a space appended
		// to the end for convenience
		Alias selected = popupList.getSelectionModel().getSelectedItem();
		if (!isShortcutCommand(selected)) {
			return selected.getAlias() + " "; 
		} else {
			return selected.getAlias();
		}
	}
	
	/**
	 * Switches focus of the application from the main stage to the popup
	 */
	protected static void switchFocus() {
		popupList.requestFocus();
		popupList.getSelectionModel().select(0);
		popupList.scrollTo(0);
	}
	
	/**
	 * Sets the horizontal position of the popup on the screen
	 * @param coord
	 * 			  The x-coordinate of the popup on the screen
	 */
	protected static void setX(double coord) {
		popup.setX(coord +
				InterfaceController.WIDTH_SIDEBAR + 
				InterfaceController.MARGIN_TEXT_FIELD +
				7);
	}
	
	/**
	 * Sets the vertical position of the popup on the screen
	 * @param coord
	 * 			  The y-coordinate of the popup on the screen
	 */
	protected static void setY(double coord) {
		popup.setY(coord + 
				MainApp.stage.getHeight() - 
				InterfaceController.HEIGHT_FEEDBACK - 
				InterfaceController.HEIGHT_TEXT_FIELD - 
				InterfaceController.HEIGHT_HORIZ_LINE - 
				HEIGHT_POPUP + 15);
	}
	
	// ================================================================================
    // Protected methods for showing or closing the popup
    // ================================================================================
	
	protected static void showPopup() {
		isShowing = true;
		popup.show(MainApp.stage);
	}
	
	protected static void closePopup() {
		isShowing = false;
		popup.hide();
	}
	
	// ================================================================================
    // Getters and setter for isShowing and isActivated
    // ================================================================================
	
	protected static boolean isShowing() {
		return isShowing;
	}
	
	protected static boolean isActivated() {
		return isActivated;
	}
	
	protected static void setActivation(boolean status) {
		if (status) {
			isActivated = true;
		} else {
			isActivated = false;
		}
	}
	
	// ================================================================================
    // Private methods for initializing the command arrays that AutoComplete references
    // ================================================================================
	
	private static void initPopupList() {
		
		popupList = new ListView<Alias>();
		
		popupList.setMinSize(WIDTH_POPUP, HEIGHT_POPUP);
		popupList.setMaxSize(WIDTH_POPUP, HEIGHT_POPUP);
		
		popupList.setOnKeyPressed(Handlers.getAutoCompleteSelectHandler());
	}
	
	private static void initAllCommands() {
		initShortcutCommands();
		initOperationCommands();
		initAliasCommands();
	}
	
	private static void initShortcutCommands() {
		shortcutCommands = new ArrayList<Alias>();
		shortcutCommands.add(new Alias("def", "def"));
		shortcutCommands.add(new Alias("all", "all"));
		shortcutCommands.add(new Alias("hist", "hist"));
		shortcutCommands.add(new Alias("unres", "unres"));
		shortcutCommands.add(new Alias("help", "help"));
		shortcutCommands.add(new Alias("openfile", "openfile"));
		shortcutCommands.add(new Alias("config", "config"));
	}
	
	private static void initOperationCommands() {
		operationCommands = new ArrayList<Alias>();
		operationCommands.add(new Alias("add", "add"));
		operationCommands.add(new Alias("delete", "delete"));
		operationCommands.add(new Alias("edit", "edit"));
		operationCommands.add(new Alias("done", "done"));
		operationCommands.add(new Alias("search", "search"));
		operationCommands.add(new Alias("redo", "redo"));
		operationCommands.add(new Alias("undo", "undo"));
		operationCommands.add(new Alias("set", "set"));
		operationCommands.add(new Alias("save", "save"));
		operationCommands.add(new Alias("exit", "exit"));
	}
	
	private static void initAliasCommands() {
		aliasCommands = new ArrayList<Alias>();
	}
	
	// ================================================================================
    // Misc private methods used for calculations and operations required to display
	// the popup
    // ================================================================================
	
	/**
	 * This method calls logicControl's getAliases() method to update the 
	 * current list of aliases
	 */
	private static void updateAliases() {
		aliasCommands = InterfaceController.getLogic().getAliases();
	}
	
	/**
	 * This method returns all commands that match (contain a substring) of 
	 * the searchTerm
	 * 
	 * @param searchTerm
	 * 			  The String which the user has currently typed in the text field
	 * @return An ArrayList of Strings that contain matching substrings of searchTerm
	 */
	private static ArrayList<Alias> getMatchingCommands(String searchTerm) {
		ArrayList<Alias> matchedCommands = new ArrayList<Alias>();
		
		// Check for matches in shortcutCommands
		for (int i = 0; i < shortcutCommands.size(); i++) {
			// Check 1: length of command in array not shorter than searchTerm
			if (shortcutCommands.get(i).getAlias().length() >= searchTerm.length()) {
				// Check 2: if lengths are the same
				if (shortcutCommands.get(i).getAlias().length() == searchTerm.length()) {
					// Check 3: if both are the same string
					if (shortcutCommands.get(i).getAlias().equals(searchTerm)) {
						matchedCommands.add(shortcutCommands.get(i));
					}
				} else {
					// If shortcutCommand.length > searchTerm.length
					// Check 4: if searchTerm is a substring of shortcutCommand
					if (isSubstring(searchTerm, shortcutCommands.get(i).getAlias())) {
						matchedCommands.add(shortcutCommands.get(i));
					}
				}
			}
		}
		// Check for matches in operationCommands
		for (int i = 0; i < operationCommands.size(); i++) {
			// Check 1: length of command in array not shorter than searchTerm
			if (operationCommands.get(i).getAlias().length() >= searchTerm.length()) {
				// Check 2: if lengths are the same
				if (operationCommands.get(i).getAlias().length() == searchTerm.length()) {
					// Check 3: if both are the same string
					if (operationCommands.get(i).getAlias().equals(searchTerm)) {
						matchedCommands.add(operationCommands.get(i));
					}
				} else {
					// If shortcutCommand.length > searchTerm.length
					// Check 4: if searchTerm is a substring of shortcutCommand
					if (isSubstring(searchTerm, operationCommands.get(i).getAlias())) {
						matchedCommands.add(operationCommands.get(i));
					}
				}
			}
		}
		// Check for matches in aliasCommands
		for (int i = 0; i < aliasCommands.size(); i++) {
			// Check 1: length of command in array not shorter than searchTerm
			if (aliasCommands.get(i).getAlias().length() >= searchTerm.length()) {
				// Check 2: if lengths are the same
				if (aliasCommands.get(i).getAlias().length() == searchTerm.length()) {
					// Check 3: if both are the same string
					if (aliasCommands.get(i).getAlias().equals(searchTerm)) {
						matchedCommands.add(aliasCommands.get(i));
					}
				} else {
					// If shortcutCommand.length > searchTerm.length
					// Check 4: if searchTerm is a substring of shortcutCommand
					if (isSubstring(searchTerm, aliasCommands.get(i).getAlias())) {
						matchedCommands.add(aliasCommands.get(i));
					}
				}
			}
		}
		
		return matchedCommands;
	}
	
	/**
	 * This method shows all the aliases that match the searchTerm the user has entered
	 * 
	 * @param searchTerm
	 * 			  The String that the user has currently entered in the text field
	 */
	private static void showMatchingAliases(String searchTerm) {
		// Perform a matching search and get the results
		ArrayList<Alias> matchedCommands = getMatchingCommands(searchTerm);
		numOfResults = matchedCommands.size();
		List<Alias> matchedToSort = matchedCommands;
		Collections.sort(matchedToSort);

		// Convert from ArrayList to ObservableList
		ObservableList<Alias> matchedList = FXCollections.observableArrayList(matchedToSort);
		popupList.getItems().clear();
		popupList.setItems(matchedList);
	}

	/** 
	 * This method adds all the aliases added by the user to the matching list to display
	 */
	private static void showAllAliases() {
		// Perform a matching search and get the results
		List<Alias> matchedToSort = aliasCommands;
		numOfResults = matchedToSort.size();
		Collections.sort(matchedToSort);

		// Convert from ArrayList to ObservableList
		ObservableList<Alias> matchedList = FXCollections.observableArrayList(matchedToSort);
		popupList.getItems().clear();
		popupList.setItems(matchedList);
	}
	
	/**
	 * This method checks if an alias is added as an replacement for a shortcut command or
	 * an operation command
	 * 
	 * @param alias
	 * 			  The alias to be checked
	 * @return true if the alias is a replacement for a shortcut command, false otherwise
	 */
	private static boolean isShortcutCommand(Alias alias) {
		boolean isShortcut = false;
		for (int i = 0; i < shortcutCommands.size(); i++) {
			if (alias.getOriginal().equals(shortcutCommands.get(i).getOriginal())) {
				isShortcut = true;
				break;
			}
		}
		return isShortcut;
	}
	
	/**
	 * This method checks if one String is a substring of another
	 * 
	 * @param input
	 * 			  The String to try and check
	 * @param target
	 * 			  The String to check input against
	 * @return true if input is a substring of target, false otherwise
	 */
	private static boolean isSubstring(String input, String target) {
		if (input.length() > target.length()) {
			return false;
		} else if (input.length() == target.length()) {
			return input.equals(target);
		} else if (target.substring(0, input.length()).equals(input)) {
			return true;
		} else {
			return isSubstring(input, target.substring(1));
		}
	}
}


```
###### gui\Constructor.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import struct.View;

public class Constructor {

	// ======================================================================
    // Protected methods for initializing element components of all the views
    // Used in initDisplayElement()
    // ======================================================================
    
    /**
     * This method calls the correct initDataElement() method based on whether
     * the task/event data is marked with a status field or not
     * 
     * @param displayData
     * 		      The task/event data to be displayed in the window
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 		      The view index of the particular task/event
     * @param isTask
     * 		      A boolean flag indicating whether the data to be input is a task
     * @param displayDataSplit
     * 		      A String[] of displayData split by a period(.). Used in 
     * 			  initDisplayElement() for branching, reused to avoid recomputation
     * @return A HBox with only the task/event data formatted for insertion into the
     * 		   scroll pane
     */
    protected static HBox initDataElement(String displayData, int numOfElements, 
			int index, boolean isTask, String[] displayDataSplit, View targetView) {
    	
		// After removing the index, store it in the index map
		if (isStatusField(displayDataSplit[0].split(" ")[0])) {
			ViewIndexMap.add(targetView, Integer.parseInt(displayDataSplit[0].substring(5)));
		} else {
			assert !isStatusField(displayDataSplit[0].split(" ")[0]);
			ViewIndexMap.add(targetView, Integer.parseInt(displayDataSplit[0]));
		}
		
    	// Do a comparison on displayDataSplit to check if the returned data
    	// contains the "todo" or "done" field that requires indicator
    	String statusData = displayData.split(" ")[0];
    	if (statusData.equals(InterfaceController.STATUS_DONE)) {
    		return initDataElementWithStatus(
    				displayData, numOfElements, index, isTask, displayDataSplit, targetView);
    	} else {
    		assert !statusData.equals(InterfaceController.STATUS_DONE);
    		return initDataElementNoStatus(
    				displayData, numOfElements, index, isTask, displayDataSplit, targetView);
    	}
    }
	
	/**
	 * This method creates a HBox and formats it for an empty result String
	 * ("There are no results to display.")
	 * 
	 * @param displayData
	 * 		      The task/event data to be displayed in the window
	 * @return A HBox with the empty result String formatted for insertion into the
	 * 		   scroll pane
	 */
    protected static HBox initNoResultElement(String displayData) {
		Label elementLabel = new Label(displayData);
		HBox labelBox = new HBox(elementLabel);
		HBox elementBox = new HBox(labelBox);
		
		formatLabelElement(elementLabel, labelBox);

		// Apply CSS style for regular data field
		elementBox.getStyleClass().add("element");
		return elementBox;
	}

	/**
	 * This method creates a HBox and formats it for a date or title String
	 * ("FLOAT", "SAT, 10 OCT 2015" etc...)
	 * 
	 * @param displayData
	 * 		      The task/event data to be displayed in the window
	 * @return A HBox with the date or title String formatted for insertion into the
	 * 		   scroll pane
	 */
    protected static HBox initTitleOrDateElement(String displayData) {
		Label elementLabel = new Label(displayData.toUpperCase());
		HBox elementBox = new HBox(elementLabel);
		Line elementLine = new Line(0, 0, InterfaceController.WIDTH_DEFAULT, 0);
		elementBox.getChildren().add(elementLine);
		
		formatTitleOrDateElement(elementLabel, elementBox, elementLine);
		
		// CSS
		elementLine.getStyleClass().add("line");
		elementBox.getStyleClass().add("element-title");
		return elementBox;
	}

    /**
     * This method creates a HBox and formats it for a task/event data String
     * 
     * @param displayData
     * 		      The task/event data to be displayed in the window
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 		      The view index of the particular task/event
     * @param isTask
     * 		      A boolean flag indicating whether the data to be input is a task
     * @param displayDataSplit
     * 		      A String[] of displayData split by a period(.). Used in 
     * 			  initDisplayElement() for branching, reused to avoid recomputation
     * @return A HBox with only the task/event data formatted for insertion into the
     * 		   scroll pane
     */
    protected static HBox initDataElementNoStatus(String displayData, int numOfElements, 
			int index, boolean isTask, String[] displayDataSplit, View targetView) {
		
		Label elementIndex = new Label(String.valueOf(index));
		Label elementLabel = new Label(displayData.replaceFirst(displayDataSplit[0] + ".", "").trim());
		HBox indexBox = new HBox(elementIndex);
		HBox labelBox = new HBox(elementLabel);
		HBox elementBox = new HBox(indexBox, labelBox);

		// Component formatting
		formatIndexElement(numOfElements, elementIndex, indexBox);
		formatLabelElement(elementLabel, labelBox);
		
		// CSS
		elementBox.getStyleClass().add("element");
		elementIndex.getStyleClass().add("element-index-label");
		
		if (targetView == View.DEFAULT) {
			indexBox.getStyleClass().add("element-index");
		} else if (isTask) {
			indexBox.getStyleClass().add("element-index-task");
		} else {
			indexBox.getStyleClass().add("element-index-event");
		}
		return elementBox;
	}
	
    /**
     * This method creates a HBox and formats it for a task/event data String. This method
     * will also append a tick to the end of the label to indicate completed status
     * 
     * @param displayData
     * 		      The task/event data to be displayed in the window
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 		      The view index of the particular task/event
     * @param isTask
     * 		      A boolean flag indicating whether the data to be input is a task
     * @param displayDataSplit
     * 		      A String[] of displayData split by a period(.). Used in 
     * 			  initDisplayElement() for branching, reused to avoid recomputation
     * @return A HBox with only the task/event data formatted for insertion into the
     * 		   scroll pane
     */
    protected static HBox initDataElementWithStatus(String displayData, int numOfElements, 
			int index, boolean isTask, String[] displayDataSplit, View targetView) {
		
		Label elementIndex = new Label(String.valueOf(index));
		Label elementLabel = new Label(displayData.replaceFirst(displayDataSplit[0] + ".", "").trim());
		ImageView elementTick = new ImageView(InterfaceController.PATH_TICK);
		HBox indexBox = new HBox(elementIndex);
		HBox labelBox = new HBox(elementLabel);
		HBox tickBox = new HBox(elementTick);
		HBox elementBox = new HBox(indexBox, labelBox, tickBox);

		// Component formatting
		formatIndexElement(numOfElements, elementIndex, indexBox);
		formatLabelElement(elementLabel, labelBox);
		formatTickElement(elementTick, tickBox);
		
		// CSS
		elementBox.getStyleClass().add("element");
		elementIndex.getStyleClass().add("element-index-label");
		
		if (targetView == View.DEFAULT) {
			indexBox.getStyleClass().add("element-index");
		} else if (isTask) {
			indexBox.getStyleClass().add("element-index-task");
		} else {
			indexBox.getStyleClass().add("element-index-event");
		}
		return elementBox;
	}
	
	/**
	 * This method formats the individual components of a HBox containing the
	 * index of the task/event
	 * 
	 * @param numOfElements
	 * 		      The total number of tasks/events. Used for formatting the index box
	 * @param elementIndex
	 * 		      The view index of the particular task/event
	 * @param indexBox
	 * 		      The HBox containing the index to be formatted
	 */
    protected static void formatIndexElement(int numOfElements, Label elementIndex, HBox indexBox) {
		setFitToMaxWidth(indexBox, numOfElements);
		indexBox.setAlignment(Pos.CENTER);
		HBox.setMargin(elementIndex, new Insets(
				InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
				InterfaceController.MARGIN_TEXT_ELEMENT, 
				InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
				InterfaceController.MARGIN_TEXT_ELEMENT));
	}
	
	/**
	 * This method formats the individual components of a HBox containing the
	 * task/event data
	 * 
	 * @param elementLabel
	 * 		      The Label containing the task/event data to be formatted
	 * @param labelBox
	 * 		      The HBox containing the elementLabel
	 */
    protected static void formatLabelElement(Label elementLabel, HBox labelBox) {
		elementLabel.setWrapText(true);
		HBox.setHgrow(labelBox, Priority.ALWAYS);
		HBox.setMargin(elementLabel, new Insets(
				InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
				InterfaceController.MARGIN_TEXT_ELEMENT, 
				InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
				InterfaceController.MARGIN_TEXT_ELEMENT));
	}

	/**
	 * This method formats the individual components of a HBox containing the 
	 * title or date element of the task/event
	 * 
	 * @param elementLabel
	 * 		      The Label containing the task/event data to be formatted
	 * @param elementBox
	 * 		      The HBox containing the elementLabel
	 * @param elementLine
	 * 		      The Line which is appended to the elementLabel in the 
	 * 		      elementBox as a vertical separator
	 */
    protected static void formatTitleOrDateElement(Label elementLabel, HBox elementBox, Line elementLine) {
		setFitLineToWidth(elementLabel, elementBox, elementLine);
		elementBox.setAlignment(Pos.CENTER_LEFT);
		HBox.setMargin(elementLabel, new Insets(
				0, InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
				0, InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT));
	}

	/**
	 * This method formats the individual components of a HBox containing the
	 * tick indicating completed status of a task/event
	 * 
	 * @param elementTick
	 * 		      The ImageView containing the tick image to be formatted
	 * @param tickBox
	 * 			  The HBox containing the elementTick
	 */
    protected static void formatTickElement(ImageView elementTick, HBox tickBox) {
		tickBox.setAlignment(Pos.CENTER);
		HBox.setMargin(elementTick, new Insets(0, InterfaceController.MARGIN_TICK, 
				0, InterfaceController.MARGIN_TICK));
	}
	
	/**
	 * This method calculates the maximum width used by the current largest index
	 * and sets the indexBox to that width to ensure consistency
	 * 
	 * @param indexBox
	 * 		      The HBox containing the index to be formatted
	 * @param numOfElements
	 * 		      The total number of tasks/events. Used for formatting the index box
	 */
    protected static void setFitToMaxWidth(HBox indexBox, int numOfElements) {
		Text text = new Text(String.valueOf(numOfElements));
		Scene s = new Scene(new Group(text));
		// Override the CSS style to calculate the text width
		text.setStyle("-fx-font-family: \"Myriad Pro\"; "
				+ "-fx-font-size: 16; ");
		text.applyCss();
		double textWidth = Math.ceil(text.getLayoutBounds().getWidth());
		indexBox.setMinWidth(textWidth + 2 * InterfaceController.MARGIN_TEXT_ELEMENT);
	}
	
	/**
	 * This method calculates the correct length of the separator line elementLine
	 * to fit the line length to width of the scroll pane
	 * 
	 * @param elementLabel
	 * 		      The Label containing the task/event data to be formatted
	 * @param elementBox
	 * 		      The HBox containing the elementLabel
	 * @param elementLine
	 * 		      The Line which is appended to the elementLabel in the 
	 * 		      elementBox as a vertical separator
	 */
    protected static void setFitLineToWidth(Label elementLabel, HBox elementBox, Line elementLine) {
		Text text = new Text(elementLabel.getText());
		Scene s = new Scene(new Group(text));
		text.setStyle("-fx-font-family: \"Myriad Pro\"; "
				+ "-fx-font-size: 16; "
				+ "-fx-font-weight: bold;");
		text.applyCss();
		// The arbitrary margin exists because text in a container is not perfectly 
		// aligned to the dimensions of its container
		double textWidth = Math.ceil(text.getLayoutBounds().getWidth());
		elementLine.endXProperty().bind(elementBox.widthProperty().subtract(
				textWidth + InterfaceController.MARGIN_ARBITRARY));
	}
	
	/**
	 * This method returns whether an input string contains a status field in the
	 * data ("todo" or "done")
	 * 
	 * @param data
	 * 		      The String to check if it matches either status field
	 * @return true if data equals to either "done" or "todo", false otherwise
	 */
    protected static boolean isStatusField(String data) {
		return data.equals(InterfaceController.STATUS_DONE) || 
				data.equals(InterfaceController.STATUS_TODO);
	}
}
```
###### gui\DefaultViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.*;
import javafx.scene.shape.Line;
import struct.View;

public class DefaultViewController {

	// ================================================================================
    // JavaFX controls used in the default interface
    // ================================================================================
	
	// Used for initDefTaskView
    private static VBox defTaskBox, defTaskContentBox;
    private static HBox defTaskHeaderBox;
    private static ScrollPane defTaskScroll;

    // Used for initDefEventView
    private static VBox defEventBox, defEventContentBox;
    private static HBox defEventHeaderBox;
    private static ScrollPane defEventScroll;

    // Used for initDefView
    private static Line defScrollLine;
    
    private static final String HEADER_DEF_TASKS = "UPCOMING TASKS: SOON";
    private static final String HEADER_DEF_EVENTS = "UPCOMING EVENTS: SOON";
    
    /**
     * This method initializes all the interface components for the default view,
     * primarily the task window and the event window
     */
    protected static void initDefView() {
        initDefTaskView(InterfaceController.getLogic().getDefTasks());
        initDefEventView(InterfaceController.getLogic().getDefEvents());
        
        defScrollLine = new Line(0, 0, 0, InterfaceController.WIDTH_DEFAULT_BUTTON);
        
        InterfaceController.defBox = new HBox(defTaskBox, defScrollLine, defEventBox);
        
        // Component formatting
        defTaskScroll.prefViewportWidthProperty().bind(
        		InterfaceController.defBox.widthProperty().divide(2));
        defEventScroll.prefViewportWidthProperty().bind(
        		InterfaceController.defBox.widthProperty().divide(2));
        defTaskScroll.maxWidthProperty().bind(
        		InterfaceController.defBox.widthProperty().divide(2));
        defEventScroll.maxWidthProperty().bind(
        		InterfaceController.defBox.widthProperty().divide(2));
        
        // CSS
        defScrollLine.getStyleClass().add("line");
    }
    
    /**
     * This method updates the default view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 	2. 	updateMainInterface() in InterfaceController to update the view when
     * 		a view change command is issued (button/hotkey/text command)
     */
    protected static void updateDefView() {
    	// Clear the previous content already displayed
        defTaskContentBox.getChildren().clear();
        defEventContentBox.getChildren().clear();
        ViewIndexMap.resetDefMap();
        
        // Get the results of the file from logic
        String[] tasks = InterfaceController.getLogic().getDefTasks();
        String[] events = InterfaceController.getLogic().getDefEvents();
        
        int numOfElements = InterfaceController.getLogic().getDefElementsCount();
        int numOfResults = 1;
        
        numOfResults = updateDefTasks(tasks, numOfElements, numOfResults);
        numOfResults = updateDefEvents(events, numOfElements, numOfResults);
    }

    // ================================================================================
    // Getters for logicControl to access required JavaFX components
    // ================================================================================
    
    /**
     * This method returns the line separator between the task and event views 
     * 
     * @return The Line object separating the task and event views.
     */
    protected static Line getDefScrollLine() {
    	return defScrollLine;
    }
    
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
    
    /**
     * This method initializes the task view for the default view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getDefTasks()
     */
    private static void initDefTaskView(String[] tasks) {
    	Label defTaskHeader = new Label(HEADER_DEF_TASKS);
        defTaskHeaderBox = new HBox(defTaskHeader);
        defTaskContentBox = new VBox();
        int numOfElements = InterfaceController.getLogic().getDefElementsCount();
        
        initDefTasks(tasks, numOfElements);
        defTaskScroll = new ScrollPane(defTaskContentBox);
        defTaskBox = new VBox(defTaskHeaderBox, defTaskScroll);
        
        // Component formatting
        defTaskHeaderBox.setAlignment(Pos.CENTER);
        defTaskScroll.setFitToWidth(true);
        VBox.setVgrow(defTaskScroll, Priority.ALWAYS);
        defTaskBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(defTaskHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(defTaskHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(defTaskScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        defTaskScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        defTaskScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        defTaskHeader.getStyleClass().add("box-title-label");
        defTaskHeaderBox.getStyleClass().add("box-title");
    }

    /**
     * This method initializes the event view for the default view
     * 
     * @param events
     * 		      A String[] of tasks returned from LogicController's
     * 			  getDefEvents()
     */
    private static void initDefEventView(String[] events) {
    	Label defEventHeader = new Label(HEADER_DEF_EVENTS);
        defEventHeaderBox = new HBox(defEventHeader);
        defEventContentBox = new VBox();
        int numOfElements = InterfaceController.getLogic().getDefElementsCount();
        
        initDefEvents(events, numOfElements);
        defEventScroll = new ScrollPane(defEventContentBox);
        defEventBox = new VBox(defEventHeaderBox, defEventScroll);
        
        // Component formatting
        defEventHeaderBox.setAlignment(Pos.CENTER);
        defEventScroll.setFitToWidth(true);
        VBox.setVgrow(defEventScroll, Priority.ALWAYS);
        defEventBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(defEventHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(defEventHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(defEventScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        defEventScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        defEventScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        defEventHeader.getStyleClass().add("box-title-label");
        defEventHeaderBox.getStyleClass().add("box-title");
    }

	/**
	 * This method initializes the task content of the default view with data
	 * 
	 * @param tasks
	 * 			  The array of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initDefTasks(String[] tasks, int numOfElements) {
		for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, 1, true, View.DEFAULT);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            defTaskContentBox.getChildren().add(tempBox);
        }
	}
	
	/**
	 * This method initializes the event content of the default view with data
	 * 
	 * @param events
	 * 			  The array of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initDefEvents(String[] events, int numOfElements) {
		for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, 1, false, View.DEFAULT);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            defEventContentBox.getChildren().add(tempBox);
        }
	}
	
	/**
	 * This method updates the task content of the default view with the
     * updated data
     * 
	 * @param tasks
	 * 			  The updated array of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @param index
	 * 			  The view index of the particular task/event
	 * @return The index of the last element to be added
	 */
	private static int updateDefTasks(String[] tasks, int numOfElements, int index) {
		for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, index, true, View.DEFAULT);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            defTaskContentBox.getChildren().add(tempBox);
			// Only increment the counter if an element is added
			if (InterfaceController.getLogic().isNonEmptyElement(tasks[i])) {
				index++;
			}
        }
		return index;
	}
	
	/**
	 * This method updates the event content of the default view with the
     * updated data
     * 
	 * @param events
	 * 			  The updated array of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @param index
	 * 			  The view index of the particular task/event
	 * @return The index of the last element to be added
	 */
	private static int updateDefEvents(String[] events, int numOfElements, int index) {
		// Run the loop through the entire event list
        for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, index, false, View.DEFAULT);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            defEventContentBox.getChildren().add(tempBox);
			// Only increment the counter if an element is added
			if (InterfaceController.getLogic().isNonEmptyElement(events[i])) {
				index++;
			}
        }
		return index;
	}
}
```
###### gui\DoneViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Line;
import struct.View;

public class DoneViewController {

	// ================================================================================
    // JavaFX controls used in the all interface
    // ================================================================================
	
	// Used for initDoneTaskView
    private static VBox doneTaskBox, doneTaskContentBox;
    private static HBox doneTaskHeaderBox;
    private static ScrollPane doneTaskScroll;

    // Used for initDoneEventView
    private static VBox doneEventBox, doneEventContentBox;
    private static HBox doneEventHeaderBox;
    private static ScrollPane doneEventScroll;

    // Used for initDoneView
    private static Line doneScrollLine;
    
    private static final String HEADER_DONE_TASKS = "COMPLETED TASKS";
    private static final String HEADER_DONE_EVENTS = "COMPLETED EVENTS";
    
    /**
     * This method initializes all the interface components for the done view,
     * primarily the task window and the event window
     */
    protected static void initDoneView() {
        initDoneTaskView(InterfaceController.getLogic().getDoneTasks());
        initDoneEventView(InterfaceController.getLogic().getDoneEvents());
        
        doneScrollLine = new Line(0, 0, 0, InterfaceController.WIDTH_DEFAULT_BUTTON);
        InterfaceController.doneBox = new HBox(doneTaskBox, doneScrollLine, doneEventBox);
        
        // Component formatting
        doneTaskScroll.prefViewportWidthProperty().bind(
        		InterfaceController.doneBox.widthProperty().divide(2));
        doneEventScroll.prefViewportWidthProperty().bind(
        		InterfaceController.doneBox.widthProperty().divide(2));
        
        doneTaskScroll.maxWidthProperty().bind(
        		InterfaceController.doneBox.widthProperty().divide(2));
        doneEventScroll.maxWidthProperty().bind(
        		InterfaceController.doneBox.widthProperty().divide(2));
        
        doneScrollLine.endYProperty().bind(DefaultViewController.getDefScrollLine().endYProperty());
        
        // CSS
        doneScrollLine.getStyleClass().add("line");
    }
    
    /**
     * This method updates the done view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 	2. 	updateMainInterface() in InterfaceController to update the view when
     * 		a view change command is issued (button/hotkey/text command)
     */
    protected static void updateDoneView() {
    	// Clear the previous content already displayed
        doneTaskContentBox.getChildren().clear();
        doneEventContentBox.getChildren().clear();
        ViewIndexMap.resetDoneMap();
        
        String[] tasks = InterfaceController.getLogic().getDoneTasks();
        String[] events = InterfaceController.getLogic().getDoneEvents();
    	int numOfElements = InterfaceController.getLogic().getDoneElementsCount();
    	
    	int numOfResults = 1;
    	numOfResults = InterfaceController.updateTasks(
    			tasks, numOfElements, numOfResults, View.DONE, doneTaskContentBox);
    	numOfResults = InterfaceController.updateEvents(
    			events, numOfElements, numOfResults, View.DONE, doneEventContentBox);
    }
    
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
    
    /**
     * This method initializes the task view for the done view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getDoneTasks()
     */
    private static void initDoneTaskView(String[] tasks) {
    	Label doneTaskHeader = new Label(HEADER_DONE_TASKS);
        doneTaskHeaderBox = new HBox(doneTaskHeader);
        doneTaskContentBox = new VBox();
        
        for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	int numOfElements = InterfaceController.getLogic().getDoneElementsCount();
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, 1, true, View.DONE);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            doneTaskContentBox.getChildren().add(tempBox);
        }
        
        doneTaskScroll = new ScrollPane(doneTaskContentBox);
        doneTaskBox = new VBox(doneTaskHeaderBox, doneTaskScroll);
        
        // Component formatting
        doneTaskHeaderBox.setAlignment(Pos.CENTER);
        doneTaskScroll.setFitToWidth(true);
        VBox.setVgrow(doneTaskScroll, Priority.ALWAYS);
        doneTaskBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(doneTaskHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(doneTaskHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(doneTaskScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        doneTaskScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        doneTaskHeader.getStyleClass().add("box-title-label");
        doneTaskHeaderBox.getStyleClass().add("box-title-all-task");
    }

    /**
     * This method initializes the event view for the done view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getDoneEvents()
     */
    private static void initDoneEventView(String[] events) {
    	Label doneEventHeader = new Label(HEADER_DONE_EVENTS);
        doneEventHeaderBox = new HBox(doneEventHeader);
        doneEventContentBox = new VBox();
        
        for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	int numOfElements = InterfaceController.getLogic().getDoneElementsCount();
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, 1, false, View.DONE);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            doneEventContentBox.getChildren().add(tempBox);
        }
        
        doneEventScroll = new ScrollPane(doneEventContentBox);
        doneEventBox = new VBox(doneEventHeaderBox, doneEventScroll);
        
        // Component formatting
        doneEventHeaderBox.setAlignment(Pos.CENTER);
        doneEventScroll.setFitToWidth(true);
        VBox.setVgrow(doneEventScroll, Priority.ALWAYS);
        doneEventBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(doneEventHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(doneEventHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(doneEventScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        doneEventScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        doneEventHeader.getStyleClass().add("box-title-label");
        doneEventHeaderBox.getStyleClass().add("box-title-all-event");
    }

}
```
###### gui\HelpController.java
``` java
 */

package gui;

import java.util.logging.Level;

import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.image.ImageView;
import struct.View;

public class HelpController {

    // Used for initHelpDialog
    private static ImageView helpImage;
    private static ScrollPane helpScroll;
    
    private static boolean isHelpOpen;
    
    private static final String PATH_HELP_DIALOG = "gui/resources/help_dialog.jpg";
    
    /**
     * This method initializes all the interface components for the help window
     */
    public static void initHelpScene() {
    	isHelpOpen = false;
    	
    	helpImage = new ImageView(PATH_HELP_DIALOG);
    	helpScroll = new ScrollPane(helpImage);
    	
    	// Component formatting
    	helpImage.setFitWidth(MainApp.WIDTH_HELP_DIALOG);
    	helpImage.setPreserveRatio(true);

    	helpScroll.setFitToWidth(true);
    	helpScroll.setVbarPolicy(ScrollBarPolicy.NEVER);
    	helpScroll.setHbarPolicy(ScrollBarPolicy.NEVER);
    	
    	MainApp.helpScene = new Scene(helpScroll);
    }
    
	// ================================================================================
    // Protected methods use to control the visibility of the help dialog
    // ================================================================================
    
    protected static void toggleHelpDialog() {
    	if (!isHelpOpen) {
    		openHelpDialog();
    	} else {
    		closeHelpDialog();
    	}
    }
    
    protected static void openHelpDialog() {
		// Set help button to selected
		InterfaceController.changeButtonToSelected(View.HELP);
		isHelpOpen = true;
		MainApp.help.show();
		MainApp.help.requestFocus();
		MainApp.logger.log(Level.INFO, MainApp.LOG_HELP_OPEN);
    }
    
    protected static void closeHelpDialog() {
		// Set help button to unselected
		InterfaceController.changeButtonToUnselected(View.HELP);
		isHelpOpen = false;
		MainApp.help.close();
		MainApp.logger.log(Level.INFO, MainApp.LOG_HELP_CLOSE);
    }
}
```
###### gui\HistoryViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import struct.View;

public class HistoryViewController {

	// ================================================================================
    // JavaFX controls used in the default interface
    // ================================================================================
	
	// Used for initAllTaskView
    private static VBox histBox, histContentBox;
    private static HBox histHeaderBox;
    private static ScrollPane histScroll;
    
    private static final String HEADER_HISTORY = "OPERATION HISTORY";
    private static final String MESSAGE_EMPTY_HIST = "No operations performed yet.";
    
    private static int messageIndex = 0;

    /**
     * This method initializes all the interface components for the history view
     */
    protected static void initHistView() {
    	Label histHeader = new Label(HEADER_HISTORY);
        histHeaderBox = new HBox(histHeader);
        histHeaderBox.setAlignment(Pos.CENTER);
        
        // History view is empty when first initialized,
        // add one message for no operations performed yet
        HBox initialBox = initHistoryElement("", MESSAGE_EMPTY_HIST);
        VBox.setMargin(initialBox, new Insets(
        		0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
        
        histContentBox = new VBox(initialBox);
        histScroll = new ScrollPane(histContentBox);
        histBox = new VBox(histHeaderBox, histScroll);
        InterfaceController.histBox = new HBox(histBox);
        
        histContentBox.heightProperty().addListener(
        		Listeners.getScrollListener(View.HISTORY));
        
        // Component formatting
        HBox.setMargin(histHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        // Reducing the margin by line width to compensate for the added vertical
        // separator in the default and all views
        VBox.setMargin(histHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL - InterfaceController.WIDTH_VERT_LINE, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(histScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL - InterfaceController.WIDTH_VERT_LINE, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        histBox.setAlignment(Pos.CENTER);
        histBox.setAlignment(Pos.CENTER);
        VBox.setVgrow(histScroll, Priority.ALWAYS);
        histScroll.setFitToWidth(true);
        histScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        histScroll.prefViewportWidthProperty().bind(InterfaceController.histBox.widthProperty());
        
        // CSS
        histHeader.getStyleClass().add("box-title-label");
        histHeaderBox.getStyleClass().add("box-title-history");
    }
    
    /**
     * This method updates the history view by adding the feedback message to the view
     * 
     * @param feedbackMessage
     * 			  The feedback message returned from executeCommand()
     */
    protected static void updateHistView(String feedbackMessage) {
        messageIndex++;
        
        // Use a temporary component for formatting
        HBox tempBox = initHistoryElement(String.valueOf(messageIndex), feedbackMessage);
        if (messageIndex == 1) {
        	histContentBox.getChildren().clear();
        }
        histContentBox.getChildren().add(tempBox);
        
        // Component formatting
        VBox.setMargin(tempBox, new Insets(
        		0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
    }
    
    // ================================================================================
    // Getters for logicControl to access required JavaFX components
    // ================================================================================
    
    protected static ScrollPane getHistScroll() {
    	return histScroll;
    }
    
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
    
    /**
     * This method creates a HBox containing a history view element
     * 
     * @param index
     * 		      The index of the element to be created
     * @param feedbackMessage
     * 			  The feedback message returned from Logic's executeCommand() method
     * 			  to be added into the history
     * @return A formatted HBox containing the history data
     */
    private static HBox initHistoryElement(String index, String feedbackMessage) {
    	Label feedbackIndex = new Label(index);
    	HBox indexBox = new HBox(feedbackIndex);
    	Label feedbackLabel = new Label(feedbackMessage);
    	HBox feedbackBox = new HBox(indexBox, feedbackLabel);

    	// Component formatting
    	if (index != "") {
        	// If is default and no commands entered, do not display index background
        	setToMaxWidth(index, indexBox);
    	}
    	
    	feedbackLabel.setWrapText(true);
    	indexBox.setAlignment(Pos.CENTER);
    	
    	HBox.setMargin(feedbackLabel, new Insets(
    			InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
    			InterfaceController.MARGIN_TEXT_ELEMENT, 
    			InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 
    			InterfaceController.MARGIN_TEXT_ELEMENT));

    	// CSS
    	feedbackBox.getStyleClass().add("element");
    	indexBox.getStyleClass().add("element-index-history");
    	feedbackIndex.getStyleClass().add("element-index-label");
    	
    	return feedbackBox;
    }

	/**
	 * This method calculates the maximum width used by the current largest index
	 * and sets the indexBox to that width to ensure consistency
	 * 
	 * @param index
	 * 			  The view index to be inserted into indexBox
	 * @param indexBox
	 * 		      The HBox containing the index to be formatted
	 */
	private static void setToMaxWidth(String index, HBox indexBox) {
		// Get the width of label and resize the line
		Text text = new Text(String.valueOf(index));
		Scene s = new Scene(new Group(text));
		// Override the CSS style to calculate the text width
		text.setStyle("-fx-font-family: \"Myriad Pro\"; "
				+ "-fx-font-size: 16; ");
		text.applyCss();
		double textWidth = Math.ceil(text.getLayoutBounds().getWidth());
		indexBox.setMinWidth(textWidth + 2 * InterfaceController.MARGIN_TEXT_ELEMENT);
	}
}
```
###### gui\InterfaceController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.shape.Line;
import struct.View;

import java.util.logging.Level;
import java.util.regex.Pattern;

public class InterfaceController {

    // ==================================================
    // JavaFX controls used in the general interface
    // ==================================================

    // Used for initFilePathBar
	private static ImageView filepathConfig;
    private static HBox filepathBox, filepathLabelBox, filepathConfigBox;
    private static VBox filepathBoxWithLine;
    private static Label filepathLabel;
    private static Line filepathLine;

    // Used for initSideBarDefButton
    private static VBox sbDefBox;
    private static ImageView sbDefImage;
    
    // Used for initSideBarAllButton
    private static VBox sbAllBox;
    private static ImageView sbAllImage;
    
    // Used for initSideBarUnresButton
    private static VBox sbUnresBox;
    private static ImageView sbUnresImage;
    
    // Used for initSideBarDoneButton
    private static VBox sbDoneBox;
    private static ImageView sbDoneImage;
    
    // Used for initSideBarSearchButton
    private static VBox sbSearchBox;
    private static ImageView sbSearchImage;
    
    // Used for initSideBarHistoryButton
    private static VBox sbHistBox;
    private static ImageView sbHistImage;
    
    // Used for initSideBarHelpButton
    private static VBox sbHelpBox;
    private static ImageView sbHelpImage;
    
    // Used for initSideBarACIndicator
    private static VBox sbACBox;
    private static ImageView sbACImage;
    
    // Used for initSideBar
    private static VBox sbBox;
    private static HBox sbBoxWithLine;
    private static Line sbLine;

    // Used for initTextField
    private static VBox textBox;
    private static TextField textField;

    // Used for initFeedbackBar
    private static VBox feedbackBox, feedbackBoxWithLine;
    private static Label feedbackLabel;
    private static Line feedbackLine;

    // Used for initMainInterface
    private static Scene mainScene;
    private static VBox contentBoxNoSideBar, mainBox;
    private static HBox contentBoxWithSideBar, viewBox;
    private static Line viewLine;
    
    // Used for updateMainInterface
    protected static HBox defBox, allBox, histBox, doneBox, unresBox;
    protected static VBox summaryBox, searchBox;

    private static LogicController logicControl;  
    private static View currentView;
    
    // ======================================================================
    // Constants and fixed Strings used for program operations
    // ======================================================================
    
    // File paths for all images used
    protected static final String PATH_DEFAULT = "gui/resources/home.png";
    protected static final String PATH_DEFAULT_SELECTED = "gui/resources/home_selected.png";
    protected static final String PATH_DEFAULT_HOVER = "gui/resources/home_hover.png";
    protected static final String PATH_ALL = "gui/resources/all.png";
    protected static final String PATH_ALL_SELECTED = "gui/resources/all_selected.png";
    protected static final String PATH_ALL_HOVER = "gui/resources/all_hover.png";
    protected static final String PATH_HIST = "gui/resources/history.png";
    protected static final String PATH_HIST_SELECTED = "gui/resources/history_selected.png";
    protected static final String PATH_HIST_HOVER = "gui/resources/history_hover.png";
    protected static final String PATH_UNRESOLVED = "gui/resources/unresolved.png";
    protected static final String PATH_UNRESOLVED_SELECTED = "gui/resources/unresolved_selected.png";
    protected static final String PATH_UNRESOLVED_HOVER = "gui/resources/unresolved_hover.png";
    protected static final String PATH_DONE = "gui/resources/done.png";
    protected static final String PATH_DONE_SELECTED = "gui/resources/done_selected.png";
    protected static final String PATH_DONE_HOVER = "gui/resources/done_hover.png";
    protected static final String PATH_SEARCH = "gui/resources/search.png";
    protected static final String PATH_SEARCH_SELECTED = "gui/resources/search_selected.png";
    protected static final String PATH_SEARCH_HOVER = "gui/resources/search_hover.png";
    protected static final String PATH_HELP = "gui/resources/help.png";
    protected static final String PATH_HELP_SELECTED = "gui/resources/help_selected.png";
    protected static final String PATH_HELP_HOVER = "gui/resources/help_hover.png";
    protected static final String PATH_AC = "gui/resources/acIndicator.png";
    protected static final String PATH_CONFIG = "gui/resources/config.png";
    protected static final String PATH_TICK = "gui/resources/tick.png";
    
    protected static final String STATUS_TODO = "todo";
    protected static final String STATUS_DONE = "done";
    
    // Feedback messages
	protected static final String MESSAGE_ERROR_FILESYSTEM = "Failed to create the file.";
	protected static final String MESSAGE_EMPTY = "There are no items to display.";
	protected static final String MESSAGE_INVALID_INDEX = "Invalid index number entered.";
	
	protected static final String CSS_UNDERLINE = "-fx-underline: true;";
	protected static final String CSS_NO_UNDERLINE = "-fx-underline: false;";
	protected static final String CSS_UNDERLINE_ITALIC = CSS_UNDERLINE + "-fx-font-style: italic;";
	protected static final String CSS_NO_UNDERLINE_ITALIC = CSS_NO_UNDERLINE + "-fx-font-style: italic;";
    
    // Dimension variables used for sizing JavaFX components
    protected static final double WIDTH_DEFAULT = 100;
    protected static final double WIDTH_DEFAULT_BUTTON = 50;
    protected static final double WIDTH_SIDEBAR = 71;
    
    protected static final double HEIGHT_FILEPATH = 31;
    protected static final double HEIGHT_FEEDBACK = 31;
    protected static final double HEIGHT_TEXT_BOX = 40;
    protected static final double HEIGHT_TEXT_FIELD = 26;
    
    protected static final double WIDTH_VERT_LINE = 1;
    protected static final double HEIGHT_HORIZ_LINE = 1;
    
    protected static final double MARGIN_TEXT_BAR = 20;
    protected static final double MARGIN_TEXT_ELEMENT = 10;
    protected static final double MARGIN_TEXT_ELEMENT_HEIGHT = 3;
    protected static final double MARGIN_TEXT_ELEMENT_SEPARATOR = 10;
    protected static final double MARGIN_TEXT_FIELD = (HEIGHT_TEXT_BOX - HEIGHT_TEXT_FIELD) / 2;
    protected static final double MARGIN_BUTTON = 20;
    protected static final double MARGIN_COMPONENT = 10;
    protected static final double MARGIN_SCROLL = 30;
    protected static final double MARGIN_ARBITRARY = 6;
    protected static final double MARGIN_TICK = 10;
    protected static final double MARGIN_AC_INDICATOR = 13;

    /**
     * Public method to initialize the logic unit for the interface
     */
    public static void initLogicControl() {
        logicControl = new LogicController();
    }
    
    // ===============================================================
    // Protected methods to initialize, update and close the main 
    // interface
    // ===============================================================
    
    /**
     * This method initializes all the components of the interface except for 
     * the viewBox, the area where the views are displayed.
     * 
     * Views are saved as HBoxes within this class, and swapped into viewBox
     * as and when called by updateMainInterface
     */
    public static void initMainInterface() {
    	// Initial view set to ALL, 
    	// just a dummy state other than DEFAULT
    	currentView = View.ALL;
        ViewIndexMap.initAllMaps();
        initLogicControl();
        initSubComponents();
        initViewComponents();
        
        // Initial view will be empty
        viewBox = new HBox();
        viewLine = new Line(0, 0, WIDTH_DEFAULT, 0);

        contentBoxNoSideBar = new VBox(
        		filepathBoxWithLine, 
        		viewBox, 
        		viewLine, 
        		feedbackBoxWithLine, 
        		textBox);
        contentBoxWithSideBar = new HBox(sbBoxWithLine, contentBoxNoSideBar);
        mainBox = new VBox(contentBoxWithSideBar);
        mainScene = new Scene(mainBox);
        
        // Component formatting
        VBox.setVgrow(viewBox, Priority.ALWAYS);
        HBox.setHgrow(contentBoxNoSideBar, Priority.ALWAYS);
        VBox.setVgrow(contentBoxWithSideBar, Priority.ALWAYS);
        
        // Set resize listeners for the main scene
        mainScene.heightProperty().addListener(Listeners.getHeightListener());
        mainScene.widthProperty().addListener(Listeners.getWidthListener());

        // CSS
        viewLine.getStyleClass().add("line");
        mainScene.getStylesheets().add(InterfaceController.class.getResource(
                "/gui/stylesheets/Interface.css").toExternalForm());

        // Set the scene in MainApp
        MainApp.scene = mainScene;
    }
    
    /**
     * This method changes the view currently displayed in viewBox to the one
     * specified in the method call
     * 
     * @param view
     * 		      The view to display in the application window
     */
    protected static void updateMainInterface(View view) {
    	assert viewBox != null;
    	viewBox.getChildren().clear();
    	
    	switch (view) {
	    	case DEFAULT:
	    		DefaultViewController.updateDefView();
	    		viewBox.getChildren().add(defBox);
	    		
	    		// Component formatting
	            HBox.setHgrow(defBox, Priority.ALWAYS);
	            
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.DEFAULT);
	            
	            currentView = View.DEFAULT;
	    		break;
	    		
	    	case ALL:
	    		AllViewController.updateAllView();
	    		viewBox.getChildren().add(allBox);
	    		
	    		// Component formatting
	            HBox.setHgrow(allBox, Priority.ALWAYS);
	            
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.ALL);
	            
	            currentView = View.ALL;
	    		break;
	    		
	    	case HISTORY:
	    		viewBox.getChildren().add(histBox);
	    		
	    		// Component formatting
	            HBox.setHgrow(histBox, Priority.ALWAYS);
	    		
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.HISTORY);
	            
	            currentView = View.HISTORY;
	    		break;
	    		
	    	case UNRESOLVED:
	    		UnresolvedViewController.updateUnresView();
	    		viewBox.getChildren().add(unresBox);
	    		
	    		// Component formatting
	    		HBox.setHgrow(unresBox, Priority.ALWAYS);
	    		
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.UNRESOLVED);
	            
	            currentView = View.UNRESOLVED;
	    		break;
	    		
	    	case DONE:
	    		DoneViewController.updateDoneView();
	    		viewBox.getChildren().add(doneBox);
	    		
	    		// Component formatting
	    		HBox.setHgrow(doneBox, Priority.ALWAYS);
	    		
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.DONE);
	            
	            currentView = View.DONE;
	    		break;
	    		
	    	case SEARCH:
	    		viewBox.getChildren().add(searchBox);
	    		
	    		// Component formatting
	            HBox.setHgrow(searchBox, Priority.ALWAYS);
	    		
	            changeButtonToUnselected(currentView);
	            changeButtonToSelected(View.SEARCH);
	            
	            currentView = View.SEARCH;
	    		break;
	    		
	    	case SUMMARY:
	    		SummaryViewController.updateSummaryView();
	    		viewBox.getChildren().add(summaryBox);
	    		
	    		// Component formatting
	            HBox.setHgrow(summaryBox, Priority.ALWAYS);
	    		break;
	    		
	    	default: //ignore
	    		break;
    	}
    }
    
    protected static void closeMainInterface() {
    	currentView = View.EXIT;
    	MainApp.stage.close();
    	MainApp.logger.log(Level.INFO, MainApp.LOG_CLOSE);
    }
    
    // ===============================================================
    // Protected methods to update and modify certain UI elements
    // from other GUI components
    // ===============================================================
    
    /**
     * This method updates the various task content of the various views with
     * updated data
     * 
     * @param tasks
     * 		      The updated array of task data to be displayed in the view
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 			  The view index of the particular task/event 
     * @param targetView
     * 			  The View of which the updated task list will be displayed in
     * @param contentBox
     * 		      The VBox that contains the list of task data to be displayed
     * @return The index of the last element to be added
     */
	protected static int updateTasks(String[] tasks, int numOfElements, 
			int index, View targetView, VBox contentBox) {
		
    	// Only print the empty message if there are zero results
		if (tasks.length == 3 && InterfaceController.getLogic().isEmpty(tasks[2])) {
    		HBox tempBox = InterfaceController.initDisplayElement(
    				tasks[2], numOfElements, index, true, targetView);
    		VBox.setMargin(tempBox, new Insets(
    				0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
    		contentBox.getChildren().add(tempBox);
    	} else {
    		// If there are no results for floating tasks
    		if (InterfaceController.getLogic().isEmpty(tasks[tasks.length - 1])) {
    			for (int i = 0; i < tasks.length; i++) {
    				HBox tempBox = InterfaceController.initDisplayElement(
    						tasks[i], numOfElements, index, true, targetView);
    				VBox.setMargin(tempBox, new Insets(
    						0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
    				contentBox.getChildren().add(tempBox);
    				// Only increment the counter if an element is added
    				if (InterfaceController.getLogic().isNonEmptyElement(tasks[i])) {
    					index++;
    				}
    			}
    		} else {
    			for (int i = 0; i < tasks.length; i++) {
    				if (!InterfaceController.getLogic().isEmpty(tasks[i])) {
    					HBox tempBox = InterfaceController.initDisplayElement(
    							tasks[i], numOfElements, index, true, targetView);
    					VBox.setMargin(tempBox, new Insets(
    							0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
    					contentBox.getChildren().add(tempBox);
    					// Only increment the counter if an element is added
    					if (InterfaceController.getLogic().isNonEmptyElement(tasks[i])) {
    						index++;
    					}
    				}
    			}
    		}
    	}
		return index;
	}
	
    /**
     * This method updates the various event content of the various views with
     * updated data
     * 
     * @param events
     * 		      The updated array of event data to be displayed in the view
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 			  The view index of the particular task/event 
     * @param targetView
     * 			  The View of which the updated event list will be displayed in
     * @param contentBox
     * 		      The VBox that contains the list of event data to be displayed
     * @return The index of the last element to be added
     */
	protected static int updateEvents(String[] events, int numOfElements, 
			int index, View targetView, VBox contentBox) {
		
    	for (int i = 0; i < events.length; i++) {
    		HBox tempBox = InterfaceController.initDisplayElement(events[i], numOfElements, index, false, targetView);
    		VBox.setMargin(tempBox, new Insets(
    				0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
    		contentBox.getChildren().add(tempBox);
    		if (InterfaceController.getLogic().isNonEmptyElement(events[i])) {
    			index++;
    		}
    	}
		return index;
	}
	
    /**
     * This method updates the filepath shown in the filepath bar by calling
     * the getFilePath() method in LogicController
     */
    protected static void updateFilePathBar() {
    	filepathLabel = new Label(logicControl.getFilePath());
    	filepathLabelBox.getChildren().clear();
    	filepathLabelBox.getChildren().add(filepathLabel);
        
    	HBox.setHgrow(filepathLabelBox, Priority.ALWAYS);
    	
    	// Event handlers for mouse interaction
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_ENTERED, Handlers.getPathHoverHandler(filepathLabel));
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_EXITED, Handlers.getPathHoverHandler(filepathLabel));
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_CLICKED, Handlers.getPathClickHandler());
    }

    /**
     * This method turns the autocomplete indicator in the sidebar
     * on/off based on whether autocomplete is activated
     */
    protected static void toggleAutoCompleteIndicator() {
    	sbACBox.getChildren().clear();
    	
    	if (!AutoComplete.isActivated()) {
    		sbACBox.getChildren().add(sbACImage);
    	}
    }
    
    /**
     * This method switches the button image to its corresponding selected
     * state
     * 
     * @param view
     *            The view which button is to be changed
     */
    protected static void changeButtonToSelected(View view) {
    	switch (view) {
	    	case DEFAULT:
	    		sbDefImage = new ImageView(PATH_DEFAULT_SELECTED);
	    		sbDefBox.getChildren().clear();
	    		sbDefBox.getChildren().add(sbDefImage);
	    		break;
	    	case ALL:
	    		sbAllImage = new ImageView(PATH_ALL_SELECTED);
	    		sbAllBox.getChildren().clear();
	    		sbAllBox.getChildren().add(sbAllImage);
	    		break;
	    	case HISTORY:
	    		sbHistImage = new ImageView(PATH_HIST_SELECTED);
	    		sbHistBox.getChildren().clear();
	    		sbHistBox.getChildren().add(sbHistImage);
	    		break;
	    	case UNRESOLVED:
	    		sbUnresImage = new ImageView(PATH_UNRESOLVED_SELECTED);
	    		sbUnresBox.getChildren().clear();
	    		sbUnresBox.getChildren().add(sbUnresImage);
	    		break;
	    	case DONE:
	    		sbDoneImage = new ImageView(PATH_DONE_SELECTED);
	    		sbDoneBox.getChildren().clear();
	    		sbDoneBox.getChildren().add(sbDoneImage);
	    		break;
	    	case SEARCH:
	    		sbSearchImage = new ImageView(PATH_SEARCH_SELECTED);
	    		sbSearchBox.getChildren().clear();
	    		sbSearchBox.getChildren().add(sbSearchImage);
	    		break;
	    	case HELP:
	    		sbHelpImage = new ImageView(PATH_HELP_SELECTED);
	    		sbHelpBox.getChildren().clear();
	    		sbHelpBox.getChildren().add(sbHelpImage);
	    		break;
	    	default:
	    		// Do nothing
	    		break;
    	}
    }
    
    /**
     * This method switches the button image to its corresponding unselected
     * state
     * 
     * @param view
     *            The view which button is to be changed
     */
    protected static void changeButtonToUnselected(View view) {
    	switch (view) {
	    	case DEFAULT:
	    		sbDefImage = new ImageView(PATH_DEFAULT);
	    		sbDefBox.getChildren().clear();
	    		sbDefBox.getChildren().add(sbDefImage);
	    		break;
	    	case ALL:
	    		sbAllImage = new ImageView(PATH_ALL);
	    		sbAllBox.getChildren().clear();
	    		sbAllBox.getChildren().add(sbAllImage);
	    		break;
	    	case HISTORY:
	    		sbHistImage = new ImageView(PATH_HIST);
	    		sbHistBox.getChildren().clear();
	    		sbHistBox.getChildren().add(sbHistImage);
	    		break;
	    	case UNRESOLVED:
	    		sbUnresImage = new ImageView(PATH_UNRESOLVED);
	    		sbUnresBox.getChildren().clear();
	    		sbUnresBox.getChildren().add(sbUnresImage);
	    		break;
	    	case DONE:
	    		sbDoneImage = new ImageView(PATH_DONE);
	    		sbDoneBox.getChildren().clear();
	    		sbDoneBox.getChildren().add(sbDoneImage);
	    		break;
	    	case SEARCH:
	    		sbSearchImage = new ImageView(PATH_SEARCH);
	    		sbSearchBox.getChildren().clear();
	    		sbSearchBox.getChildren().add(sbSearchImage);
	    		break;
	    	case HELP:
	    		sbHelpImage = new ImageView(PATH_HELP);
	    		sbHelpBox.getChildren().clear();
	    		sbHelpBox.getChildren().add(sbHelpImage);
	    		break;
	    	default:
	    		// Do nothing
	    		break;
    	}
    }
    
    
    /**
     * This method takes in an input String and creates a HBox with all the required
     * data formatted correctly to be inserted into one of the task/event windows.
     * 
     * @param displayData
     * 		      The task/event data to be displayed in the window
     * @param numOfElements
     * 		      The total number of tasks/events. Used for formatting the index box
     * @param index
     * 		      The view index of the particular task/event
     * @param isTask
     * 			  A boolean flag indicating whether the data to be input is a task
     * @return A HBox with the correct task/event data type(title, empty, data) 
     * 		   formatted for insertion into the scroll pane
     */
    protected static HBox initDisplayElement(String displayData, int numOfElements, 
    		int index, boolean isTask, View targetView) {
    	// If is a date or title element
    	if (InterfaceController.getLogic().isTitleOrDate(displayData)) {
    		return Constructor.initTitleOrDateElement(displayData);
    	} else {
    		assert !InterfaceController.getLogic().isTitleOrDate(displayData);
    		// Determine whether the element data is an element or a null response
    		String[] displayDataSplit = displayData.split(Pattern.quote("."));
    		// If no items to display
    		if (displayDataSplit.length == 1) {
    			return Constructor.initNoResultElement(displayData);
    		} else {
    			assert displayDataSplit.length != 1;
    			return Constructor.initDataElement(displayData, numOfElements, index, 
    					isTask, displayDataSplit, targetView);
    		}
    	}
    }
    
    // ===============================================================
    // Getters for JavaFX components required for LogicController
    // ===============================================================
    
    // Getters for textField and feedbackLabel to allow updates
    protected static TextField getTextField() {
    	return textField;
    }
    
    protected static Label getFeedbackLabel() {
    	return feedbackLabel;
    }
    
    // Getters for line components for binding to window sizes
    protected static Line getSbLine() {
    	return sbLine;
    }
    
    protected static Line getFeedbackLine() {
    	return feedbackLine;
    }
    
    protected static Line getViewLine() {
    	return viewLine;
    }
    
    protected static Line getFilepathLine() {
    	return filepathLine;
    }
    
    // Getters for buttons to allow access to the EventHandlers
    // in LogicController
    protected static VBox getHomeButton() {
    	return sbDefBox;
    }
    
    protected static VBox getAllButton() {
    	return sbAllBox;
    }
    
    protected static VBox getHistButton() {
    	return sbHistBox;
    }
    
    protected static VBox getUnresButton() {
    	return sbUnresBox;
    }
    
    protected static VBox getDoneButton() {
    	return sbDoneBox;
    }
    
    protected static VBox getSearchButton() {
    	return sbSearchBox;
    }
    
    protected static VBox getHelpButton() {
    	return sbHelpBox;
    }
    
    // ===============================================================
    // Getter and setter for currentView and logicControl
    // ===============================================================
    
    protected static View getCurrentView() {
    	return currentView;
    }
    
    protected static void setCurrentView(View newView) {
    	currentView = newView;
    }
    
    protected static LogicController getLogic() {
    	return logicControl;
    }
	
    // ======================================================================
    // Private methods for initializing components of the main interface
	// Used in initMainInterface()
    // ======================================================================

	/**
	 * Initializes all the views by calling the relevant initializers in all
	 * the view controllers
	 */
	private static void initViewComponents() {
		DefaultViewController.initDefView();
        SummaryViewController.initSummaryView();
        AllViewController.initAllView();
        HistoryViewController.initHistView();
        UnresolvedViewController.initUnresView();
        DoneViewController.initDoneView();
        SearchViewController.initSearchView();
	}

	/**
	 * Initializes sub components of the main interface
	 * (filepathBar, sideBar, feedbackBar, textField)
	 */
	private static void initSubComponents() {
		initFilePathBar();
        initSideBar();
        initFeedbackBar();
        initTextField();
	}
	
    private static void initFilePathBar() {
        filepathLabel = new Label(logicControl.getFilePath());
        filepathLabelBox = new HBox(filepathLabel);
        filepathLine = new Line(0, 0, WIDTH_DEFAULT, 0);
        filepathConfig = new ImageView(PATH_CONFIG);
        filepathConfigBox = new HBox(filepathConfig);
        Region filepathBuffer = new Region();
        filepathBox = new HBox(filepathBuffer, filepathLabelBox, filepathConfigBox);
        filepathBoxWithLine = new VBox(filepathBox, filepathLine);
        
        // Component formatting
        filepathBuffer.setMaxSize(HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE, 
        		HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE);
        filepathBuffer.setMinSize(HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE, 
        		HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE);
        
        HBox.setHgrow(filepathLabelBox, Priority.ALWAYS);
        
        HBox.setMargin(filepathLabel, new Insets(
        		0, MARGIN_TEXT_BAR, 
        		0, MARGIN_TEXT_BAR));
        
        filepathLabelBox.setAlignment(Pos.CENTER);

        filepathBox.setMaxHeight(HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE);
        filepathBox.setMinHeight(HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE);

        filepathBoxWithLine.setMaxHeight(HEIGHT_FILEPATH);
        filepathBoxWithLine.setMinHeight(HEIGHT_FILEPATH);
        
        // Event handlers for mouse interactions
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_ENTERED, 
        		Handlers.getPathHoverHandler(filepathLabel));
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_EXITED, 
        		Handlers.getPathHoverHandler(filepathLabel));
        filepathLabel.addEventHandler(
        		MouseEvent.MOUSE_CLICKED, 
        		Handlers.getPathClickHandler());
        filepathConfigBox.addEventHandler(
        		MouseEvent.MOUSE_CLICKED, 
        		Handlers.getConfigClickHandler());

        // CSS
        filepathLine.getStyleClass().add("line");
        filepathBox.getStyleClass().add("display-bar");
        filepathBox.getStyleClass().add("gradient-regular");
    }
    
    private static void initTextField() {
        textField = new TextField();
        textField.requestFocus();
        textBox = new VBox(textField);
        
        // Component formatting
        textBox.setAlignment(Pos.CENTER);
        VBox.setMargin(textField, new Insets(0, MARGIN_TEXT_FIELD, 0, MARGIN_TEXT_FIELD));

        textBox.setMaxHeight(HEIGHT_TEXT_BOX);
        textBox.setMinHeight(HEIGHT_TEXT_BOX);
        
        textField.setMinHeight(HEIGHT_TEXT_FIELD);
        textField.setMaxHeight(HEIGHT_TEXT_FIELD);
        
        // Event handling for operations
        textField.setOnAction(Handlers.getTextInputHandler());
        textField.addEventFilter(KeyEvent.KEY_PRESSED, Handlers.getKeyPressHandler());
        
        // Initialize the popup for the first time
        AutoComplete.initPopup();
        logicControl.toggleAutoComplete();

        // CSS
        textBox.getStyleClass().add("gradient-regular");
        textField.getStyleClass().add("text-field");
    }

    private static void initFeedbackBar() {
        feedbackLabel = new Label("No commands entered yet.");
        feedbackLine = new Line(0, 0, WIDTH_DEFAULT, 0);

        feedbackBox = new VBox(feedbackLabel);
        feedbackBoxWithLine = new VBox(feedbackBox, feedbackLine);

        // Component formatting
        VBox.setMargin(feedbackLabel, new Insets(
        		0, MARGIN_TEXT_BAR, 
        		0, MARGIN_TEXT_BAR));
        
        feedbackBox.setAlignment(Pos.CENTER);

        feedbackBox.setMaxHeight(HEIGHT_FEEDBACK - HEIGHT_HORIZ_LINE);
        feedbackBox.setMinHeight(HEIGHT_FEEDBACK - HEIGHT_HORIZ_LINE);

        feedbackBoxWithLine.setMaxHeight(HEIGHT_FEEDBACK);
        feedbackBoxWithLine.setMinHeight(HEIGHT_FEEDBACK);

        // CSS
        feedbackLine.getStyleClass().add("line");
        feedbackBox.getStyleClass().add("display-bar");
        feedbackBox.getStyleClass().add("gradient-regular");
    }
    
    private static void initSideBar() {
        initAllSideBarButtons();
        Region sbSpacer = new Region();
        initSideBarACIndicator();
        
        changeButtonToSelected(View.DEFAULT);

        sbBox = new VBox(sbDefBox, 
        		sbAllBox, 
        		sbUnresBox,
        		sbDoneBox, 
        		sbSearchBox,
        		sbHistBox,
        		sbHelpBox, 
        		sbSpacer, 
        		sbACBox);
        sbLine = new Line(0, 0, 0, WIDTH_DEFAULT_BUTTON);
        sbBoxWithLine = new HBox(sbBox, sbLine);

        // Component formatting
        VBox.setVgrow(sbSpacer, Priority.ALWAYS);
        sbBoxWithLine.setMaxWidth(WIDTH_SIDEBAR);
        sbBoxWithLine.setMinWidth(WIDTH_SIDEBAR);

        // CSS
        sbLine.getStyleClass().add("line");
        sbBoxWithLine.getStyleClass().add("sidebar");
    }
    
    // ======================================================================
    // Private methods for initializing buttons in the sidebar
    // ======================================================================
    
    /** 
     * Initializes all the buttons in the sidebar by calling all the private
     * button initializers
     */
	private static void initAllSideBarButtons() {
		initSideBarDefButton();
        initSideBarAllButton();
        initSideBarUnresButton();
        initSideBarDoneButton();
        initSideBarSearchButton();
        initSideBarHistoryButton();
        initSideBarHelpButton();
	}
	
	
	private static void initSideBarDefButton() {
        sbDefImage = new ImageView(PATH_DEFAULT);
        sbDefBox = new VBox(sbDefImage);

        setButtonDimensions(sbDefBox);
        setButtonHandler(sbDefBox, View.DEFAULT);
        
        VBox.setMargin(sbDefBox, new Insets(
        		HEIGHT_FILEPATH - HEIGHT_HORIZ_LINE, 
        		MARGIN_COMPONENT, 
        		MARGIN_BUTTON, 
        		MARGIN_COMPONENT));
    }
    
    private static void initSideBarAllButton() {
    	sbAllImage = new ImageView(PATH_ALL);
    	sbAllBox = new VBox(sbAllImage);

        setButtonDimensions(sbAllBox);
        setButtonHandler(sbAllBox, View.ALL);
        VBox.setMargin(sbAllBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    private static void initSideBarUnresButton() {
    	sbUnresImage = new ImageView(PATH_UNRESOLVED);
    	sbUnresBox = new VBox(sbUnresImage);

        setButtonDimensions(sbUnresBox);
        setButtonHandler(sbUnresBox, View.UNRESOLVED);
        VBox.setMargin(sbUnresBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    private static void initSideBarDoneButton() {
    	sbDoneImage = new ImageView(PATH_DONE);
    	sbDoneBox = new VBox(sbDoneImage);

        setButtonDimensions(sbDoneBox);
        setButtonHandler(sbDoneBox, View.DONE);
        VBox.setMargin(sbDoneBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    private static void initSideBarSearchButton() {
    	sbSearchImage = new ImageView(PATH_SEARCH);
    	sbSearchBox = new VBox(sbSearchImage);

        setButtonDimensions(sbSearchBox);
        setButtonHandler(sbSearchBox, View.SEARCH);
        VBox.setMargin(sbSearchBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    
    private static void initSideBarHistoryButton() {
    	sbHistImage = new ImageView(PATH_HIST);
    	sbHistBox = new VBox(sbHistImage);
    	
        setButtonDimensions(sbHistBox);
        setButtonHandler(sbHistBox, View.HISTORY);
        VBox.setMargin(sbHistBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    private static void initSideBarHelpButton() {
    	sbHelpImage = new ImageView(PATH_HELP);
    	sbHelpBox = new VBox(sbHelpImage);

        setButtonDimensions(sbHelpBox);
        setButtonHandler(sbHelpBox, View.HELP);
        VBox.setMargin(sbHelpBox, new Insets(
        		0, MARGIN_COMPONENT, MARGIN_BUTTON, MARGIN_COMPONENT));
    }
    
    private static void initSideBarACIndicator() {
    	sbACImage = new ImageView(PATH_AC);
    	sbACBox = new VBox(sbACImage);
    	
    	sbACBox.setAlignment(Pos.CENTER);
        VBox.setMargin(sbACBox, new Insets(
        		0, 0, MARGIN_AC_INDICATOR, 0));
    }
    
    /**
     * This method sets the button dimensions to the constant defined 
     * for buttons
     * 
     * @param buttonBox
     * 		      The VBox containing the button
     */	
	private static void setButtonDimensions(VBox buttonBox) {
		buttonBox.setMaxWidth(WIDTH_DEFAULT_BUTTON);
		buttonBox.setMinWidth(WIDTH_DEFAULT_BUTTON);
		buttonBox.setMaxHeight(WIDTH_DEFAULT_BUTTON);
		buttonBox.setMinHeight(WIDTH_DEFAULT_BUTTON);
	}
	
	/**
	 * This method attaches EventHandlers to the buttons to be able to
	 * handle mouse clicks and hover events
	 * 
	 * @param buttonBox
	 * 		      The VBox containing the button
	 * @param view
	 * 		      The View of which to associate the button operation with
	 */
	private static void setButtonHandler(VBox buttonBox, View view) {
		buttonBox.addEventHandler(
        		MouseEvent.MOUSE_ENTERED, 
        		Handlers.getButtonHoverHandler(view));
		buttonBox.addEventHandler(
        		MouseEvent.MOUSE_EXITED, 
        		Handlers.getButtonHoverHandler(view));
		buttonBox.addEventHandler(
        		MouseEvent.MOUSE_PRESSED, 
        		Handlers.getButtonClickHandler(view));
	}
}
```
###### gui\LogicController.java
``` java
 */

package gui;

import java.awt.Desktop;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystemException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.regex.Pattern;

import backend.Logic;
import javafx.application.Platform;
import struct.Alias;
import struct.Command;
import struct.View;

public class LogicController {
	

	protected static final int INDEX_UNRES = 4;
	
	protected static final char NEWLINE_CHAR = '\n';
	protected static final char SEMICOLON = ';';
	protected static final String NEWLINE = "\n";
	protected static final String NULL_STRING = "";
	
	protected static final String PATH_CONFIG_FILE = "config" + File.separator + "config.txt";
	private static final String MESSAGE_OPEN_CONFIG = "Opening config...";
	private static final String MESSAGE_OPEN_FILE = "Opening file...";
	
	// Class instances within one LogicController instance
	private static Listeners.AutoCompleteListener autocompleter;
	private static Logic logic;
	private static CommandHistory commandHistory;
	
	private static boolean mapIndexOutOfBounds = false;
	
    // ======================================================================
    // LogicController constructor
    // ======================================================================
	
	/**
	 * This method is the constructor for a LogicController object.
	 * Possibly catches a FileSystemException from Storage caught by Logic and
	 * passed on to UI.
	 */
	public LogicController() {
		try {
			logic = new Logic();
		} catch (FileSystemException e) {
			logic = null;
			MainApp.logger.log(Level.SEVERE, MainApp.LOG_FILE_NOT_CREATED);
		}
		
		// Initialize the command history object
		commandHistory = new CommandHistory();
		// Initialize the listener for autocomplete
		autocompleter = Listeners.getAutoCompleteListener();
	}
	
	/**
	 * Getter for the CommandHistory object to work with Handlers class
	 * @return the CommandHistory object
	 */
	public static CommandHistory getHistory() {
		return commandHistory;
	}
	
	/**
	 * Getter for the Logic object to work with the Handlers class
	 * @return the Logic object
	 */
	public static Logic getLogic() {
		return logic;
	}
	
    // ======================================================================
    // Public methods called by other GUI classes that require some
	// processing of data or Logic methods
    // ======================================================================
	
	/**
	 * This method returns the current filepath of the text file being written
	 * to by the application
	 * 
	 * @return A String containing the filepath of whattodo.txt, or an error
	 * 		   message if the file cannot be found/written
	 */
	public String getFilePath() {
		if (logic != null) {
			return logic.getFilepath();
		} else {
			return InterfaceController.MESSAGE_ERROR_FILESYSTEM;
		}
	}
	
	/**
	 * This method returns default tasks filtered by Logic in a String[]
	 * for easier formatting by DefaultViewController
	 * 
	 * @return A String[] of default task data from the text file
	 */
	public String[] getDefTasks() {
		// Get the string from logic
		String defTasks = logic.taskDefaultView();
		// Split the string by newline
		String[] defTasksSplit = defTasks.split(NEWLINE);
		
		return defTasksSplit;
	}
	
	/**
	 * This method returns default events filtered by Logic in a String[]
	 * for easier formatting by DefaultViewController
	 * 
	 * @return A String[] of default event data from the text file
	 */
	public String[] getDefEvents() {
		// Get the string from logic
		String defEvents = logic.eventDefaultView();
		// Split the string by newline
		String[] defEventsSplit = defEvents.split(NEWLINE);
		
		// Filter through the array and reformat the data
		for (int i = 0; i < defEventsSplit.length; i++) {
			defEventsSplit[i] = defEventsSplit[i].replace(SEMICOLON, NEWLINE_CHAR);
		}
		
		return defEventsSplit;
	}
	
	/**
	 * This method returns all uncompleted tasks filtered by Logic in a 
	 * String[] for easier formatting by AllViewController
	 * 
	 * @return A String[] of all uncompleted task data from the text file
	 */
	public String[] getAllTasks() {
		// Get the String from logic
		String allTasks = logic.taskAllView(false);
		// Split the string by newline
		String[] allTasksSplit = allTasks.split(NEWLINE);
		
		return allTasksSplit;
	}
	
	/**
	 * This method returns all uncompleted events filtered by Logic in a 
	 * String[] for easier formatting by AllViewController
	 * 
	 * @return A String[] of all uncompleted event data from the text file
	 */
	public String[] getAllEvents() {
		// Get the String from logic
		String allEvents = logic.eventAllView(false);
		// Split the string by newline
		String[] allEventsSplit = allEvents.split(NEWLINE);
		
		// Filter through the array and reformat the data
		for (int i = 0; i < allEventsSplit.length; i++) {
			allEventsSplit[i] = allEventsSplit[i].replace(SEMICOLON, NEWLINE_CHAR);
		}
		
		return allEventsSplit;
	}
	
	/**
	 * This method returns all unresolved tasks filtered by Logic in a 
	 * String[] for easier formatting by UnresolvedViewController
	 * 
	 * @return A String[] of all unresolved task data from the text file
	 */
	public String[] getUnresTasks() {
		// Get the String from logic
		String unresTasks = logic.taskPastUncompletedView();
		// Split the string by newline
		String[] unresTasksSplit = unresTasks.split(NEWLINE);
		
		return unresTasksSplit;
	}
	
	/**
	 * This method returns all unresolved events filtered by Logic in a 
	 * String[] for easier formatting by UnresolvedViewController
	 * 
	 * @return A String[] of all unresolved event data from the text file
	 */
	public String[] getUnresEvents() {
		// Get the String from logic
		String unresEvents = logic.eventPastUncompletedView();
		// Split the string by newline
		String[] unresEventsSplit = unresEvents.split(NEWLINE);
		
		// Filter through the array and reformat the data
		for (int i = 0; i < unresEventsSplit.length; i++) {
			unresEventsSplit[i] = unresEventsSplit[i].replace(SEMICOLON, NEWLINE_CHAR);
		}
		
		return unresEventsSplit;
	}
	
	/**
	 * This method returns all completed tasks filtered by Logic in a 
	 * String[] for easier formatting by DoneViewController
	 * 
	 * @return A String[] of all completed task data from the text file
	 */
	public String[] getDoneTasks() {
		// Get the String from logic
		String doneTasks = logic.taskAllView(true);
		// Split the string by newline
		String[] doneTasksSplit = doneTasks.split(NEWLINE);
		
		// Prefix a "done" to the returned data
		for (int i = 0; i < doneTasksSplit.length; i++) {
			if (isNonEmptyElement(doneTasksSplit[i])) {
				doneTasksSplit[i] = InterfaceController.STATUS_DONE + 
						" " + doneTasksSplit[i];
			}
		}
		
		return doneTasksSplit;
	}
	
	/**
	 * This method returns all completed events filtered by Logic in a 
	 * String[] for easier formatting by DoneViewController
	 * 
	 * @return A String[] of all completed event data from the text file
	 */
	public String[] getDoneEvents() {
		// Get the String from logic
		String doneEvents = logic.eventAllView(true);
		// Split the string by newline
		String[] doneEventsSplit = doneEvents.split(NEWLINE);
		
		// Filter through the array and reformat the data
		for (int i = 0; i < doneEventsSplit.length; i++) {
			if (isNonEmptyElement(doneEventsSplit[i])) {
				doneEventsSplit[i] = InterfaceController.STATUS_DONE + 
						" " + doneEventsSplit[i];
			}
			doneEventsSplit[i] = doneEventsSplit[i].replace(SEMICOLON, NEWLINE_CHAR);
		}
		
		return doneEventsSplit;
	}
    
	/**
	 * This method calculates all values required for the summary view and
	 * stores them in a size 5 array in order of display in summary view
	 * 
	 * @return An int[] of size 5, each index storing the number required for
	 * 		   each element of the summary view
	 */
	public int[] getSummaryCount() {
		
		String[] defTasks = InterfaceController.getLogic().getDefTasks();
		String[] defEvents = InterfaceController.getLogic().getDefEvents();
		int[] summary = {0, 0, 0, 0, 0};
		int currentIndex = 0;
		
		currentIndex = getTaskSummaryCount(defTasks, summary, currentIndex);
		currentIndex = getEventSummaryCount(defEvents, summary, currentIndex);
		// Count the unresolved tasks and events as well
		summary[INDEX_UNRES] = getUnresElementsCount();
		
		return summary;
	}
	
	/**
	 * This method counts the number of elements there are in the default view
	 * (exclusive of title/date/empty elements)
	 * 
	 * @return The number of elements in the default view
	 */
	public int getDefElementsCount() {
		int count = 0;
		
		String[] temp = InterfaceController.getLogic().getDefTasks();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		temp = InterfaceController.getLogic().getDefEvents();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		
		return count;
	}
	
	/**
	 * This method counts the number of elements there are in the all view
	 * (exclusive of title/date/empty elements)
	 * 
	 * @return The number of elements in the all view
	 */
	public int getAllElementsCount() {
		int count = 0;
		
		String[] temp = InterfaceController.getLogic().getAllTasks();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		temp = InterfaceController.getLogic().getAllEvents();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		
		return count;
	}
	
	/**
	 * This method counts the number of elements there are in the search view
	 * (exclusive of title/date/empty elements)
	 * 
	 * @return The number of elements in the search view
	 */
	public int getSearchElementsCount(ArrayList<String> taskResults, 
			ArrayList<String> eventResults) {
		
		int count = 0;
		
		for (int i = 0; i < taskResults.size(); i++) {
			if (isNonEmptyElement(taskResults.get(i))) {
				count++;
			}
		}
		for (int i = 0; i < eventResults.size(); i++) {
			if (isNonEmptyElement(eventResults.get(i))) {
				count++;
			}
		}
		
		return count;
	}
	
	/**
	 * This method counts the number of elements there are in the unresolved view
	 * (exclusive of title/date/empty elements)
	 * 
	 * @return The number of elements in the unresolved view
	 */
	public int getUnresElementsCount() {
		int count = 0;
		
		String[] temp = InterfaceController.getLogic().getUnresTasks();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		temp = InterfaceController.getLogic().getUnresEvents();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		
		return count;
	}
	
	/**
	 * This method counts the number of elements there are in the done view
	 * (exclusive of title/date/empty elements)
	 * 
	 * @return The number of elements in the done view
	 */
	public int getDoneElementsCount() {
		int count = 0;
		
		String[] temp = InterfaceController.getLogic().getDoneTasks();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		temp = InterfaceController.getLogic().getDoneEvents();
		for (int i = 0; i < temp.length; i++) {
			if (isNonEmptyElement(temp[i])) {
				count++;
			}
		}
		
		return count;
	}
	
	/**
```
###### gui\LogicController.java
``` java
	 */
	
    // ======================================================================
    // Boolean methods which are used in other GUI classes to check for 
	// certain conditions which the data must meet
    // ======================================================================
	
	/**
	 * This method checks if the data is a title, meaning it is a header for a
	 * section that is not a date ("FLOAT", "TODAY" etc)
	 * 
	 * @param displayData
	 * 		      The line of data read in as a String
	 * @return true if displayData matches either of the title keywords, false
	 * 		   otherwise
	 */
	protected boolean isTitle(String displayData) {
    	
    	String firstWord = displayData.split(" ")[0];
    	return firstWord.equals("FLOAT") || firstWord.equals("TODAY") || 
    			firstWord.equals("TOMORROW") || firstWord.equals("ONGOING");
    }
    
    /**
     * This method checks if the data is an empty message, output when there are
     * no results ("There are no results to display.")
     * 
     * @param displayData
     * 		      The line of data read in as a String
     * @return true if displayData matches the empty message response, false
     * 		   otherwise
     */
	protected boolean isEmpty(String displayData) {
		return displayData.equals(InterfaceController.MESSAGE_EMPTY);
	}
    
	/**
	 * This method checks if the data is either a title or a date, meaning it
	 * does not contain task/event data
	 * 
	 * @param displayData
	 *  		  The line of data read in as a String
	 * @return true if displayData matches either a title or a date, false
	 * 		   otherwise
	 */
	protected boolean isTitleOrDate(String displayData) {
    	// Use the definition that a date or title does not have a period in it
    	// whereas an element will definitely have a period after its index
    	return displayData.split(Pattern.quote(".")).length == 1 && 
    			!displayData.equals(InterfaceController.MESSAGE_EMPTY);
    }
    
    /**
     * This method checks if the data is a String which contains data, and
     * that the data is not an empty message
     * 
     * @param displayData
     * 		      The line of data read in as a String
     * @return true if displayData is not a title, date or empty element, false
     * 		   otherwise
     */
	protected boolean isNonEmptyElement(String displayData) {
    	return !isTitleOrDate(displayData) && 
				!displayData.equals(InterfaceController.MESSAGE_EMPTY);
    }
    
    /**
     * This method checks if a particular task/event has been marked as completed
     * 
     * @param displayData
     * 		      The line of data read in as a String
     * @return true if the data has been marked as done, false otherwise
     */
	protected boolean isCompleted(String displayData) {
		return displayData.split(" ")[0].equals("done");
	}
    
    // ======================================================================
    // Additional operations used to change certain program features
    // ======================================================================
    
    /**
     * This method toggles the activation status of the autocomplete feature by
     * adding/deleting the listener depending on the activation status
     */
    protected void toggleAutoComplete() {
    	if (!AutoComplete.isActivated()) {
    		InterfaceController.getTextField().textProperty().addListener(autocompleter);
    		AutoComplete.setActivation(true);
    	} else {
    		InterfaceController.getTextField().textProperty().removeListener(autocompleter);
    		AutoComplete.closePopup();
    		AutoComplete.setActivation(false);
    	}
    }
	
    /**
```
###### gui\LogicController.java
``` java
     */
    // ======================================================================
    // Private methods for running commands and switching views accessible 
    // only within LogicController
    // ======================================================================
    
    /**
     * This method takes in an input target View to switch to, and then either
     * 1. Swaps to it if currentView != target view
     * 2. Do nothing if currentView == target view
     * 
     * @param view
     * 		      The target View to switch to
     */
	protected void changeView(View view) {
		
		switch(InterfaceController.getCurrentView()) {
		    // currentView == DEFAULT
	        case DEFAULT:
	        	switch (view) {
		        	case ALL:
		        		InterfaceController.updateMainInterface(View.ALL);
		        		break;
		        	case HISTORY:
		        		InterfaceController.updateMainInterface(View.HISTORY);
		        		break;
		        	case UNRESOLVED:
		        		InterfaceController.updateMainInterface(View.UNRESOLVED);
		        		break;
		        	case DONE:
		        		InterfaceController.updateMainInterface(View.DONE);
		        		break;
		        	case SEARCH:
		        		InterfaceController.updateMainInterface(View.SEARCH);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		            	break;
		        }
	        	break;
	    	// currentView == ALL
	        case ALL:
	        	switch (view) {
		        	case DEFAULT:
		        		InterfaceController.updateMainInterface(View.DEFAULT);
		        		break;
		        	case HISTORY:
		        		InterfaceController.updateMainInterface(View.HISTORY);
		        		break;
		        	case UNRESOLVED:
		        		InterfaceController.updateMainInterface(View.UNRESOLVED);
		        		break;
		        	case DONE:
		        		InterfaceController.updateMainInterface(View.DONE);
		        		break;
		        	case SEARCH:
		        		InterfaceController.updateMainInterface(View.SEARCH);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		        		break;
	        	}
	        	break;
	    	// currentView == HISTORY
	        case HISTORY:
	        	switch (view) {
		        	case DEFAULT:
		        		InterfaceController.updateMainInterface(View.DEFAULT);
		        		break;
		        	case ALL:
		        		InterfaceController.updateMainInterface(View.ALL);
		        		break;
		        	case UNRESOLVED:
		        		InterfaceController.updateMainInterface(View.UNRESOLVED);
		        		break;
		        	case DONE:
		        		InterfaceController.updateMainInterface(View.DONE);
		        		break;
		        	case SEARCH:
		        		InterfaceController.updateMainInterface(View.SEARCH);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		        		break;
	        	}
	        	break;
	    	// currentView == UNRESOLVED
	        case UNRESOLVED:
	        	switch (view) {
		        	case DEFAULT:
		        		InterfaceController.updateMainInterface(View.DEFAULT);
		        		break;
		        	case ALL:
		        		InterfaceController.updateMainInterface(View.ALL);
		        		break;
		        	case HISTORY:
		        		InterfaceController.updateMainInterface(View.HISTORY);
		        		break;
		        	case DONE:
		        		InterfaceController.updateMainInterface(View.DONE);
		        		break;
		        	case SEARCH:
		        		InterfaceController.updateMainInterface(View.SEARCH);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		        		break;
	        	}
	        	break;
	    	// currentView == DONE
	        case DONE:
	        	switch (view) {
		        	case DEFAULT:
		        		InterfaceController.updateMainInterface(View.DEFAULT);
		        		break;
		        	case ALL:
		        		InterfaceController.updateMainInterface(View.ALL);
		        		break;
		        	case HISTORY:
		        		InterfaceController.updateMainInterface(View.HISTORY);
		        		break;
		        	case UNRESOLVED:
		        		InterfaceController.updateMainInterface(View.UNRESOLVED);
		        		break;
		        	case SEARCH:
		        		InterfaceController.updateMainInterface(View.SEARCH);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		        		break;
	        	}
	        	break;
	    	// currentView == SEARCH
	        case SEARCH:
	        	switch (view) {
		        	case DEFAULT:
		        		InterfaceController.updateMainInterface(View.DEFAULT);
		        		break;
		        	case ALL:
		        		InterfaceController.updateMainInterface(View.ALL);
		        		break;
		        	case HISTORY:
		        		InterfaceController.updateMainInterface(View.HISTORY);
		        		break;
		        	case UNRESOLVED:
		        		InterfaceController.updateMainInterface(View.UNRESOLVED);
		        		break;
		        	case DONE:
		        		InterfaceController.updateMainInterface(View.DONE);
		        		break;
		        	case HELP:
		        		HelpController.toggleHelpDialog();
		        		break;
		        	case SUMMARY:
		        		InterfaceController.updateMainInterface(View.SUMMARY);
		        		break;
		        	case EXIT:
		        		InterfaceController.closeMainInterface();
		        		break;
		        	default:
		        		// Do nothing if already in this view
		        		break;
	        	}
	        	break;
	
	        default: // do nothing, should not enter
	        	break;
        }
	}
	
	/**
	 * This method runs the user entered command by calling Logic's executeCommand()
	 * method and getting the return message
	 * 
	 * @param operationType
	 * 		      The type of operation being entered by the user (ADD, EDIT, DELETE..)
	 * @param textFieldInput
	 * 		      The input String entered by the user into the text field
	 * @param isBackgroundUpdate
	 * 		      A boolean flag indicating whether the current operation is a background
	 * 			  update being run by a SEARCH command
	 */
	protected void runCommand(Command.CommandType operationType, 
			String textFieldInput, boolean isBackgroundUpdate) {
		// Execute the command
		String returnMessage = logic.executeCommand(textFieldInput);
		if (operationType == Command.CommandType.SEARCH) {
			// Do not update the feedback bar and history view if the search operation
			// is a background update of the last search term
			if (!isBackgroundUpdate) {
				String searchTerm = returnMessage.split(NEWLINE)[0];
				// Add the search terms to the feedback bar and history view
				InterfaceController.getFeedbackLabel().setText(searchTerm);
				HistoryViewController.updateHistView(searchTerm);
			}
			SearchViewController.updateSearchView(returnMessage);
		} else {
			// Modify the return message first if it is incorrect and is an operation
			// that uses indices (delete, done, edit)
			if (mapIndexOutOfBounds && 
					(operationType == Command.CommandType.DELETE || 
					operationType == Command.CommandType.DONE || 
					operationType == Command.CommandType.EDIT)) {
				returnMessage = InterfaceController.MESSAGE_INVALID_INDEX;
			}
			// Add the returnMessage to the feedback bar and history view
			InterfaceController.getFeedbackLabel().setText(returnMessage);
			HistoryViewController.updateHistView(returnMessage);
		}

		// Update the necessary views
		DefaultViewController.updateDefView();
		AllViewController.updateAllView();
		UnresolvedViewController.updateUnresView();
		DoneViewController.updateDoneView();
		InterfaceController.updateFilePathBar();
		SummaryViewController.updateSummaryView();
	}
	
	// runCommand(), edited for JUnit testing
	public void runCommandTest(String textFieldInput) {
		// Execute the command
		logic.executeCommand(textFieldInput);
	}
	
	/**
	 * This method modifies the String input by a user by extracting the view 
	 * index of delete, done and edit operations, mapping it to the file index, 
	 * and then replacing it before passing it to the Logic component
	 * 
	 * @param textFieldInput
	 * 		      The input String that was entered by the user into the text 
	 * 			  field
	 * @return A String with the view index entered by the user replaced by the
	 * 		   file index
	 */
	protected String mapToFileIndex(String textFieldInput) {
    	
    	String[] textFieldInputSplit = textFieldInput.split("[\\s;]+");
    	String modifiedString = textFieldInput;
    	try {
    		int viewIndex = Integer.parseInt(textFieldInputSplit[1]);
        	int fileIndex = ViewIndexMap.get(viewIndex);
        	
        	// Check if the index has exceeded the allowable size of the array
        	// -1 should be returned by ViewIndexMap.get()
        	mapIndexOutOfBounds = fileIndex == -1 && viewIndex != -1;
        	
        	// Proceed with normal operation
        	// Negative and zero indices are handled by CommandParser
        	textFieldInputSplit[1] = String.valueOf(fileIndex);
        	modifiedString = NULL_STRING;
        	for (int i = 0; i < textFieldInputSplit.length; i++) {
        		modifiedString += textFieldInputSplit[i] + " ";
        	}
        	// Remove the extra space appended by the for loop
        	modifiedString = modifiedString.substring(0, modifiedString.length() - 1);
    	} catch (NumberFormatException e) {
    		// User did not enter an integer and hence exception is thrown
    		// Do not modify the string and pass through to CommandParser to reject
    		mapIndexOutOfBounds = true;
    		MainApp.logger.log(Level.WARNING, MainApp.LOG_INVALID_INDEX);
    	}
    	
    	return modifiedString;
    }
    
	/**
	 * This method sets the caret position to the end of the line of text
	 * 
	 * @param text
	 * 		      The line of text to set the caret position of
	 */
	protected void setCaretToEnd(String text) {
		// Required for positionCaret to work correctly
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				InterfaceController.getTextField().positionCaret(text.length());
			}
		});
	}
	
    // ======================================================================
    // Misc private methods used for calculations and other methods
    // ======================================================================
    
	/**
	 * This method calculates
	 * 1. The number of events due within the next two days
	 * 2. The number of events that are currently ongoing
	 * and then updates the array summary with the data
	 * 
	 * @param defEvents
	 * 		      A String[] of all the event data from the default view
	 * @param summary
	 * 		      The int[] that stores all the counts for the summary view
	 * @param currentIndex
	 * 		 	  The index of the summary array that is to be modified
	 * @return The index of in the summary array where the method ended 
	 * 		   operation at
	 */
	private int getEventSummaryCount(String[] defEvents, int[] summary, int currentIndex) {
		// Count for events and update the count array
		for (int i = 0; i < defEvents.length; i++) {
			String temp = defEvents[i];
			if (isTitle(temp)) {
				// Switch array index to increment the right counter
				temp = temp.split(" ")[0];
				switch(temp) {
					case "TODAY":
						currentIndex = 1;
						break;
					case "TOMORROW":
						currentIndex = 1;
						break;
					case "ONGOING":
						currentIndex = 3;
						break;
					default:
						break;
				}
			} else {
				// Increment the counter in the currentIndex
				if (temp.split(Pattern.quote(".")).length > 1) {
					summary[currentIndex]++;
				}
			}
		}
		
		return currentIndex;
	}

	/**
	 * This method calculates
	 * 1. The number of tasks due within the next two days
	 * 2. The number of tasks that are without a deadline (floating)
	 * and then updates the array summary with the data
	 * 
	 * @param defEvents
	 * 		      A String[] of all the task data from the default view
	 * @param summary
	 * 		      The int[] that stores all the counts for the summary view
	 * @param currentIndex
	 * 		 	  The index of the summary array that is to be modified
	 * @return The index of in the summary array where the method ended 
	 * 		   operation at
	 */
	private int getTaskSummaryCount(String[] defTasks, int[] summary, int currentIndex) {
		// First count for tasks and update the count array
		for (int i = 0; i < defTasks.length; i++) {
			String temp = defTasks[i];
			if (isTitle(temp)) {
				// Switch array index to increment the right counter
				temp = temp.split(" ")[0];
				switch(temp) {
					case "TODAY":
						currentIndex = 0;
						break;
					case "TOMORROW":
						currentIndex = 0;
						break;
					case "FLOAT":
						currentIndex = 2;
						break;
					default:
						break;
				}
			} else {
				// Increment the counter in the currentIndex
				if (temp.split(Pattern.quote(".")).length > 1) {
					summary[currentIndex]++;
				}
			}
		}
		
		return currentIndex;
	}
}
```
###### gui\MainApp.java
``` java
 */

package gui;

import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.application.Application;
import javafx.scene.image.Image;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import struct.View;
import javafx.scene.*;

public class MainApp extends Application {

	// ============================================================
	// Variables used in stage configuration
	// ============================================================
	
	protected static final double MIN_WINDOW_HEIGHT = 700;
    protected static final double MIN_WINDOW_WIDTH = 1000;
    
    protected static final double WIDTH_HELP_DIALOG = 800;
    protected static final double HEIGHT_HELP_DIALOG = 800;
    
    private static final String TITLE_STAGE = "WhatToDo";
    private static final String TITLE_HELP = "Help Dialog";
    
    protected static final String LOG_START = "Starting WhatToDo";
    protected static final String LOG_CLOSE = "Closing WhatToDo";
    protected static final String LOG_HELP_OPEN = "Opening Help dialog";
    protected static final String LOG_HELP_CLOSE = "Closing Help dialog";
    protected static final String LOG_INVALID_INDEX = "Invalid index has been entered";
    protected static final String LOG_FILE_NOT_FOUND = "Unable to open whattodo.txt";
    protected static final String LOG_CONFIG_NOT_FOUND = "Unable to open config.txt";
    protected static final String LOG_ALIAS_NOT_FOUND = "Unable to open alias.txt";
    protected static final String LOG_FILE_NOT_CREATED = "Unable to create the file";
    
    private static final String PATH_ICON = "gui/resources/icon.png";

	// ============================================================
	// Scenes and stages used by the application
	// ============================================================
    
    protected static Scene scene, helpScene;
    protected static Stage stage, help;

	// ============================================================
	// Logger object used to log events and details
	// ============================================================
    
    protected static final Logger logger = Logger.getLogger(MainApp.class.getName()); 
    
	/**
	 * This method is the driver method which starts the application and
	 * displays the interface
	 */
    @Override
    public void start(Stage primaryStage) {
        stage = primaryStage;

        InterfaceController.initMainInterface();
        HelpController.initHelpScene();

        initPrimaryStage();
        initHelpStage();

        stage.show();
        logger.log(Level.INFO, LOG_START);
        
        // Set the first view to be the default view
        InterfaceController.updateMainInterface(View.DEFAULT);
    }

    public static void main(String[] args) {
        launch(args);
    }

    /**
     * Initializes the default Scene, window title, window icon, default window
     * dimensions, and the minimum and maximum window sizes
     */
    public static void initPrimaryStage() {
        stage.setScene(scene);

        // Customize the stage
        stage.setTitle(TITLE_STAGE);
        stage.getIcons().add(new Image(PATH_ICON));

        stage.setWidth(MIN_WINDOW_WIDTH);
        stage.setHeight(MIN_WINDOW_HEIGHT);
        stage.setMinHeight(MIN_WINDOW_HEIGHT);
        stage.setMinWidth(MIN_WINDOW_WIDTH);
        
        // Event handling for the summary view
        stage.addEventFilter(KeyEvent.KEY_PRESSED, 
        		Handlers.getTabPressHandler());
        
        // Event handling for hotkeys
        stage.addEventFilter(KeyEvent.KEY_PRESSED, 
        		Handlers.getHotKeyHandler());
        
        // Focus handling for the autocomplete popup
        stage.focusedProperty().addListener(
        		Listeners.getLostFocusListener());
        
        // Reposition listeners for the autocomplete popup
        stage.xProperty().addListener(
        		Listeners.getWidthPositionListener());
        stage.yProperty().addListener(
        		Listeners.getHeightPositionListener());
    }
    
    // Initializes the help Scene, window title, default window dimensions
    public static void initHelpStage() {
    	
    	help = new Stage();
    	help.setScene(helpScene);
    	
    	help.setTitle(TITLE_HELP);
        help.setWidth(WIDTH_HELP_DIALOG);
        help.setHeight(HEIGHT_HELP_DIALOG);
        help.setResizable(false);
        
        // Change listener for when window is closed by user click
        // Performs a strict window close instead of window toggle which loops infinitely
        help.showingProperty().addListener(
        		Listeners.getCloseHelpListener());
        
        // Event handling for hotkeys
        help.addEventFilter(KeyEvent.KEY_PRESSED, 
        		Handlers.getHelpHotKeyHandler());
    }
}
```
###### gui\SearchViewController.java
``` java
 */

package gui;

import java.util.ArrayList;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Line;
import struct.View;

public class SearchViewController {

	// ================================================================================
    // JavaFX controls used in the search interface
    // ================================================================================

	// Used for initSearchTaskView
	private static VBox searchTaskBox, searchTaskContentBox;
	private static HBox searchTaskHeaderBox;
	private static ScrollPane searchTaskScroll;

	// Used for initSearchEventView
	private static VBox searchEventBox, searchEventContentBox;
	private static HBox searchEventHeaderBox;
	private static ScrollPane searchEventScroll;

	// Used for initSearchView
	private static Line searchScrollLine;

	private static final String HEADER_SEARCH_TASKS = "TASKS";
	private static final String HEADER_SEARCH_EVENTS = "EVENTS";

    /**
     * This method initializes all the interface components for the search view,
     * primarily the task window and the event window
     */
	public static void initSearchView() {
		ArrayList<String> initialArray = new ArrayList<String>();
		initSearchTaskView(initialArray, 0);
		initSearchEventView(initialArray, 0);

		searchScrollLine = new Line(0, 0, 0, InterfaceController.WIDTH_DEFAULT_BUTTON);
		HBox searchBoxNoHeader = new HBox(searchTaskBox, searchScrollLine, searchEventBox);
		InterfaceController.searchBox = new VBox(searchBoxNoHeader);
		
		searchTaskScroll.prefViewportWidthProperty().bind(
        		InterfaceController.searchBox.widthProperty().divide(2));
        searchEventScroll.prefViewportWidthProperty().bind(
        		InterfaceController.searchBox.widthProperty().divide(2));
        
        searchTaskScroll.maxWidthProperty().bind(
        		InterfaceController.searchBox.widthProperty().divide(2));
        searchEventScroll.maxWidthProperty().bind(
        		InterfaceController.searchBox.widthProperty().divide(2));
        
        searchScrollLine.endYProperty().bind(
        		DefaultViewController.getDefScrollLine().endYProperty());
        
        // CSS
        searchScrollLine.getStyleClass().add("line");
	}

    /**
     * This method updates the all view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 
     * @param results
     * 			  The search results as a String returned from Logic's
     * 			  executeCommand()
     */
	public static void updateSearchView(String results) {
		ArrayList<String> taskResults = getTaskResults(results);
		ArrayList<String> eventResults = getEventResults(results);

		searchTaskContentBox.getChildren().clear();
		searchEventContentBox.getChildren().clear();
		ViewIndexMap.resetSearchMap();
		
		int numOfElements = InterfaceController.getLogic().getSearchElementsCount(
				taskResults, eventResults);
		int numOfResults = 1;
		
		numOfResults = updateSearchTasks(taskResults, numOfElements, numOfResults);
		numOfResults = updateSearchEvents(eventResults, numOfElements, numOfResults);
	}
	
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
	
	/**
	 * This method formats the results of a search into only task results
	 * 
	 * @param displayData
	 * 		      The search results passed back from Logic's executeCommand
	 * 			  as a String in the return message 
	 * @return An ArrayList of Strings which contain the task results for 
	 * 		   the search
	 */
	private static ArrayList<String> getTaskResults(String displayData) {
		String[] resultsSplit = displayData.split("\n");
		ArrayList<String> taskResults = new ArrayList<String>();
		boolean startRead = false;

		for (int i = 0; i < resultsSplit.length; i++) {
			if (resultsSplit[i].equals("TASK")) {
				startRead = true;
			} else if (resultsSplit[i].equals("EVENT")) {
				startRead = false;
				break;
			} else {
				if (startRead) {
					taskResults.add(resultsSplit[i]);
				}
			}
		}
		return taskResults;
	}

	/**
	 * This method formats the results of a search into only event results
	 * 
	 * @param displayData
	 * 		      The search results passed back from Logic's executeCommand
	 * 			  as a String in the return message 
	 * @return An ArrayList of Strings which contain the event results for 
	 * 		   the search
	 */
	private static ArrayList<String> getEventResults(String displayData) {
		String[] resultsSplit = displayData.split("\n");
		ArrayList<String> eventResults = new ArrayList<String>();
		boolean startRead = false;

		for (int i = 0; i < resultsSplit.length; i++) {
			if (resultsSplit[i].equals("EVENT")) {
				startRead = true;
			} else {
				if (startRead) {
					// Filter through the array and reformat the data
					for (int j = 0; j < resultsSplit.length; j++) {
						resultsSplit[i] = resultsSplit[i].replace(';', '\n');
					}
					eventResults.add(resultsSplit[i]);
				}
			}
		}
		return eventResults;
	}
	
	/**
	 * This method initializes the task view for the search view
	 * 
	 * @param taskResults
	 * 			  A String[] of tasks returned from getTaskResults()
	 * @param numOfElements
	 * 			  The number of elements in taskResults
	 */
	private static void initSearchTaskView(ArrayList<String> taskResults, int numOfElements) {
		Label searchTaskHeaderLabel = new Label(HEADER_SEARCH_TASKS);
		searchTaskHeaderBox = new HBox(searchTaskHeaderLabel);
		searchTaskContentBox = new VBox();

		initSearchTasks(taskResults, numOfElements);
		searchTaskScroll = new ScrollPane(searchTaskContentBox);
		searchTaskBox = new VBox(searchTaskHeaderBox, searchTaskScroll);
		
		// Component formatting
		searchTaskHeaderBox.setAlignment(Pos.CENTER);
		searchTaskScroll.setFitToWidth(true);
        VBox.setVgrow(searchTaskScroll, Priority.ALWAYS);
        searchTaskBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(searchTaskHeaderLabel, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(searchTaskHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(searchTaskScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));

		searchTaskScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		searchTaskScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        searchTaskHeaderLabel.getStyleClass().add("box-title-label");
        searchTaskHeaderBox.getStyleClass().add("box-title-all-task");
	}

	/**
	 * This method initializes the event view for the search view
	 * 
	 * @param eventResults
	 * 			  A String[] of tasks returned from getEventResults()
	 * @param numOfElements
	 * 			  The number of elements in eventResults
	 */
	private static void initSearchEventView(ArrayList<String> eventResults, int numOfElements) {
		Label searchEventHeaderLabel = new Label(HEADER_SEARCH_EVENTS);
		searchEventHeaderBox = new HBox(searchEventHeaderLabel);
		searchEventContentBox = new VBox();

		initSearchEvents(eventResults, numOfElements);
		searchEventScroll = new ScrollPane(searchEventContentBox);
		searchEventBox = new VBox(searchEventHeaderBox, searchEventScroll);
		
		// Component formatting
		searchEventHeaderBox.setAlignment(Pos.CENTER);
		searchEventScroll.setFitToWidth(true);
        VBox.setVgrow(searchEventScroll, Priority.ALWAYS);
        searchEventBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(searchEventHeaderLabel, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(searchEventHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(searchEventScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));

		searchEventScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		searchEventScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);

        // CSS
        searchEventHeaderLabel.getStyleClass().add("box-title-label");
        searchEventHeaderBox.getStyleClass().add("box-title-all-event");
	}

	/**
	 * This method initializes the task content of the search view with data
	 * 
	 * @param taskResults
	 * 			  The ArrayList of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 */
	private static void initSearchTasks(ArrayList<String> taskResults, int numOfElements) {
		for (int i = 0; i < taskResults.size(); i++) {
			HBox tempBox = InterfaceController.initDisplayElement(
					taskResults.get(i), numOfElements, i + 1, true, View.SEARCH);
			VBox.setMargin(tempBox, new Insets(
					0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
			searchTaskContentBox.getChildren().add(tempBox);
		}
	}
	
	/**
	 * This method initializes the event content of the search view with data
	 * 
	 * @param eventResults
	 * 			  The ArrayList of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 */
	private static void initSearchEvents(ArrayList<String> eventResults, int numOfElements) {
		for (int i = 0; i < eventResults.size(); i++) {
			HBox tempBox = InterfaceController.initDisplayElement(
					eventResults.get(i), numOfElements, i + 1, false, View.SEARCH);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
			searchEventContentBox.getChildren().add(tempBox);
		}
	}
	
	/**
	 * This method updates the various task content of the search view with the
     * updated data
     * 
	 * @param taskResults
	 * 			  The updated ArrayList of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @param index
	 * 			  The view index of the particular task/event
	 * @return The index of the last element to be added
	 */
	private static int updateSearchTasks(ArrayList<String> taskResults, int numOfElements, int index) {
		// Only print the empty message if there are zero results
		if (taskResults.size() == 3 && InterfaceController.getLogic().isEmpty(taskResults.get(2))) {
			HBox tempBox = InterfaceController.initDisplayElement(
					taskResults.get(2), numOfElements, index, true, View.SEARCH);
			VBox.setMargin(tempBox, new Insets(
					0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
			searchTaskContentBox.getChildren().add(tempBox);
		} else {
			// If there are no results for floating tasks
			if (InterfaceController.getLogic().isEmpty(taskResults.get(taskResults.size() - 1))) {
				for (int i = 0; i < taskResults.size(); i++) {
					HBox tempBox = InterfaceController.initDisplayElement(
							taskResults.get(i), numOfElements, index, true, View.SEARCH);
					VBox.setMargin(tempBox, new Insets(
							0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
					searchTaskContentBox.getChildren().add(tempBox);
					// Only increment the counter if an element is added
					if (InterfaceController.getLogic().isNonEmptyElement(taskResults.get(i))) {
						index++;
					}
				}
			} else {
				for (int i = 0; i < taskResults.size(); i++) {
					if (!InterfaceController.getLogic().isEmpty(taskResults.get(i))) {
						HBox tempBox = InterfaceController.initDisplayElement(
								taskResults.get(i), numOfElements, index, true, View.SEARCH);
						VBox.setMargin(tempBox, new Insets(
								0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
						searchTaskContentBox.getChildren().add(tempBox);
						// Only increment the counter if an element is added
						if (InterfaceController.getLogic().isNonEmptyElement(taskResults.get(i))) {
							index++;
						}
					}
				}
			}
		}
		return index;
	}

	/**
	 * This method updates the various event content of the search view with the
     * updated data
     * 
	 * @param eventResults
	 * 			  The updated ArrayList of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @param index
	 * 			  The view index of the particular task/event
	 * @return The index of the last element to be added
	 */
	private static int updateSearchEvents(ArrayList<String> eventResults, int numOfElements, int numOfResults) {
		// Print the event results
		for (int i = 0; i < eventResults.size(); i++) {
			HBox tempBox = InterfaceController.initDisplayElement(
					eventResults.get(i), numOfElements, numOfResults, false, View.SEARCH);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
        	searchEventContentBox.getChildren().add(tempBox);
			if (InterfaceController.getLogic().isNonEmptyElement(eventResults.get(i))) {
				numOfResults++;
			}
		}
		return numOfResults;
	}
}
```
###### gui\SummaryViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;

public class SummaryViewController {
	
	// Used for initTaskTwoDays
	private static Label taskTwoDaysCount, taskTwoDaysLabel;
	private static HBox taskTwoDaysCountBox, taskTwoDaysLabelBox, taskTwoDaysBox;
	
	// Used for initEventTwoDays
	private static Label eventTwoDaysCount, eventTwoDaysLabel;
	private static HBox eventTwoDaysCountBox, eventTwoDaysLabelBox, eventTwoDaysBox;
	
	// Used for initTaskFloat
	private static Label taskFloatCount, taskFloatLabel;
	private static HBox taskFloatCountBox, taskFloatLabelBox, taskFloatBox;
	
	// Used for initEventOngoing
	private static Label eventOngoingCount, eventOngoingLabel;
	private static HBox eventOngoingCountBox, eventOngoingLabelBox, eventOngoingBox;
	
	// Used for initAllUnres
	private static Label allUnresCount, allUnresLabel, allUnresAttention, allUnresClear;
	private static ImageView allUnresIcon;
	private static HBox allUnresCountBox, allUnresLabelBox, allUnresNotifyBox,
	allUnresIconBox, allUnresBox;
	
	// Used for initSummaryView
	private static VBox summaryBox;
	
	private static final String PATH_UNRES_TICK = "gui/resources/unres_tick.png";
	private static final String PATH_UNRES_ALERT = "gui/resources/unres_alert.png";
	
	private static final String HEADER_TASK_TWO_DAYS = "Tasks due within two days";
	private static final String HEADER_EVENT_TWO_DAYS = "Events starting within two days";
	private static final String HEADER_TASK_FLOAT = "Tasks with no deadline";
	private static final String HEADER_EVENT_ONGOING = "Ongoing events";
	private static final String HEADER_ALL_UNRES = "Unresolved tasks/events past deadline";
	private static final String HEADER_ALL_UNRES_ATTENTION = "Some items require attention";
	private static final String HEADER_ALL_UNRES_CLEAR = "All items clear";
	
	private static final double MARGIN_SUMMARY_BOX = 80;
	private static final double MARGIN_SUMMARY_LABEL = 30;
	private static final double MARGIN_SUMMARY_COUNT_HORIZ = 20;
	private static final double MARGIN_SUMMARY_COUNT_VERT = 5;
	
	private static final int INDEX_TASK_TWO_DAYS = 0;
	private static final int INDEX_EVENT_TWO_DAYS = 1;
	private static final int INDEX_TASK_FLOAT = 2;
	private static final int INDEX_EVENT_ONGOING = 3;
	private static final int INDEX_UNRES = 4;
	private static final int ARRAY_LENGTH = 5;
	
	private static boolean isShowing = false;
	
    /**
     * This method initializes all the interface components for the default view,
     * primarily the five display bars
     */
	protected static void initSummaryView() {
		int[] summary = InterfaceController.getLogic().getSummaryCount();
		assert summary.length == ARRAY_LENGTH;
		double maxWidth = getCountMaxWidth(summary);
		
		initTaskTwoDays(summary[INDEX_TASK_TWO_DAYS], maxWidth);
		initEventTwoDays(summary[INDEX_EVENT_TWO_DAYS], maxWidth);
		initTaskFloat(summary[INDEX_TASK_FLOAT], maxWidth);
		initEventOngoing(summary[INDEX_EVENT_ONGOING], maxWidth);
		initAllUnres(summary[INDEX_UNRES], maxWidth);
		
		Region space1 = new Region();
		Region space2 = new Region();
		Region space3 = new Region();
		Region space4 = new Region();
		Region space5 = new Region();
		Region space6 = new Region();
		
		summaryBox = new VBox(space1, taskTwoDaysBox, 
				space2, eventTwoDaysBox, 
				space3, taskFloatBox, 
				space4, eventOngoingBox, 
				space5, allUnresBox, 
				space6);
		InterfaceController.summaryBox = summaryBox;
		
		// Component formatting
		formatSummaryBox();
		
		VBox.setVgrow(space1, Priority.ALWAYS);
		VBox.setVgrow(space2, Priority.ALWAYS);
		VBox.setVgrow(space3, Priority.ALWAYS);
		VBox.setVgrow(space4, Priority.ALWAYS);
		VBox.setVgrow(space5, Priority.ALWAYS);
		VBox.setVgrow(space6, Priority.ALWAYS);
	}
	
    /**
     * This method updates the summary view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 	2. 	updateMainInterface() in InterfaceController to update the view when
     * 		a view change command is issued (button/hotkey/text command)
     */
	protected static void updateSummaryView() {
		int[] summary = InterfaceController.getLogic().getSummaryCount();
		assert summary.length == ARRAY_LENGTH;
		
		// Clear the old data
		taskTwoDaysCountBox.getChildren().clear();
		eventTwoDaysCountBox.getChildren().clear();
		taskFloatCountBox.getChildren().clear();
		eventOngoingCountBox.getChildren().clear();
		allUnresCountBox.getChildren().clear();
		
		taskTwoDaysCount = new Label(String.valueOf(summary[INDEX_TASK_TWO_DAYS]));
		eventTwoDaysCount = new Label(String.valueOf(summary[INDEX_EVENT_TWO_DAYS]));
		taskFloatCount = new Label(String.valueOf(summary[INDEX_TASK_FLOAT]));
		eventOngoingCount = new Label(String.valueOf(summary[INDEX_EVENT_ONGOING]));
		allUnresCount = new Label(String.valueOf(summary[INDEX_UNRES]));
		
		// Update the icon depending on the new value of unresolved tasks
		initUnresIcon(summary[INDEX_UNRES]);
		allUnresIconBox.getChildren().clear();
		allUnresIconBox.getChildren().add(allUnresIcon);
		HBox.setMargin(allUnresIcon, new Insets(0, MARGIN_SUMMARY_COUNT_HORIZ, 0, 0));
		
		updateUnresNotifyBox(summary[INDEX_UNRES]);
		
		// Insert the new data
		taskTwoDaysCountBox.getChildren().add(taskTwoDaysCount);
		eventTwoDaysCountBox.getChildren().add(eventTwoDaysCount);
		taskFloatCountBox.getChildren().add(taskFloatCount);
		eventOngoingCountBox.getChildren().add(eventOngoingCount);
		allUnresCountBox.getChildren().add(allUnresCount);
		
		// Component formatting
		HBox.setMargin(taskTwoDaysCount, new Insets(
				MARGIN_SUMMARY_COUNT_VERT, 0, MARGIN_SUMMARY_COUNT_VERT, 0));
		HBox.setMargin(eventTwoDaysCount, new Insets(
				MARGIN_SUMMARY_COUNT_VERT, 0, MARGIN_SUMMARY_COUNT_VERT, 0));
		HBox.setMargin(taskFloatCount, new Insets(
				MARGIN_SUMMARY_COUNT_VERT, 0, MARGIN_SUMMARY_COUNT_VERT, 0));
		HBox.setMargin(eventOngoingCount, new Insets(
				MARGIN_SUMMARY_COUNT_VERT, 0, MARGIN_SUMMARY_COUNT_VERT, 0));
		HBox.setMargin(allUnresCount, new Insets(
				MARGIN_SUMMARY_COUNT_VERT, 0, MARGIN_SUMMARY_COUNT_VERT, 0));
		
		// CSS
		taskTwoDaysCount.getStyleClass().add("summary-box-count");
		eventTwoDaysCount.getStyleClass().add("summary-box-count");
		taskFloatCount.getStyleClass().add("summary-box-count");
		eventOngoingCount.getStyleClass().add("summary-box-count");
		allUnresCount.getStyleClass().add("summary-box-count");
	}
	
	// ========================================
	// Getters and setters for isShowing
	// ========================================
	
	protected static boolean isShowing() {
		return isShowing;
	}
	
	protected static void startShowing() {
		isShowing = true;
	}
	
	protected static void stopShowing() {
		isShowing = false;
	}
	
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
	
	private static void initTaskTwoDays(int count, double maxWidth) {
		taskTwoDaysCount = new Label(String.valueOf(count));
		taskTwoDaysLabel = new Label(HEADER_TASK_TWO_DAYS);
		
		taskTwoDaysCountBox = new HBox(taskTwoDaysCount);
		taskTwoDaysLabelBox = new HBox(taskTwoDaysLabel);
		taskTwoDaysCountBox.setAlignment(Pos.CENTER);
		taskTwoDaysLabelBox.setAlignment(Pos.CENTER_LEFT);
		
		taskTwoDaysCountBox.setMinWidth(maxWidth);
		HBox.setMargin(taskTwoDaysLabel, new Insets(0, 0, 0, MARGIN_SUMMARY_LABEL));
		HBox.setHgrow(taskTwoDaysLabelBox, Priority.ALWAYS);
		
		taskTwoDaysBox = new HBox(taskTwoDaysLabelBox, taskTwoDaysCountBox);
		
		// CSS
		taskTwoDaysBox.getStyleClass().add("summary-box");
		taskTwoDaysCount.getStyleClass().add("summary-box-count");
		taskTwoDaysLabel.getStyleClass().add("summary-box-label");
		taskTwoDaysLabel.setStyle("-fx-font-family: \"Myriad Pro Light\";");
		
		taskTwoDaysLabelBox.getStyleClass().add("summary-box-label-box");
		taskTwoDaysCountBox.getStyleClass().add("summary-box-count-box");
	}
	
	private static void initEventTwoDays(int count, double maxWidth) {
		eventTwoDaysCount = new Label(String.valueOf(count));
		eventTwoDaysLabel = new Label(HEADER_EVENT_TWO_DAYS);
		
		eventTwoDaysCountBox = new HBox(eventTwoDaysCount);
		eventTwoDaysLabelBox = new HBox(eventTwoDaysLabel);
		eventTwoDaysCountBox.setAlignment(Pos.CENTER);
		eventTwoDaysLabelBox.setAlignment(Pos.CENTER_LEFT);
		
		eventTwoDaysCountBox.setMinWidth(maxWidth);
		HBox.setMargin(eventTwoDaysLabel, new Insets(0, 0, 0, MARGIN_SUMMARY_LABEL));
		HBox.setHgrow(eventTwoDaysLabelBox, Priority.ALWAYS);
		
		eventTwoDaysBox = new HBox(eventTwoDaysLabelBox, eventTwoDaysCountBox);

		// CSS
		eventTwoDaysBox.getStyleClass().add("summary-box");
		eventTwoDaysCount.getStyleClass().add("summary-box-count");
		eventTwoDaysLabel.getStyleClass().add("summary-box-label");
		eventTwoDaysLabel.setStyle("-fx-font-family: \"Myriad Pro Light\";");
		
		eventTwoDaysLabelBox.getStyleClass().add("summary-box-label-box");
		eventTwoDaysCountBox.getStyleClass().add("summary-box-count-box");
	}
	
	private static void initTaskFloat(int count, double maxWidth) {
		taskFloatCount = new Label(String.valueOf(count));
		taskFloatLabel = new Label(HEADER_TASK_FLOAT);
		
		taskFloatCountBox = new HBox(taskFloatCount);
		taskFloatLabelBox = new HBox(taskFloatLabel);
		taskFloatCountBox.setAlignment(Pos.CENTER);
		taskFloatLabelBox.setAlignment(Pos.CENTER_LEFT);
		
		taskFloatCountBox.setMinWidth(maxWidth);
		HBox.setMargin(taskFloatLabel, new Insets(0, 0, 0, MARGIN_SUMMARY_LABEL));
		HBox.setHgrow(taskFloatLabelBox, Priority.ALWAYS);
		
		taskFloatBox = new HBox(taskFloatLabelBox, taskFloatCountBox);
		
		// CSS
		taskFloatBox.getStyleClass().add("summary-box");
		taskFloatCount.getStyleClass().add("summary-box-count");
		taskFloatLabel.getStyleClass().add("summary-box-label");
		taskFloatLabel.setStyle("-fx-font-family: \"Myriad Pro Light\";");
		
		taskFloatLabelBox.getStyleClass().add("summary-box-label-box");
		taskFloatCountBox.getStyleClass().add("summary-box-count-box");
	}
	
	private static void initEventOngoing(int count, double maxWidth) {
		eventOngoingCount = new Label(String.valueOf(count));
		eventOngoingLabel = new Label(HEADER_EVENT_ONGOING);
		
		eventOngoingCountBox = new HBox(eventOngoingCount);
		eventOngoingLabelBox = new HBox(eventOngoingLabel);
		eventOngoingCountBox.setAlignment(Pos.CENTER);
		eventOngoingLabelBox.setAlignment(Pos.CENTER_LEFT);
		
		eventOngoingCountBox.setMinWidth(maxWidth);
		HBox.setMargin(eventOngoingLabel, new Insets(0, 0, 0, MARGIN_SUMMARY_LABEL));
		HBox.setHgrow(eventOngoingLabelBox, Priority.ALWAYS);
		
		eventOngoingBox = new HBox(eventOngoingLabelBox, eventOngoingCountBox);
		
		// CSS
		eventOngoingBox.getStyleClass().add("summary-box");
		eventOngoingCount.getStyleClass().add("summary-box-count");
		eventOngoingLabel.getStyleClass().add("summary-box-label");
		eventOngoingLabel.setStyle("-fx-font-family: \"Myriad Pro Light\";");
		
		eventOngoingLabelBox.getStyleClass().add("summary-box-label-box");
		eventOngoingCountBox.getStyleClass().add("summary-box-count-box");
	}
	
	private static void initAllUnres(int count, double maxWidth) {
		allUnresCount = new Label(String.valueOf(count));
		allUnresLabel = new Label(HEADER_ALL_UNRES);
		allUnresAttention = new Label(HEADER_ALL_UNRES_ATTENTION);
		allUnresClear = new Label(HEADER_ALL_UNRES_CLEAR);
		initUnresIcon(count);
		
		allUnresCountBox = new HBox(allUnresCount);
		allUnresLabelBox = new HBox(allUnresLabel);
		allUnresIconBox = new HBox(allUnresIcon);
		initUnresNotifyBox(count);
		
		allUnresBox = new HBox(allUnresLabelBox, allUnresNotifyBox, 
				allUnresIconBox, allUnresCountBox);
		
		// Add event handling for mouse clicks
		allUnresAttention.addEventHandler(MouseEvent.MOUSE_ENTERED, 
				Handlers.getUnresHoverHandler(allUnresAttention));
		allUnresAttention.addEventHandler(MouseEvent.MOUSE_EXITED, 
				Handlers.getUnresHoverHandler(allUnresAttention));
		allUnresAttention.addEventHandler(MouseEvent.MOUSE_CLICKED, 
				Handlers.getUnresClickHandler());
		
		// Component formatting
		allUnresCountBox.setAlignment(Pos.CENTER);
		allUnresLabelBox.setAlignment(Pos.CENTER_LEFT);
		allUnresIconBox.setAlignment(Pos.CENTER);
		allUnresNotifyBox.setAlignment(Pos.CENTER_LEFT);
		
		allUnresCountBox.setMinWidth(maxWidth);
		HBox.setMargin(allUnresLabel, new Insets(0, 0, 0, MARGIN_SUMMARY_LABEL));
		HBox.setMargin(allUnresAttention, new Insets(0, 0, 0, MARGIN_SUMMARY_COUNT_HORIZ));
		HBox.setMargin(allUnresClear, new Insets(0, 0, 0, MARGIN_SUMMARY_COUNT_HORIZ));
		HBox.setMargin(allUnresIcon, new Insets(0, MARGIN_SUMMARY_COUNT_HORIZ, 0, 0));
		HBox.setHgrow(allUnresNotifyBox, Priority.ALWAYS);
		
		// CSS
		allUnresBox.getStyleClass().add("summary-box");
		allUnresCount.getStyleClass().add("summary-box-count");
		allUnresLabel.getStyleClass().add("summary-box-label");
		allUnresAttention.getStyleClass().add("summary-box-notify");
		allUnresClear.getStyleClass().add("summary-box-notify");
		allUnresLabel.setStyle("-fx-font-family: \"Myriad Pro Light\";");
		allUnresAttention.setStyle("-fx-font-family: \"Myriad Pro Light\"; "
				+ "-fx-font-style: italic;");
		allUnresClear.setStyle("-fx-font-family: \"Myriad Pro Light\"; "
				+ "-fx-font-style: italic;");
		
		allUnresLabelBox.getStyleClass().add("summary-box-label-box");
		allUnresIconBox.getStyleClass().add("summary-box-label-box");
		allUnresCountBox.getStyleClass().add("summary-box-count-box");
		allUnresNotifyBox.getStyleClass().add("summary-box-notify-box");
	}
	
    // ================================================================================
    // Private methods, used to initialize and update the unresolved bar
    // ================================================================================
	
	private static void initUnresIcon(int count) {
		if (count == 0) {
			allUnresIcon = new ImageView(PATH_UNRES_TICK);
		} else {
			allUnresIcon = new ImageView(PATH_UNRES_ALERT);
		}
	}
	
	private static void initUnresNotifyBox(int count) {
		if (count == 0) {
			allUnresNotifyBox = new HBox(allUnresClear);
		} else {
			allUnresNotifyBox = new HBox(allUnresAttention);
		}
	}
	
	private static void updateUnresNotifyBox(int count) {
		allUnresNotifyBox.getChildren().clear();
		if (count == 0) {
			allUnresNotifyBox.getChildren().add(allUnresClear);
		} else {
			allUnresNotifyBox.getChildren().add(allUnresAttention);
		}
	}
	
    // ================================================================================
    // Misc private methods used to perform calculations and formatting
    // ================================================================================
	
	/**
	 * This method returns the width of the largest number that will be displayed 
	 * in the summary view
	 * 
	 * @param summary
	 * 			  The array of values to be used in the summary view
	 * @return The width of the largest number to be used in the summary view
	 */
	private static double getCountMaxWidth(int[] summary) {
		// Obtain the largest value within summary
		int maxValue = summary[0];
		for (int i = 1; i < 5; i++) {
			maxValue = Math.max(maxValue, summary[i]);
		}
		
		Text text = new Text(String.valueOf(maxValue));
		new Scene(new Group(text));
		text.setStyle("-fx-font-family: \"Myriad Pro Light\";"
				+ "-fx-font-size: 48;");
		text.applyCss();
		double maxWidth = text.getLayoutBounds().getWidth() + 2 * MARGIN_SUMMARY_COUNT_HORIZ;
		return maxWidth;
	}

	/**
	 * This method formats all five HBoxes used in the summary view during initialization
	 */
	private static void formatSummaryBox() {
		HBox.setHgrow(taskTwoDaysBox, Priority.ALWAYS);
		HBox.setHgrow(eventTwoDaysBox, Priority.ALWAYS);
		HBox.setHgrow(taskFloatBox, Priority.ALWAYS);
		HBox.setHgrow(eventOngoingBox, Priority.ALWAYS);
		HBox.setHgrow(allUnresBox, Priority.ALWAYS);
		
		VBox.setMargin(taskTwoDaysBox, new Insets(0, MARGIN_SUMMARY_BOX, 0, MARGIN_SUMMARY_BOX));
		VBox.setMargin(eventTwoDaysBox, new Insets(0, MARGIN_SUMMARY_BOX, 0, MARGIN_SUMMARY_BOX));
		VBox.setMargin(taskFloatBox, new Insets(0, MARGIN_SUMMARY_BOX, 0, MARGIN_SUMMARY_BOX));
		VBox.setMargin(eventOngoingBox, new Insets(0, MARGIN_SUMMARY_BOX, 0, MARGIN_SUMMARY_BOX));
		VBox.setMargin(allUnresBox, new Insets(0, MARGIN_SUMMARY_BOX, 0, MARGIN_SUMMARY_BOX));
	}
}
```
###### gui\UnresolvedViewController.java
``` java
 */

package gui;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Line;
import struct.View;

public class UnresolvedViewController {

	// ================================================================================
    // JavaFX controls used in the unresolved interface
    // ================================================================================
	
	// Used for initUnresTaskView
    private static VBox unresTaskBox, unresTaskContentBox;
    private static HBox unresTaskHeaderBox;
    private static ScrollPane unresTaskScroll;

    // Used for initUnresEventView
    private static VBox unresEventBox, unresEventContentBox;
    private static HBox unresEventHeaderBox;
    private static ScrollPane unresEventScroll;

    // Used for initUnresView
    private static Line unresScrollLine;
    
    private static final String HEADER_UNRESOLVED_TASKS = "UNRESOLVED TASKS";
    private static final String HEADER_UNRESOLVED_EVENTS = "UNRESOLVED EVENTS";
    
    /**
     * This method initializes all the interface components for the unresolved view,
     * primarily the task window and the event window
     */
    protected static void initUnresView() {
        initUnresTaskView(InterfaceController.getLogic().getUnresTasks());
        initUnresEventView(InterfaceController.getLogic().getUnresEvents());
        
        unresScrollLine = new Line(0, 0, 0, InterfaceController.WIDTH_DEFAULT_BUTTON);
        InterfaceController.unresBox = new HBox(unresTaskBox, unresScrollLine, unresEventBox);
        
        // Component formatting
        unresTaskScroll.prefViewportWidthProperty().bind(
        		InterfaceController.unresBox.widthProperty().divide(2));
        unresEventScroll.prefViewportWidthProperty().bind(
        		InterfaceController.unresBox.widthProperty().divide(2));
        
        unresTaskScroll.maxWidthProperty().bind(
        		InterfaceController.unresBox.widthProperty().divide(2));
        unresEventScroll.maxWidthProperty().bind(
        		InterfaceController.unresBox.widthProperty().divide(2));
        
        unresScrollLine.endYProperty().bind(DefaultViewController.getDefScrollLine().endYProperty());
        
        // CSS
        unresScrollLine.getStyleClass().add("line");
    }
    
    /**
     * This method updates the unresolved view with data from the text file
     * 
     * Called by:
     * 	1. 	runCommand() in LogicController to update the view every time an 
     * 		operation is performed
     * 	2. 	updateMainInterface() in InterfaceController to update the view when
     * 		a view change command is issued (button/hotkey/text command)
     */
    protected static void updateUnresView() {
    	// Clear the previous content already displayed
        unresTaskContentBox.getChildren().clear();
        unresEventContentBox.getChildren().clear();
        ViewIndexMap.resetUnresMap();
        
        String[] tasks = InterfaceController.getLogic().getUnresTasks();
        String[] events = InterfaceController.getLogic().getUnresEvents();
    	int numOfElements = InterfaceController.getLogic().getUnresElementsCount();
    	int numOfResults = 1;
    	
        // Run the loop through the entire task list
        for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, numOfResults, true, View.UNRESOLVED);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            unresTaskContentBox.getChildren().add(tempBox);
			// Only increment the counter if an element is added
			if (InterfaceController.getLogic().isNonEmptyElement(tasks[i])) {
				numOfResults++;
			}
        }
        // Run the loop through the entire event list
        for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, numOfResults, false, View.UNRESOLVED);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            unresEventContentBox.getChildren().add(tempBox);
			// Only increment the counter if an element is added
			if (InterfaceController.getLogic().isNonEmptyElement(events[i])) {
				numOfResults++;
			}
        }
    }
    
    // ================================================================================
    // Private methods, used to initialize various sub components of the interface
    // ================================================================================
    
    /**
     * This method initializes the task view for the unresolved view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getUnresTasks()
     */
    private static void initUnresTaskView(String[] tasks) {
    	Label unresTaskHeader = new Label(HEADER_UNRESOLVED_TASKS);
        unresTaskHeaderBox = new HBox(unresTaskHeader);
        unresTaskContentBox = new VBox();
    	int numOfElements = InterfaceController.getLogic().getUnresElementsCount();
    	
        initUnresTasks(tasks, numOfElements);
        unresTaskScroll = new ScrollPane(unresTaskContentBox);
        unresTaskBox = new VBox(unresTaskHeaderBox, unresTaskScroll);
        
        // Component formatting
        unresTaskHeaderBox.setAlignment(Pos.CENTER);
        unresTaskScroll.setFitToWidth(true);
        VBox.setVgrow(unresTaskScroll, Priority.ALWAYS);
        unresTaskBox.setAlignment(Pos.CENTER);
        
        HBox.setMargin(unresTaskHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(unresTaskHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(unresTaskScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        unresTaskScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        unresTaskHeader.getStyleClass().add("box-title-label");
        unresTaskHeaderBox.getStyleClass().add("box-title-all-task");
    }

    /**
     * This method initializes the event view for the unresolved view
     * 
     * @param tasks
     * 		      A String[] of tasks returned from LogicController's
     * 			  getUnresEvents()
     */
    private static void initUnresEventView(String[] events) {
    	Label unresEventHeader = new Label(HEADER_UNRESOLVED_EVENTS);
        unresEventHeaderBox = new HBox(unresEventHeader);
        unresEventContentBox = new VBox();
    	int numOfElements = InterfaceController.getLogic().getUnresElementsCount();
    	
        initUnresEvents(events, numOfElements);
        unresEventScroll = new ScrollPane(unresEventContentBox);
        unresEventBox = new VBox(unresEventHeaderBox, unresEventScroll);
        
        // Component formatting
        unresEventHeaderBox.setAlignment(Pos.CENTER);
        unresEventScroll.setFitToWidth(true);
        VBox.setVgrow(unresEventScroll, Priority.ALWAYS);
        unresEventBox.setAlignment(Pos.CENTER);

        HBox.setMargin(unresEventHeader, new Insets(
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0, 
        		InterfaceController.MARGIN_TEXT_ELEMENT_HEIGHT, 0));
        
        VBox.setMargin(unresEventHeaderBox, new Insets(
        		0, InterfaceController.MARGIN_SCROLL, 
        		0, InterfaceController.MARGIN_SCROLL));
        
        VBox.setMargin(unresEventScroll, new Insets(
        		InterfaceController.MARGIN_COMPONENT, 
        		InterfaceController.MARGIN_SCROLL, 
        		0, 
        		InterfaceController.MARGIN_SCROLL));
        
        unresEventScroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        // CSS
        unresEventHeader.getStyleClass().add("box-title-label");
        unresEventHeaderBox.getStyleClass().add("box-title-all-event");
    }

	/**
	 * This method initializes the task content of the unresolved view with data
	 * 
	 * @param tasks
	 * 			  The array of task data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initUnresTasks(String[] tasks, int numOfElements) {
		for (int i = 0; i < tasks.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			tasks[i], numOfElements, 1, true, View.UNRESOLVED);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            unresTaskContentBox.getChildren().add(tempBox);
        }
	}
	
	/**
	 * This method initializes the event content of the unresolved view with data
	 * 
	 * @param events
	 * 			  The array of event data to be displayed in the view
	 * @param numOfElements
	 * 			  The total number of tasks/events. Used for formatting the index box
	 * @return The index of the last element to be added
	 */
	private static void initUnresEvents(String[] events, int numOfElements) {
		for (int i = 0; i < events.length; i++) {
        	// Use a temporary component for formatting
        	HBox tempBox = InterfaceController.initDisplayElement(
        			events[i], numOfElements, 1, false, View.UNRESOLVED);
        	VBox.setMargin(tempBox, new Insets(
        			0, 0, InterfaceController.MARGIN_TEXT_ELEMENT_SEPARATOR, 0));
            unresEventContentBox.getChildren().add(tempBox);
        }
	}
}
```
###### test\CommandHistoryTest.java
``` java
 */

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import gui.CommandHistory;

public class CommandHistoryTest {

	// Create an instance of command history
	CommandHistory ch = new CommandHistory();
	
	@Test
	// Average case test for previous, 10 commands
	public void testCase1() {
		
		// Correct result
		String expected = "10 9 8 7 6 5 4 3 2 1 ";
		
		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();
		ch.add("6");
		ch.resetIndex();
		ch.add("7");
		ch.resetIndex();
		ch.add("8");
		ch.resetIndex();
		ch.add("9");
		ch.resetIndex();
		ch.add("10");
		ch.resetIndex();
		
		String actual = "";
		
		for (int i = 0; i < 10; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
			actual += ch.getText() + " ";
		}
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Average test case for next, 10 commands
	public void testCase2() {
		
		// Correct result
		String expected = "2 3 4 5 6 7 8 9 10 10 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();
		ch.add("6");
		ch.resetIndex();
		ch.add("7");
		ch.resetIndex();
		ch.add("8");
		ch.resetIndex();
		ch.add("9");
		ch.resetIndex();
		ch.add("10");
		ch.resetIndex();
		
		String actual = "";
		
		for (int i = 0; i < 10; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
		}
		
		for (int i = 0; i < 10; i++) {
			String next = ch.getNextTest();
			ch.updateField(next);
			actual += ch.getText() + " ";
		}
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Average test case for alternate previous and next, 10 commands
	public void testCase3() {
		
		// Correct result
		String expected = "9 10 9 10 9 10 9 10 9 10 9 10 9 10 9 10 9 10 9 10 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();
		ch.add("6");
		ch.resetIndex();
		ch.add("7");
		ch.resetIndex();
		ch.add("8");
		ch.resetIndex();
		ch.add("9");
		ch.resetIndex();
		ch.add("10");
		ch.resetIndex();

		String actual = "";
		
		String first = ch.getPreviousTest();
		ch.updateField(first);
		
		for (int i = 0; i < 10; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
			actual += ch.getText() + " ";
			String next = ch.getNextTest();
			ch.updateField(next);
			actual += ch.getText() + " ";
		}

		assertEquals(expected, actual);
	}
	
	@Test
	/* Small test case for previous and next, 2 commands
	 * Testing for ArrayIndexOutOfBoundsException since getPrevious() and
	 * getNext() have consecutive double increments(++) and decrements(--)
	 */
	public void testCase4() {
		
		// Correct result
		String expected = "1 2 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();

		String actual = "";
		String prev, next;

		prev = ch.getPreviousTest();
		ch.updateField(prev);
		prev = ch.getPreviousTest();
		ch.updateField(prev);
		prev = ch.getPreviousTest();
		ch.updateField(prev);
		prev = ch.getPreviousTest();
		ch.updateField(prev);
		prev = ch.getPreviousTest();
		ch.updateField(prev);
		
		actual += ch.getText() + " ";
		
		next = ch.getNextTest();
		ch.updateField(next);
		next = ch.getNextTest();
		ch.updateField(next);
		next = ch.getNextTest();
		ch.updateField(next);
		next = ch.getNextTest();
		ch.updateField(next);
		next = ch.getNextTest();
		ch.updateField(next);
		
		actual += ch.getText() + " ";

		assertEquals(expected, actual);
	}
	
	@Test
	// Average test case for previous and next for n = 3 waves, 
	// n+2 getPrevious() calls and n getNext() calls, 15 commands
	public void testCase5() {
		
		// Correct result
		String expected = "11 14 9 12 7 10 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();
		ch.add("6");
		ch.resetIndex();
		ch.add("7");
		ch.resetIndex();
		ch.add("8");
		ch.resetIndex();
		ch.add("9");
		ch.resetIndex();
		ch.add("10");
		ch.resetIndex();
		ch.add("11");
		ch.resetIndex();
		ch.add("12");
		ch.resetIndex();
		ch.add("13");
		ch.resetIndex();
		ch.add("14");
		ch.resetIndex();
		ch.add("15");
		ch.resetIndex();

		String actual = "";

		for (int n = 0; n < 3; n++) {
			for (int i = 0; i < 5; i++) {
				String prev = ch.getPreviousTest();
				ch.updateField(prev);
			}
			actual += ch.getText() + " ";
			
			for (int j = 0; j < 3; j++) {
				String next = ch.getNextTest();
				ch.updateField(next);
			}
			actual += ch.getText() + " ";
		}

		assertEquals(expected, actual);
	}
	
	@Test
	// Average test case with duplicate values, 10 commands
	public void testCase6() {
		
		// Correct result
		String expected = "3 3 3 3 3 2 3 3 3 2 2 2 2 1 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("3");

		String actual = "";

		for (int i = 0; i < 6; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
			actual += ch.getText() + " ";
		}
		
		for (int j = 0; j < 2; j++) {
			String next = ch.getNextTest();
			ch.updateField(next);
			actual += ch.getText() + " ";
		}
		
		for (int i = 0; i < 6; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
			actual += ch.getText() + " ";
		}

		assertEquals(expected, actual);
	}
	
	@Test
	/* Small test case for edge cases on getPrevious(), 5 commands
	 * Even if getPrevious() is called > 5 times only the first command 
	 * should be returned. Right after, calling getNext() should return
	 * the second command and not cycle through extra copies of the first
	 * command.
	 */
	public void testCase7() {
		
		// Correct result
		String expected = "1 2 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();

		String actual = "";

		for (int i = 0; i < 10; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
		}
		actual += ch.getText() + " ";
		
		String next = ch.getNextTest();
		ch.updateField(next);
		actual += ch.getText() + " ";

		assertEquals(expected, actual);
	}
	
	@Test
	/* Small test case for edge cases on getNext(), 5 commands
	 * Even if getNext() is called > 5 times only the last command should
	 * be returned. Right after, calling getPrevious() should return the 
	 * second last command and not cycle through extra copies of the last
	 * command.
	 */
	public void testCase8() {
		
		// Correct result
		String expected = "5 4 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();

		String actual = "";

		for (int i = 0; i < 10; i++) {
			String next = ch.getNextTest();
			ch.updateField(next);
		}
		actual += ch.getText() + " ";
		
		String prev = ch.getPreviousTest();
		ch.updateField(prev);
		actual += ch.getText() + " ";

		assertEquals(expected, actual);
	}
	
	@Test
	/* Small test case for edge cases on both getNext() and getPrevious().
	 * Only the first and last commands should be returned even for excessive
	 * calls to either method.
	 */
	public void testCase9() {
		
		// Correct result
		String expected = "1 5 ";

		// Test result
		ch.add("1");
		ch.resetIndex();
		ch.add("2");
		ch.resetIndex();
		ch.add("3");
		ch.resetIndex();
		ch.add("4");
		ch.resetIndex();
		ch.add("5");
		ch.resetIndex();

		String actual = "";

		for (int i = 0; i < 10; i++) {
			String prev = ch.getPreviousTest();
			ch.updateField(prev);
		}
		actual += ch.getText() + " ";
		
		for (int i = 0; i < 10; i++) {
			String next = ch.getNextTest();
			ch.updateField(next);
		}
		actual += ch.getText() + " ";

		assertEquals(expected, actual);
	}
}
```
###### test\LogicControllerTest.java
``` java
 */

package test;

import static org.junit.Assert.*;

import java.nio.file.FileSystemException;
import java.util.ArrayList;

import org.junit.Test;

import gui.InterfaceController;
import gui.LogicController;
import struct.Command;

public class LogicControllerTest {

	LogicController lc = new LogicController();
	
	// Ignoring all tests for default tasks and events
	// Given that the test cases need to be altered every day
	
	@Test
	// Test for getAllElementsCount(), and by extension getAllTasks() and getAllEvents()
	public void testCase1() {
		InterfaceController.initLogicControl();
		
		try {
			LogicController.getLogic().overwriteFile("");
		} catch (FileSystemException e) {
			e.printStackTrace();
		}
		
		// Do first initialization of the test data
		lc.runCommandTest("add float1");
		lc.runCommandTest("add float2");
		lc.runCommandTest("add float3");
		lc.runCommandTest("add float4");
		lc.runCommandTest("add float5");
		lc.runCommandTest("add float6");
		lc.runCommandTest("add float7");
		lc.runCommandTest("add float8");
		lc.runCommandTest("add float9");
		lc.runCommandTest("add deadline1 by 081116");
		lc.runCommandTest("add deadline2 by 091116");
		lc.runCommandTest("add deadline3 by 101116");
		lc.runCommandTest("add deadline4 by 111116");
		lc.runCommandTest("add deadline5 by 111116");
		lc.runCommandTest("add deadline6 by 121116");
		lc.runCommandTest("add deadline7 by 121116");
		lc.runCommandTest("add event1 from 051116 0000 to 061116 0000");
		lc.runCommandTest("add event2 from 061116 0000 to 061116 2000");
		lc.runCommandTest("add event3 from 071116 0000 to 071116 2100");
		lc.runCommandTest("add event4 from 091116 0000 to 131116 0000");
		lc.runCommandTest("add event5 from 101116 0000 to 111116 0000");
		lc.runCommandTest("add event6 from 101116 0000 to 111116 0000");
		lc.runCommandTest("add event7 from 101116 0000 to 111116 0000");
		lc.runCommandTest("add event8 from 121116 0000 to 151116 0000");
		lc.runCommandTest("done 1");
		lc.runCommandTest("done 2");
		lc.runCommandTest("done 3");
		lc.runCommandTest("done 4");
		lc.runCommandTest("done 5");
		lc.runCommandTest("done 17");
		lc.runCommandTest("done 18");
		lc.runCommandTest("done 19");
		lc.runCommandTest("done 20");
		lc.runCommandTest("done 21");
		lc.runCommandTest("done 22");
		
		int expected = 13;
		int actual = lc.getAllElementsCount();
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Test for getSearchElementsCount()
	public void testCase2() {
		
		int expected = 17;
		
		ArrayList<String> taskResultsTest = new ArrayList<String>();
		taskResultsTest.add("FLOAT");
		taskResultsTest.add("There are no items to display.");
		taskResultsTest.add("TUE, 08 NOV 2016");
		taskResultsTest.add("1. match");
		taskResultsTest.add("2. match");
		taskResultsTest.add("3. match");
		taskResultsTest.add("4. match");
		taskResultsTest.add("THU, 10 NOV 2016");
		taskResultsTest.add("5. match");
		taskResultsTest.add("6. match");
		taskResultsTest.add("7. match");
		taskResultsTest.add("FRI, 11 NOV 2016");
		taskResultsTest.add("8. match");
		taskResultsTest.add("9. match");
		
		ArrayList<String> eventResultsTest = new ArrayList<String>();
		eventResultsTest.add("ONGOING");
		eventResultsTest.add("10. match");
		eventResultsTest.add("11. match");
		eventResultsTest.add("WED, 09 NOV 2016");
		eventResultsTest.add("12. match");
		eventResultsTest.add("13. match");
		eventResultsTest.add("14. match");
		eventResultsTest.add("15. match");
		eventResultsTest.add("FRI, 11 NOV 2016");
		eventResultsTest.add("16. match");
		eventResultsTest.add("17. match");
		
		int actual = lc.getSearchElementsCount(taskResultsTest, eventResultsTest);
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Test for getUnresElementsCount(), and by extension getUnresTasks() and getUnresEvents()
	public void testCase3() {
		
		int expected = 0;
		int actual = lc.getUnresElementsCount();
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Test for getDoneElementsCount(), and by extension getDoneTasks() and getDoneEvents()
	public void testCase4() {
		
		int expected = 11;
		int actual = lc.getDoneElementsCount();
		
		assertEquals(expected, actual);
	}
	
	@Test
	// Test for getDefElementsCount(), and by extension getDefTasks() and getDefEvents()
	public void testCase5() {
		
		int expected = 4;
		int actual = lc.getDefElementsCount();
		
		assertEquals(expected, actual);
	}

	@Test
	// Test for getSummaryCount(), and by extension getDefTasks() and getDefEvents()
	public void testCase6() {
		
		int[] expected = {0, 0, 4, 0, 0};
		
		int[] actual = new int[5];
		actual = lc.getSummaryCount();
		
		// Remove the added lines
		for (int i = 0; i < 35; i++) {
			lc.runCommandTest("delete 1");
		}
		
		assertEquals(expected[0], actual[0]);
		assertEquals(expected[1], actual[1]);
		assertEquals(expected[2], actual[2]);
		assertEquals(expected[3], actual[3]);
		assertEquals(expected[4], actual[4]);
	}
}
```
