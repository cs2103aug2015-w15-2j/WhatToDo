# A0127051U
###### backend\Filter.java
``` java
 */

package backend;

import java.util.ArrayList;

import struct.Date;

public class Filter {
	
	private static final int INDEX_TYPE = 0; 
	private static final int INDEX_NAME = 1; 
	private static final int INDEX_ISDONE = 2; 
	private static final int INDEX_DUEDATE = 3;
	private static final int INDEX_STARTDATE = 3; 
	private static final int INDEX_ENDDATE = 5; 
	
    private static final String TYPE_TASK = "task";
    private static final String TYPE_EVENT = "event";
	
	private static final String DONE = "done";
	private static final String SEMICOLON = ";";
	private static final String REGEX_WHITESPACES = "[\\s,]+"; 
	
	//============================================
	// Public methods
	//============================================
	
	/**
	 * filters tasks and events only
	 * @param linesInFile
	 * @param type
	 * @param date
	 * @return the arraylist of indexes of tasks due on date if type is task 
	 *         the arraylist indexes of events starting on date if type is event
	 */
	public ArrayList<Integer> filterDate(String[] linesInFile, String type, Date date){ 
		 assert(type.equals(TYPE_TASK) || type.equals(TYPE_EVENT));
		
		 ArrayList<Integer> resultList = new ArrayList<Integer>(); 
		 
		 for(int i = 0; i < linesInFile.length; i++){ 
			 String line = linesInFile[i]; 
			 if(isType(type, line) && isReqStatus(false, line) && isOnDate(date, line)){
				 resultList.add(i); 
			 }
		 } 
		 
		 return resultList; 
	}
	
	/**
	 * filters for ongoing events - events starting earlier than today 
	 * and ending later than today 
	 * @param linesInFile
	 * @return the arraylist indexes of ongoing events 
	 */
	public ArrayList<Integer> filterOngoingEvents(String[] linesInFile){ 
		ArrayList<Integer> resultList = new ArrayList<Integer>(); 
		
		for(int i = 0; i < linesInFile.length; i++){ 
			String line = linesInFile[i];
			if(isType(TYPE_EVENT, line) && isReqStatus(false, line) && isOngoing(line)){
				resultList.add(i);
			}
		}
		
		return resultList; 
	}
	
	/**
	 * filters any type of to-do item
	 * @param linesInFile
	 * @param type
	 * @param isDone
	 * @return arraylist of indexes items of type 'type' that is done if isDone is true 
	 *         arraylist of indexes items of type 'type' that is uncompleted, otherwise
	 */
	public ArrayList<Integer> filterStatus(String[] linesInFile, String type, boolean isDone){ 
		 ArrayList<Integer> resultList = new ArrayList<Integer>(); 
		 
		 for(int i = 0; i < linesInFile.length; i++){ 
			 String line = linesInFile[i];
			 if(isType(type, line) && isReqStatus(isDone, line)){
				 resultList.add(i); 
			 }
		 }
		 
		 return resultList; 
	}
	
	/**
	 * filters tasks and events only
	 * @param linesInFile
	 * @param type
	 * @param date
	 * @return the arraylist of indexes of tasks that is uncompleted and past deadline 
	 *          or arraylist of indexed of events that is uncompleted and past enddate
	 */
	public ArrayList<Integer> filterPastUncompleted(String[] linesInFile, String type){ 
		assert(type.equals(TYPE_TASK) || type.equals(TYPE_EVENT));
		
		ArrayList<Integer> resultList = new ArrayList<Integer>(); 
		
		for(int i = 0; i < linesInFile.length; i++){ 
			 String line = linesInFile[i];
			 if(isType(type, line) && isPast(type, line) &&isReqStatus(false, line)){
				 resultList.add(i); 
			 }
		 }

		return resultList; 
	}
	
	/**
	 * filter method for search
	 * @param linesInFile
	 * @param type
	 * @param query
	 * @return arraylist of indexes of items that match at least one of the tokens in query 
	 */
	public ArrayList<Integer> matchTokensInQuery(String[] linesInFile, String type, String query){ 
		String[] tokens = parseQuery(query); 
		ArrayList<Integer> resultList = new ArrayList<Integer>(); 
		
		for(int i = 0; i < linesInFile.length; i++){ 
			String line = linesInFile[i];
			if(isType(type, line) && containToken(tokens, line)){
				resultList.add(i); 
			}
		}
		
		return resultList; 
	}
		
	//============================================
	// Private methods 
	//============================================
	
	private boolean isType(String type, String line){
		String[] lineFields = line.split(SEMICOLON);
		String lineType = lineFields[INDEX_TYPE];
		return lineType.equals(type); 
	}
	
	private boolean isOnDate(Date date, String line){
		String[] lineFields = line.split(SEMICOLON);
		Date lineDate = new Date(lineFields[INDEX_DUEDATE]);
		if(lineDate.compareTo(date) == 0){ 
			return true; 
		}
		else{ 
			return false; 
		}
	}
	
	private boolean isReqStatus(boolean isDone, String line){ 
		if(isDone){ 
			return isCompleted(line); 
		}
		else{
			return !isCompleted(line); 
		}
	}
	
	private boolean isOngoing(String line){
		String[] lineFields = line.split(SEMICOLON);
		
		assert(lineFields[INDEX_TYPE].equals(TYPE_EVENT));
		
		Date todayDate = Date.todayDate(); 
		Date startDate = new Date(lineFields[INDEX_STARTDATE]);
		Date endDate = new Date(lineFields[INDEX_ENDDATE]);
		
		return startDate.compareTo(todayDate) < 0 && endDate.compareTo(todayDate) >= 0; 
	}
	
	private boolean isCompleted(String line){ 
		String[] lineFields = line.split(SEMICOLON);
		String lineIsDone = lineFields[INDEX_ISDONE];
		return lineIsDone.equals(DONE); 
	}
	
	private boolean isPast(String type, String line){ 
		assert(type.equals(TYPE_TASK) || type.equals(TYPE_EVENT));
		
		String[] lineFields = line.split(SEMICOLON);
		String lineDateStr = getPastDate(type, lineFields); 
		Date lineDate = new Date(lineDateStr); 
		Date todayDate = Date.todayDate(); 
		
		if(lineDate.compareTo(todayDate) < 0){
			return true; 
		}
		else{ 
			return false; 
		}
	}
	/**
	 * get date to compare to today's date to determine if item is past 
	 * @param type
	 * @param lineFields
	 * @return deadline if type is task
	 *         end date if type id event 
	 */
	private String getPastDate(String type, String[] lineFields) {
		assert(type.equals(TYPE_TASK) || type.equals(TYPE_EVENT));
		if(type.equals(TYPE_TASK)){ 
			return lineFields[INDEX_DUEDATE]; 
		}
		else{
			return lineFields[INDEX_ENDDATE];
		}
	}
	
	private String[] parseQuery(String rawQuery){ 
		String query = rawQuery.trim().toLowerCase();
		String[] tokens = query.split(REGEX_WHITESPACES);
		return tokens; 
	}
	
	private boolean containToken(String[] tokens, String line){
		String[] lineFields = line.split(SEMICOLON);
		String lineName = lineFields[INDEX_NAME].toLowerCase();
		boolean result = false; 
		int i = 0; 
		
		while(!result && i < tokens.length){
			result = lineName.contains(tokens[i]);
			i++; 
		}
		
		return result; 
	}
}
```
###### backend\Formatter.java
``` java
 */

package backend;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

import struct.Date;

public class Formatter {

	private static final int INDEX_TYPE = 0; 
	private static final int INDEX_NAME = 1; 
	private static final int INDEX_ISDONE = 2; 
	private static final int INDEX_DUEDATE = 3;
	private static final int INDEX_STARTDATE = 3; 
	private static final int INDEX_STARTTIME = 4; 
	private static final int INDEX_ENDDATE = 5; 
	private static final int INDEX_ENDTIME = 6; 
	
	private static final String DISPLAY_NO_ITEMS = "There are no items to display.\n"; 
    private static final String DISPLAY_FORMAT_FLOAT_OR_TASK = "%s%d. %s\n"; 
    private static final String DISPLAY_FORMAT_EVENT = "%s%d. %s;Start: %s%s;End: %s %s\n"; 
    private static final String DISPLAY_FORMAT_DELETED_OR_MARKDONE = "%s \"%s\"";
    
    private static final String DISPLAY_LAYOUT_ALL_TASK = "%s\nFLOAT\n%s"; 
    private static final String DISPLAY_LAYOUT_DEFAULT_TASK = "TODAY - %s \n%s\nTOMORROW - %s \n%s\nFLOAT\n%s";
    private static final String DISPLAY_LAYOUT_DEFAULT_EVENT = "ONGOING\n%s\nTODAY - %s \n%s\nTOMORROW - %s \n%s";
    private static final String DISPLAY_LAYOUT_SEARCH_RESULTS = "Showing results for \"%s\"\nTASK\n%s\nFLOAT\n%s\nEVENT\n%s"; 
    
    private static final String TYPE_FLOAT = "float";
    private static final String TYPE_TASK = "task";
    private static final String TYPE_EVENT = "event";
    
	private static final String SEMICOLON = ";";
	private static final String NEWLINE = "\n";
	private static final String EMPTYSTRING = ""; 
	private static final String SPACE = " "; 
	
	private static final String REGEX_24_HOUR_TIME = "([01]?[0-9]|2[0-3])[0-5][0-9]";
	
	//============================================
	// Public methods 
	//============================================
	
	/**
	 * formats content to display in events in default view 
	 * @param linesInFile
	 * @param eventOngoingIndexList
	 * @param eventTodayIndexList
	 * @param eventTmrIndexList
	 * @return formatted string
	 */
	public String formatDefEventView(String[] linesInFile, ArrayList<Integer> eventOngoingIndexList, 
			ArrayList<Integer> eventTodayIndexList, ArrayList<Integer> eventTmrIndexList){ 
		
		String ongoingContent = formatEventWithoutHeaders(linesInFile, eventOngoingIndexList, true); 
		String todayContent = formatEventWithoutHeaders(linesInFile, eventTodayIndexList, false); 
		String tmrContent = formatEventWithoutHeaders(linesInFile, eventTmrIndexList, false); 
		String todayDate = Date.todayDateLong(); 
		String tmrDate = Date.tomorrowDateLong();
		
		return String.format(DISPLAY_LAYOUT_DEFAULT_EVENT, ongoingContent, todayDate, todayContent, 
        		tmrDate, tmrContent).trim();
	}

	/**
	 * formats content to display in tasks in default view 
	 * @param linesInFile
	 * @param taskTodayIndexList
	 * @param taskTmrIndexList
	 * @param floatIndexList
	 * @return formatted string
	 */
	public String formatDefTaskView(String[] linesInFile, ArrayList<Integer> taskTodayIndexList, 
			ArrayList<Integer> taskTmrIndexList, ArrayList<Integer> floatIndexList){ 
		
		String taskTodayContent = formatFloatOrTaskWithoutHeaders(linesInFile, taskTodayIndexList, false); 
		String taskTmrContent = formatFloatOrTaskWithoutHeaders(linesInFile, taskTmrIndexList, false); 
		String floatContent = formatFloatOrTaskWithoutHeaders(linesInFile, floatIndexList, false); 
		String todayDate = Date.todayDateLong(); 
		String tmrDate = Date.tomorrowDateLong(); 
		
        return String.format(DISPLAY_LAYOUT_DEFAULT_TASK, todayDate, taskTodayContent, 
        		tmrDate, taskTmrContent, floatContent).trim();
	}
	
	/**
	 * formats content to display tasks in all view 
	 * @param linesInFile
	 * @param taskIndexList
	 * @param floatIndexList
	 * @return formatted string
	 */
	public String formatAllTaskView(String[] linesInFile, 
			ArrayList<Integer> taskIndexList, ArrayList<Integer> floatIndexList){ 
		
		String taskContent = formatTaskWithHeaders(linesInFile, taskIndexList, false); 
		String floatContent = formatFloatOrTaskWithoutHeaders(linesInFile, floatIndexList, false);
		
		return String.format(DISPLAY_LAYOUT_ALL_TASK, taskContent, floatContent).trim(); 
	}
	
	/**
	 * formats content to display in search view 
	 * @param query
	 * @param linesInFile
	 * @param taskResults
	 * @param floatResults
	 * @param eventResults
	 * @return formatted string
	 */
	public String formatSearchResults(String query, String[] linesInFile, ArrayList<Integer> taskResults,
			ArrayList<Integer> floatResults, ArrayList<Integer> eventResults){ 
		
		String taskContent = formatTaskWithHeaders(linesInFile, taskResults, true);
		String floatContent = formatFloatOrTaskWithoutHeaders(linesInFile, floatResults, true);
		String eventContent = formatEventWithHeaders(linesInFile, eventResults, true); 
		
		return String.format(DISPLAY_LAYOUT_SEARCH_RESULTS, query, taskContent, floatContent, eventContent);
		
	}
	
	/**
	 * formats search results if there is error 
	 * @param query
	 * @param errorMsg
	 * @return 
	 */
	public String formatSearchError(String query, String errorMsg){ 		
		return String.format(DISPLAY_LAYOUT_SEARCH_RESULTS, query, errorMsg, errorMsg, errorMsg);
	}

	/**
	 * formats float or tasks into list with no date headers 
	 * @param linesInFile
	 * @param result
	 * @param includeStatus - true if isDoneStr is required, false if not required 
	 * @return formatted string 
	 */
	public String formatFloatOrTaskWithoutHeaders(String[] linesInFile, 
			ArrayList<Integer> result, boolean includeStatus){
		
		StringBuffer contentBuffer = new StringBuffer();
		for(int i : result){ 
			String line = linesInFile[i]; 
			String[] lineFields = line.split(SEMICOLON);

			assert(lineFields[INDEX_TYPE].equals(TYPE_FLOAT) ||
					lineFields[INDEX_TYPE].equals(TYPE_TASK)); 
			
			String lineName = lineFields[INDEX_NAME];
			String lineIsDone = (includeStatus) ? lineFields[INDEX_ISDONE] + SPACE : EMPTYSTRING;
			
			String formattedLine = String.format(DISPLAY_FORMAT_FLOAT_OR_TASK, lineIsDone, i+1, lineName);
			contentBuffer.append(formattedLine); 
		}
		
		return addMsgIfEmpty(contentBuffer); 
	}
	
	/**
	 * formats tasks into list with date headers 
	 * @param linesInFile
	 * @param result
	 * @param includeStatus - true if isDoneStr is required, false if not required 
	 * @return formatted string 
	 */
	public String formatTaskWithHeaders(String[] linesInFile, ArrayList<Integer> result, boolean includeStatus){
		StringBuffer contentBuffer = new StringBuffer();
		Date prevDeadline = null; 
		for(int i : result){ 
			String line = linesInFile[i]; 
			String[] lineFields = line.split(SEMICOLON);

			assert(lineFields[INDEX_TYPE].equals(TYPE_TASK)); 
			
			String lineName = lineFields[INDEX_NAME];
			String lineIsDone = (includeStatus) ? lineFields[INDEX_ISDONE] + SPACE : EMPTYSTRING;
			Date currDeadline = new Date(lineFields[INDEX_DUEDATE]);
			
			prevDeadline = addDateHeader(contentBuffer, currDeadline, prevDeadline);
			String formattedLine = String.format(DISPLAY_FORMAT_FLOAT_OR_TASK, lineIsDone, i+1, lineName);
			contentBuffer.append(formattedLine); 
		}
	
		return addMsgIfEmpty(contentBuffer); 
	}
	
	/**
	 * formatting of events into a list that with no date headers
	 * @param linesInFile
	 * @param result
	 * @param includeStartDate - true if startDate is required; false if startDate is not required 
	 * @return formatted string 
	 */
	public String formatEventWithoutHeaders(String[] linesInFile, ArrayList<Integer> result, boolean includeStartDate){ 
		StringBuffer contentBuffer = new StringBuffer(); 
		for(int i : result){ 
			String line = linesInFile[i]; 
			String[] lineFields = line.split(SEMICOLON);

			assert(lineFields[INDEX_TYPE].equals(TYPE_EVENT)); 
			
			String lineName = lineFields[INDEX_NAME];
			String lineIsDone = EMPTYSTRING;
			String lineStartTime = formatTime(lineFields[INDEX_STARTTIME]); 
			String lineEndTime = formatTime(lineFields[INDEX_ENDTIME]); 
			Date startDate = new Date(lineFields[INDEX_STARTDATE]); 
			String currStartDate = (includeStartDate)? startDate.formatDateMedium() + SPACE : EMPTYSTRING; 
			Date currEndDate = new Date(lineFields[INDEX_ENDDATE]);
			
			String formattedLine = String.format(DISPLAY_FORMAT_EVENT, lineIsDone, i+1, 
					lineName, currStartDate, lineStartTime, currEndDate.formatDateMedium(), lineEndTime);
			contentBuffer.append(formattedLine); 	
		}
		
		return addMsgIfEmpty(contentBuffer); 
	}
	
	/**
	 * formatting of events into a list that include date headers
	 * @param linesInFile
	 * @param result 
	 * @param includeStatus - true if isDoneStr require, false if not required
	 * @return
	 */
	public String formatEventWithHeaders(String[] linesInFile, ArrayList<Integer> result, boolean includeStatus){ 
		StringBuffer contentBuffer = new StringBuffer();
		Date prevStartDate = null; 
		for(int i : result){ 
			String line = linesInFile[i]; 
			String[] lineFields = line.split(SEMICOLON);

			assert(lineFields[INDEX_TYPE].equals(TYPE_EVENT)); 
			
			String lineName = lineFields[INDEX_NAME];
			String lineIsDone = (includeStatus) ? lineFields[INDEX_ISDONE] + SPACE : EMPTYSTRING;
			String lineStartTime = formatTime(lineFields[INDEX_STARTTIME]); 
			String lineEndTime = formatTime(lineFields[INDEX_ENDTIME]); 
			Date currEndDate = new Date(lineFields[INDEX_ENDDATE]);
			Date currStartDate = new Date(lineFields[INDEX_STARTDATE]);
			
			prevStartDate = addDateHeader(contentBuffer, currStartDate, prevStartDate); 
			String formattedLine = String.format(DISPLAY_FORMAT_EVENT, lineIsDone, i+1, 
					lineName, EMPTYSTRING, lineStartTime, currEndDate.formatDateMedium(), lineEndTime);
			contentBuffer.append(formattedLine); 
		}
		
		return addMsgIfEmpty(contentBuffer); 
	}
	
	/**
	 * extracts the type and name of the line 
	 * @param line
	 * @return formatted string in this format: <type> "<name>"
	 */
	public String formatDeleteOrDoneLine(String line){
		String[] lineComponents = line.split(SEMICOLON);
		String type = lineComponents[INDEX_TYPE]; 
		String name = lineComponents[INDEX_NAME];
		return String.format(DISPLAY_FORMAT_DELETED_OR_MARKDONE, type, name); 
	}
		
	//============================================
	// Private methods 
	//============================================
	
    private String addMsgIfEmpty(StringBuffer buffer){
    	if(buffer.length() == 0){ 
    		buffer.append(DISPLAY_NO_ITEMS);
    	}
    	return buffer.toString().trim();
    }
    
    /**
     * add date headers to sb if the currDate is different from prevDate
     * @param sb
     * @param currDate
     * @param prevDate
     * @return currDate
     */
    private Date addDateHeader(StringBuffer sb, Date currDate, Date prevDate){
    	if(prevDate == null || currDate.compareTo(prevDate)!= 0){
    		String dateHeader = currDate.formatDateLong(); 
    		sb.append(dateHeader + NEWLINE); 
    	}
    	return currDate;
    }
    
    /**
     * format time to 12h format
     * @param time in 24h format
     * @return formatted time string
     */
    private String formatTime(String time){
    	assert(time.matches(REGEX_24_HOUR_TIME)); 
    	
    	Calendar cal = Calendar.getInstance(); 
		cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(time.substring(0,2)));
		cal.set(Calendar.MINUTE, Integer.parseInt(time.substring(2)));
    	SimpleDateFormat sdf = new SimpleDateFormat("h:mm a"); 
    	return sdf.format(cal.getTime());
    }
}
```
###### backend\Logic.java
``` java
 */

package backend;

import java.nio.file.FileSystemException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Hashtable;
import java.util.logging.Level;
import java.util.logging.Logger;

import struct.Command;
import struct.Command.CommandType;
import struct.Command.DataType;
import struct.Command.ViewType;
import struct.Date;
import struct.Event;
import struct.FloatingTask;
import struct.State;
import struct.Task;

public class Logic {
	
    private static final int CONVERSION_NOT_REQ = 0; 
    private static final int CONVERSION_INVALID = -1; 
    private static final int CONVERSION_TO_TASK = 1; 
    private static final int CONVERSION_TO_EVENT = 2; 
	
	private static final int INDEX_COMMAND = 0;
	private static final int INDEX_ALIAS = 0; 
	private static final int INDEX_MEANING = 1; 

	private static final int INDEX_TYPE = 0; 
	private static final int INDEX_NAME = 1; 
	private static final int INDEX_ISDONE = 2; 
	private static final int INDEX_DUEDATE = 3;
	private static final int INDEX_STARTDATE = 3; 
	private static final int INDEX_STARTTIME = 4; 
	private static final int INDEX_ENDDATE = 5; 
	private static final int INDEX_ENDTIME = 6; 
		
    private static final String COMMAND_FORMAT_ADD_TASK = "add %s by %s"; 
    private static final String COMMAND_FORMAT_ADD_EVENT = "add %s from %s %s to %s %s";

	private static final String MESSAGE_ADD_TASK = "Added task \"%s\" to list. Due on %s.";
	private static final String MESSAGE_ADD_FLOAT_TASK = "Added float \"%s\" to list.";
	private static final String MESSAGE_ADD_EVENT = "Added event \"%s\" to list. Start: %s at %s End: %s at %s.";
	private static final String MESSAGE_DELETE_ITEM = "Deleted %s from list.";
	private static final String MESSAGE_EDIT = "Edited %s \"%s\".";
	private static final String MESSAGE_EDIT_CONVERSION = "Converted float \"%s\" to %s \"%s\".";
	private static final String MESSAGE_MARK_DONE = "Done %s.";
	private static final String MESSAGE_REDO = "Redid a \"%s\" command."; 
	private static final String MESSAGE_NO_REDO = "There are no commands to redo.";
	private static final String MESSAGE_UNDO = "Undid a \"%s\" command."; 
	private static final String MESSAGE_NO_UNDO = "There are no commands to undo.";
	private static final String MESSAGE_SET = "Set new alias \"%s\" for \"%s\"."; 
	private static final String MESSAGE_DELETE_ALIAS = "Deleted alias \"%s\"."; 
	
	private static final String MESSAGE_ERROR_UNKNOWN = "0.Unknown error encountered - file may be corrupted"; 
    private static final String MESSAGE_ERROR_INVALID_COMMAND = "\"%s\" is an invalid command. %s"; 
    private static final String MESSAGE_ERROR_ADD = "Error encountered when adding item. The item's data type is unrecognized."; 
    private static final String MESSAGE_ERROR_EDIT = "Error encountered when editing item."; 
	private static final String MESSAGE_ERROR_EDIT_INSUFFICIENT_ARGS = "Not enough arguments for conversion."; 
    private static final String MESSAGE_ERROR_EDIT_INVALID_CONVERSION = "A %s cannot be converted to a %s.";
    private static final String MESSAGE_ERROR_EDIT_INVALID_EDIT = "Invalid edit. %s"; 
    private static final String MESSAGE_ERROR_UNDO = "Error encountered in memory. "
    		+ "Undo will be unavailable for all commands before this.";
    
    private static final String MESSAGE_LOG_ERROR_FILE_SYSTEM = "File system error. May have problems opening file.";
    private static final String MESSAGE_LOG_ERROR_ALIAS_HASHTABLE = "Error creating alias hash table from alias.txt.";
    private static final String MESSAGE_LOG_ERROR_GET_PREV_STATE = "Error getting state.";
    private static final String MESSAGE_LOG_ERROR_SAVE_STATE = "Error saving state. Undo stack cleared";
    
    private static final String KEYWORD_EDIT_NAME = "name";
    private static final String KEYWORD_EDIT_DEADLINE = "date";
    private static final String KEYWORD_EDIT_START_DATE = "startd";
    private static final String KEYWORD_EDIT_START_TIME = "startt";
    private static final String KEYWORD_EDIT_END_DATE = "endd";
    private static final String KEYWORD_EDIT_END_TIME = "endt";

    private static final ArrayList<String> ATTRIBUTE_LIST_FLOAT_TO_TASK = 
    		new ArrayList<String>(Arrays.asList(KEYWORD_EDIT_DEADLINE));
    private static final ArrayList<String> ATTRIBUTE_LIST_FLOAT_TO_EVENT = 
    		new ArrayList<String>(Arrays.asList(KEYWORD_EDIT_START_DATE, KEYWORD_EDIT_START_TIME, 
    				                            KEYWORD_EDIT_END_DATE, KEYWORD_EDIT_END_TIME));
       
    private static final String TYPE_FLOAT = "float";
    private static final String TYPE_TASK = "task";
    private static final String TYPE_EVENT = "event";
    
    private static final String DONE = "done"; 
    
    private static final String NEWLINE = "\n";
    private static final String SEMICOLON = ";";
    private static final String EMPTYSTRING = "";
    private static final String REGEX_WHITESPACES = "[\\s;]+"; 
    
    private static final Logger LOGGER = Logger.getLogger(Logic.class.getName());
    
    private CommandParser commandParser; 
    private Storage storage;
    private Memory memory; 
    private Filter filter; 
    private Formatter formatter; 
    //prevCommand refer to the last command that made changes to the file 
    private Command prevCommand;
    
	//============================================
	// Constructor
	//============================================
    
    public Logic() throws FileSystemException {    	
   		Hashtable<String, String> aliasHashtable = createAliasHashtable(); 
   		initialiseMemberVariables(aliasHashtable); 
    }
        
	//============================================
	// Public methods for executing commands 
	//============================================
    
    public CommandType getCommandType(String userInput) {
    	Command command = commandParser.parse(userInput);
    	return command.getCommandType(); 
	}
    
    public ViewType getViewType(String userInput){ 
    	Command command = commandParser.parse(userInput);
    	assert(command.getCommandType() == CommandType.VIEW); 
    	return command.getViewType();
    }
    
    public String executeCommand(String userInput) {
    	Command command = commandParser.parse(userInput);
    	switch (command.getCommandType()) {
    		case ADD : 
    			return executeAdd(command);
    		case DELETE : 
    			return executeDelete(command); 
    		case EDIT : 
    			return executeEdit(command); 
    		case DONE : 
    			return executeDone(command);
    		case SEARCH :
    			return executeSearch(command); 
    		case UNDO : 
    			return executeUndo(command); 
    		case REDO : 
    			return executeRedo(command);
    		case SET : 
    			return executeSet(command); 
    		case DELETEALIAS : 
    			return executeDeleteAlias(command); 
    		case SAVE : 
    			return executeSave(command);
    		case INVALID :
            default :
            	return handleInvalid(command);
    	}	
    }
    
	//============================================
	// Public methods for views
	//============================================
 
    public String taskDefaultView(){
    	try{
    		String[] linesInFile = getLinesInFile();
    		ArrayList<Integer> taskTodayIndexList = getDateContent(linesInFile, TYPE_TASK, Date.todayDate()); 
            ArrayList<Integer> taskTmrIndexList = getDateContent(linesInFile, TYPE_TASK, Date.tomorrowDate());
        	ArrayList<Integer> floatIndexList = getAllStatus(linesInFile, TYPE_FLOAT, false); 
            return formatter.formatDefTaskView(linesInFile, taskTodayIndexList, taskTmrIndexList, floatIndexList);
    	}
    	catch(FileSystemException e){
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage(); 
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN; 
    	}
    }
    
    public String eventDefaultView(){
    	try{
    		String[] linesInFile = getLinesInFile();
        	ArrayList<Integer> eventOngoingIndexList = getOngoingEventContent(linesInFile); 
            ArrayList<Integer> eventTodayIndexList = getDateContent(linesInFile, TYPE_EVENT, Date.todayDate());
            ArrayList<Integer> eventTmrIndexList = getDateContent(linesInFile, TYPE_EVENT, Date.tomorrowDate()); 
    		return formatter.formatDefEventView(linesInFile, eventOngoingIndexList, 
    				eventTodayIndexList, eventTmrIndexList); 
    	}
    	catch(FileSystemException e){
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage();  
    	}
    	catch (Exception e) {
    		System.out.println(e.getMessage());
    		return MESSAGE_ERROR_UNKNOWN; 
		}
    }
    
    /**
     * filter and format tasks to shows in all or done views
     * @param isDone - true if display all completed tasks, false is display all uncompleted tasks 
     * @return formatted string
     */
    public String taskAllView(boolean isDone){ 
    	try{ 
    		String[] linesInFile = getLinesInFile();
        	ArrayList<Integer> taskIndexList = getAllStatus(linesInFile,TYPE_TASK, isDone);
        	ArrayList<Integer> floatIndexList = getAllStatus(linesInFile, TYPE_FLOAT, isDone); 
        	return formatter.formatAllTaskView(linesInFile, taskIndexList, floatIndexList);  
    	}
    	catch(FileSystemException e){
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage();
    	}
    	catch (Exception e) {
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
    /**
     * filter and format events to shows in all or done views
     * @param isDone - true if display all completed events, false is display all uncompleted events 
     * @return formatted string
     */
    public String eventAllView(boolean isDone){ 
    	try{
    		String[] linesInFile = getLinesInFile(); 
    		ArrayList<Integer> eventIndexList = getAllStatus(linesInFile, TYPE_EVENT, isDone);
    		return formatter.formatEventWithHeaders(linesInFile, eventIndexList, false);
    	}
    	catch(FileSystemException e){
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage(); 
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
    /**
     * filter and format tasks for unresolved view
     * @return formatted string
     */
    public String taskPastUncompletedView(){
    	try{
    		String[] linesInFile = getLinesInFile();
    		ArrayList<Integer> pastTaskIndexes = filter.filterPastUncompleted(linesInFile, TYPE_TASK); 
    		String formattedContent = formatter.formatTaskWithHeaders(linesInFile, pastTaskIndexes, false); 
    		return formattedContent; 
    	}
    	catch(FileSystemException e){ 
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage();
    	}catch (Exception e) {
			return MESSAGE_ERROR_UNKNOWN;
		} 
    }

    /**
     * filter and format events for unresolved view
     * @return formatted string
     */
    public String eventPastUncompletedView(){
    	try{
    		String[] linesInFile = getLinesInFile();
    		ArrayList<Integer> pastEventIndexes = filter.filterPastUncompleted(linesInFile, TYPE_EVENT); 
    		String formattedContent = formatter.formatEventWithHeaders(linesInFile, pastEventIndexes, false); 
    		return formattedContent; 
    	}
    	catch(FileSystemException e){ 
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return e.getMessage();
    	}catch (Exception e) {
			return MESSAGE_ERROR_UNKNOWN;
		} 
    }
    
    public String getFilepath() {
    	try{
    		return storage.getFilePath();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
    public String getAliasFileContents() throws FileSystemException{
    	assert(storage != null); 
    	return storage.readAliasFile(); 
    }
    
	//============================================
	// Private methods for constructor 
	//============================================
    
    private Hashtable<String, String> createAliasHashtable(){
    	Hashtable<String, String> aliasHashtable = new Hashtable<String, String>();
    	
    	try{ 
    		String[] lineInAliasFile = getLinesInAliasFile(); 
    		for(int i = 0; i < lineInAliasFile.length; i++){
    			String[] lineFields = lineInAliasFile[i].split(SEMICOLON);
    			String alias = lineFields[INDEX_ALIAS];
    			String meaning = lineFields[INDEX_MEANING];
    			
    			aliasHashtable.put(alias, meaning); 
    		}
    	}
    	catch(Exception e){
    		LOGGER.log(Level.WARNING, MESSAGE_LOG_ERROR_ALIAS_HASHTABLE);
    	}
    	
    	return aliasHashtable; 
    }
    
    private String[] getLinesInAliasFile() throws FileSystemException{
    	storage = new Storage(); 
    	String fileContents = storage.readAliasFile();
    	if(fileContents.isEmpty()){ 
    		return new String[0];
    	}else{
    		return fileContents.split(NEWLINE);
    	}
    }
    
	private void initialiseMemberVariables(Hashtable<String, String> aliasHashtable) throws FileSystemException {
		storage = new Storage();
		commandParser = new CommandParser(aliasHashtable);
		memory = new Memory();
		filter = new Filter(); 
		formatter = new Formatter(); 
		prevCommand = new Command();
	}
      
	//============================================
	// Private methods for executing add 
	//============================================
    
    private String executeAdd(Command command){
    	try{
    		switch (command.getDataType()) {
				case FLOATING_TASK : 
					return executeAddFloatingTask(command); 
				case TASK :
					return executeAddTask(command); 
				case EVENT :
					return executeAddEvent(command); 
				default: 
					return MESSAGE_ERROR_ADD;
    		}
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch (Exception e) {
			return MESSAGE_ERROR_UNKNOWN; 
		}
    }
    
    private String executeAddFloatingTask(Command command) throws FileSystemException{
    	State stateBeforeExecutingCommand = getState(command);
    		
    	String taskName = command.getName(); 
        FloatingTask floatingTask = new FloatingTask(taskName, false);
        storage.addFloatingTask(floatingTask); 
        String addFeedback = String.format(MESSAGE_ADD_FLOAT_TASK, taskName); 
        
        boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
        return addMemoryFeedback(addFeedback, isSaved);
    }
    
    private String executeAddTask(Command command) throws FileSystemException{
    	State stateBeforeExecutingCommand = getState(command);
    		
    	String taskName = command.getName(); 
        Date taskDeadline = command.getDueDate();
        Task task = new Task(taskName, false, taskDeadline);
        storage.addTask(task);
        String addFeedback = String.format(MESSAGE_ADD_TASK, taskName, 
        		taskDeadline.formatDateLong()); 

        boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
        return addMemoryFeedback(addFeedback, isSaved);
    }
    
    private String executeAddEvent(Command command) throws FileSystemException{
    	State stateBeforeExecutingCommand = getState(command);
    		
    	String eventName = command.getName(); 
        Date eventStartDate = command.getStartDate();
        Date eventEndDate = command.getEndDate();
        String eventStartTime = command.getStartTime(); 
        String eventEndTime = command.getEndTime();
        Event event = new Event(eventName, false, eventStartDate, eventEndDate, eventStartTime, eventEndTime);
        storage.addEvent(event); 
        String addFeedback = String.format(MESSAGE_ADD_EVENT, eventName, 
        		eventStartDate.formatDateLong(), eventStartTime, 
        		eventEndDate.formatDateLong(), eventEndTime);
        
        boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
        return addMemoryFeedback(addFeedback, isSaved);
    }
    
	//============================================
	// Private methods for executing delete 
	//============================================
   
    private String executeDelete(Command command){
    	try{
    		State stateBeforeExecutingCommand = getState(command);
    		
    		int lineNumber = command.getIndex(); 
        	String deletedLine = storage.deleteLine(lineNumber); 
        	String formattedDelLine = formatter.formatDeleteOrDoneLine(deletedLine); 
        	String deleteFeedback = String.format(MESSAGE_DELETE_ITEM, formattedDelLine); 
        	
        	boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
        	return addMemoryFeedback(deleteFeedback, isSaved);
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
	//============================================
	// Private methods for executing edit  
	//============================================

    private String executeEdit(Command command){
    	try{     		
    		switch(getConversionStatus(command)){  
    			case CONVERSION_TO_TASK : 
    				return executeEditConvertToTask(command);  
    			case CONVERSION_TO_EVENT : 
    				return executeEditConvertToEvent(command);  
    			case CONVERSION_NOT_REQ : 
    				return executeEditNoConversion(command); 
    			case CONVERSION_INVALID :
    			default : 
    				return MESSAGE_ERROR_EDIT_INSUFFICIENT_ARGS;  
    		}
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN; 
    	}
    }
    
	private String executeEditNoConversion(Command command)	throws FileSystemException {
		int lineNumber = command.getIndex(); 
		String lineType = storage.getAttribute(lineNumber, INDEX_TYPE); 
		switch(lineType){ 
			case TYPE_FLOAT :
				return executeEditFloat(command); 
			case TYPE_TASK : 
				return executeEditTask(command); 
			case TYPE_EVENT : 
				return executeEditEvent(command); 
			default:
				return MESSAGE_ERROR_EDIT; 
		}
	}
	
	private String executeEditConvertToTask(Command command) throws FileSystemException{
    	ArrayList<String> editList = command.getEditList(); 
    	assert(editList != null); 
    	
    	int lineNumber = command.getIndex(); 
    	String oldName = storage.getAttribute(lineNumber, INDEX_NAME);
    	String newName = getEditedName(command, editList, lineNumber);  
    	Date newDeadline = command.getDueDate(); 
    	String newDeadlineStr = newDeadline.formatDateShort(); 
    	Boolean isDone = isDone(lineNumber); 
    	Command addTaskCmd = getAddEditedTaskCommand(newName, newDeadlineStr); 

    	return handleEditConvertToTask(command,  addTaskCmd, lineNumber, oldName, newName, newDeadline, isDone);	  
    }
	
	 private String executeEditConvertToEvent(Command command) throws FileSystemException{ 
	    	ArrayList<String> editList = command.getEditList(); 
	    	assert(editList != null);
	    	
	    	int lineNumber = command.getIndex(); 
	    	Date newStartDate = command.getStartDate();
	    	Date newEndDate = command.getEndDate(); 
	    	String oldName = storage.getAttribute(lineNumber, INDEX_NAME); 
	    	String newName = getEditedName(command, editList, lineNumber);
	    	String newStartDateStr = newStartDate.formatDateShort(); 
	    	String newEndDateStr = newEndDate.formatDateShort(); 
	    	String newStartTime = command.getStartTime(); 
	    	String newEndTime = command.getEndTime(); 
	    	Boolean isDone = isDone(lineNumber); 
	    	Command addEventCmd = getAddEditedEventCommand(newName, newStartDateStr, 
	    			newEndDateStr, newStartTime, newEndTime); 
	    	
	    	return handleEditConvertToEvent(command, addEventCmd, lineNumber, newStartDate, 
	    			newEndDate, oldName, newName, newStartTime, newEndTime, isDone);	
	    }
	 
	private String executeEditFloat(Command command) throws FileSystemException{
		State stateBeforeExecutingCommand = getState(command);
			
		int lineNumber = command.getIndex();
		String newName = command.getName(); 
		boolean isDone = isDone(lineNumber);  
		FloatingTask newFloatingTask = new FloatingTask(newName,isDone); 
			
		storage.deleteLine(lineNumber); 
		storage.addFloatingTask(newFloatingTask);
		String editFeedback = String.format(MESSAGE_EDIT, TYPE_FLOAT, newName);
		
		boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
	    return addMemoryFeedback(editFeedback, isSaved);
	}
		
	private String executeEditTask(Command command) throws FileSystemException {
		ArrayList<String> editList = command.getEditList(); 
		assert(editList != null);

		if(Collections.disjoint(editList, ATTRIBUTE_LIST_FLOAT_TO_EVENT)){  
			int lineNumber = command.getIndex();
			Date newDeadline =  getEditedDeadline(command, editList, lineNumber);
			String newName = getEditedName(command, editList, lineNumber); 
			String newDeadlineStr = newDeadline.formatDateShort(); 
			boolean isDone = isDone(lineNumber);  			
			Command addEditedTaskCmd = getAddEditedTaskCommand(newName, newDeadlineStr);
	    	
	    	return handleEditTask(command, addEditedTaskCmd, lineNumber, newDeadline, newName, isDone);
		}
		else{ 
			return String.format(MESSAGE_ERROR_EDIT_INVALID_CONVERSION, TYPE_TASK, TYPE_EVENT); 
		}
	}
	
	private String executeEditEvent(Command command) throws FileSystemException {
    	ArrayList<String> editList = command.getEditList(); 
    	assert(editList != null); 
    	
    	if(Collections.disjoint(editList, ATTRIBUTE_LIST_FLOAT_TO_TASK)){ 
    		int lineNumber = command.getIndex();
    		Date newStartDate = getEditedStartDate(command, editList, lineNumber);
    		Date newEndDate = getEditedEndDate(command, editList, lineNumber);
    		String newName = getEditedName(command, editList, lineNumber); 
    		String newStartDateStr = newStartDate.formatDateShort();
    		String newEndDateStr = newEndDate.formatDateShort(); 
    		String newStartTime = getEditedStartTime(command, editList, lineNumber);
    		String newEndTime = getEditedEndTime(command, editList, lineNumber);
    		boolean isDone = isDone(lineNumber);  
    		Command addEditedEventCmd = getAddEditedEventCommand(newName, newStartDateStr, 
    				newEndDateStr, newStartTime, newEndTime); 
    		
        	return handleEditEvent(command, addEditedEventCmd, lineNumber, 
        			newStartDate, newEndDate, newName, newStartTime, newEndTime, isDone);	
    	}
    	else{ 
			return String.format(MESSAGE_ERROR_EDIT_INVALID_CONVERSION, TYPE_EVENT, TYPE_TASK);
    	}
	}

	private String getEditedName(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_NAME)){ 
			return command.getName();
		}
		else{ 
			return storage.getAttribute(lineNumber, INDEX_NAME);
		}
	}
    
	private Date getEditedDeadline(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_DEADLINE)){ 
			return command.getDueDate(); 
		}
		else{ 
			return new Date(storage.getAttribute(lineNumber, INDEX_DUEDATE));
		}
	}

	private String getEditedStartTime(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_START_TIME)){ 
			return command.getStartTime(); 
		}
		else{
			return storage.getAttribute(lineNumber, INDEX_STARTTIME);
		}
	}

	private String getEditedEndTime(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_END_TIME)){ 
			return command.getEndTime(); 
		}
		else{ 
			return storage.getAttribute(lineNumber, INDEX_ENDTIME);
		}
	}
	
	private Date getEditedStartDate(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_START_DATE)){ 
			return command.getStartDate(); 
		}
		else{ 
			return new Date(storage.getAttribute(lineNumber, INDEX_STARTDATE));
		}
	}

	private Date getEditedEndDate(Command command, ArrayList<String> editList, int lineNumber)
			throws FileSystemException {
		if(editList.contains(KEYWORD_EDIT_END_DATE)){
			return command.getEndDate(); 
		}
		else{ 
			return new Date(storage.getAttribute(lineNumber, INDEX_ENDDATE));
		}
	}
	
	private Command getAddEditedTaskCommand(String newName, String newDeadlineStr) {
		String addEditedTaskCmdStr = String.format(COMMAND_FORMAT_ADD_TASK, newName, newDeadlineStr);    	
		Command addEditedTaskCmd = commandParser.parse(addEditedTaskCmdStr);
		return addEditedTaskCmd;
	}

	private Command getAddEditedEventCommand(String newName, String newStartDateStr, String newEndDateStr,
			String newStartTime, String newEndTime) {
		String addEditedEventCmdString = String.format(COMMAND_FORMAT_ADD_EVENT, newName, newStartDateStr, newStartTime, newEndDateStr, newEndTime);  
		Command addEditedEventCmd = commandParser.parse(addEditedEventCmdString);
		return addEditedEventCmd;
	}
	
    private int getConversionStatus(Command command) throws FileSystemException{ 
		ArrayList<String> editList = command.getEditList();
		int lineNumber = command.getIndex(); 
    	String lineType = storage.findTypeInLine(lineNumber); 
        	
    	if(containNameOnly(editList) || isTaskOrEvent(lineType)){
    		return CONVERSION_NOT_REQ; 
    	}
    	else if(lineType.equals(TYPE_FLOAT) && editList.containsAll(ATTRIBUTE_LIST_FLOAT_TO_TASK)){ 
    		return CONVERSION_TO_TASK; 
    	}
    	else if(lineType.equals(TYPE_FLOAT) && editList.containsAll(ATTRIBUTE_LIST_FLOAT_TO_EVENT)){
    		return CONVERSION_TO_EVENT; 
    	}
    	else{ 
    		return CONVERSION_INVALID;
    	}    	 
    }
    
	private String handleEditConvertToTask(Command command, Command addTaskCmd, int lineNumber, 
			String oldName, String newName, Date newDeadline, Boolean isDone) throws FileSystemException {
		
		if(isValidEdit(addTaskCmd, DataType.TASK)){ 	
    		boolean isSaved = handleValidEditTask(command, lineNumber, newName, newDeadline, isDone);
    		String editFeedback = String.format(MESSAGE_EDIT_CONVERSION, oldName, TYPE_TASK, newName);
            return addMemoryFeedback(editFeedback, isSaved);
    	}else{ 
    		return handleInvalidEdit(addTaskCmd); 
    	}
	}
    
	private String handleEditConvertToEvent(Command command, Command addEventCmd, int lineNumber, Date newStartDate,
			Date newEndDate, String oldName, String newName, String newStartTime, String newEndTime, Boolean isDone)
						throws FileSystemException {
		if(isValidEdit(addEventCmd, DataType.EVENT)){ 	
    		boolean isSaved = handleValidEditEvent(command, lineNumber, 
	   				newStartDate, newEndDate, newName, newStartTime, newEndTime, isDone);
	   		String editFeedback = String.format(MESSAGE_EDIT_CONVERSION, oldName, TYPE_EVENT, newName);
            return addMemoryFeedback(editFeedback, isSaved);
	    }else{ 
	    	return handleInvalidEdit(addEventCmd);
	   	}
	}
		
	private String handleEditTask(Command command, Command addTaskCmd, int lineNumber, 
			Date newDeadline, String newName, boolean isDone) throws FileSystemException {
		if(isValidEdit(addTaskCmd, DataType.TASK)){ 
			boolean isSaved = handleValidEditTask(command, lineNumber, newName, newDeadline, isDone); 
			String editFeedback = String.format(MESSAGE_EDIT, TYPE_TASK, newName);
		    return addMemoryFeedback(editFeedback, isSaved);
		}else{ 
			return handleInvalidEdit(addTaskCmd); 
		}
	}

	private String handleEditEvent(Command command, Command addEventCmd, int lineNumber, Date newStartDate,
			Date newEndDate, String newName, String newStartTime, String newEndTime, boolean isDone) 
					throws FileSystemException {
		if(isValidEdit(addEventCmd, DataType.EVENT)){ 
			boolean isSaved = handleValidEditEvent(command, lineNumber, 
					newStartDate, newEndDate, newName, newStartTime, newEndTime, isDone);
			String editFeedback = String.format(MESSAGE_EDIT, TYPE_EVENT, newName);
		    return addMemoryFeedback(editFeedback, isSaved);
		}else{ 
			return handleInvalidEdit(addEventCmd); 
		}
	}

	private boolean handleValidEditTask(Command command, int lineNumber, String newName, Date newDeadline,
			Boolean isDone) throws FileSystemException {
		State stateBeforeExecutingCommand = getState(command);
		addEditedTaskToFile(lineNumber, newName, isDone, newDeadline);
		return loadToMemoryStacks(command, stateBeforeExecutingCommand);
	}

	private boolean handleValidEditEvent(Command command, int lineNumber, Date newStartDate, Date newEndDate,
			String newName, String newStartTime, String newEndTime, Boolean isDone) throws FileSystemException {
		State stateBeforeExecutingCommand = getState(command);
		addEditedEventToFile(lineNumber, newName, isDone, newStartDate, newEndDate, newStartTime, newEndTime);
		boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
		return isSaved;
	}
	
	private String handleInvalidEdit(Command addEditedItemCmd) {
		assert(addEditedItemCmd.getCommandType() == CommandType.INVALID);
		 
		String reason = (addEditedItemCmd.getName() != null)? addEditedItemCmd.getName() : EMPTYSTRING;
		return String.format(MESSAGE_ERROR_EDIT_INVALID_EDIT, reason);
	}
  
	private void addEditedTaskToFile(int lineNumber, String newName, boolean isDone, Date newDeadline)
			throws FileSystemException {
		storage.deleteLine(lineNumber); 
		Task editedTask = new Task(newName, isDone, newDeadline); 
		storage.addTask(editedTask);
	}
	
	private void addEditedEventToFile(int lineNumber, String newName, boolean isDone, Date newStartDate,
			Date newEndDate, String newStartTime, String newEndTime) throws FileSystemException {
		storage.deleteLine(lineNumber); 
		Event editedEvent = new Event(newName, isDone, newStartDate, newEndDate, newStartTime, newEndTime); 
		storage.addEvent(editedEvent);
	}
    
	private boolean isDone(int lineNumber) throws FileSystemException {
		String isDoneStr = storage.getAttribute(lineNumber, INDEX_ISDONE); 
		return isDoneStr.equals(DONE);
	}
	
	private boolean isValidEdit(Command addEditedItemCmd, Command.DataType dataType) {
		return addEditedItemCmd.getCommandType() == CommandType.ADD 
				&& addEditedItemCmd.getDataType() == dataType;
	}
	
    private boolean isTaskOrEvent(String lineType){ 
    	return lineType.equals(TYPE_TASK) || lineType.equals(TYPE_EVENT); 
    }
   	    
    private boolean containNameOnly(ArrayList<String> editList){ 
    	return editList.size() == 1 && editList.contains(KEYWORD_EDIT_NAME); 
    }
    
	//============================================
	// Private methods for executing done 
	//============================================
   
	private String executeDone(Command command){
    	try{
    		State stateBeforeExecutingCommand = getState(command);
    		
    		int lineNumber = command.getIndex(); 
        	String doneLine = storage.markAsDone(lineNumber); 
        	String formattedDoneLine = formatter.formatDeleteOrDoneLine(doneLine);
        	String markDoneFeedback = String.format(MESSAGE_MARK_DONE, formattedDoneLine); 
        	
        	boolean isSaved = loadToMemoryStacks(command, stateBeforeExecutingCommand);
        	return addMemoryFeedback(markDoneFeedback, isSaved);
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
	
	//============================================
	// Private methods for executing search
	//============================================
     
    private String executeSearch(Command command){ 
    	String query = command.getName(); 
    	try{
    		String[] linesInFile = getLinesInFile();
    		ArrayList<Integer> floatResults = getSearchResults(linesInFile, TYPE_FLOAT, query); 
    		ArrayList<Integer> taskResults = getSearchResults(linesInFile, TYPE_TASK, query); 
    		ArrayList<Integer> eventResults = getSearchResults(linesInFile, TYPE_EVENT, query); 
    		return formatter.formatSearchResults(query, linesInFile, taskResults, floatResults, eventResults); 
    	}
    	catch(FileSystemException e){
    		LOGGER.log(Level.SEVERE, MESSAGE_LOG_ERROR_FILE_SYSTEM);
    		return formatter.formatSearchError(query, e.getMessage());
    	}
    	catch(Exception e){ 
    		return formatter.formatSearchError(query, MESSAGE_ERROR_UNKNOWN); 
    	}
    }
    
    private ArrayList<Integer> getSearchResults(String[] linesInFile, String type, String query){
    	return filter.matchTokensInQuery(linesInFile, type, query); 
    }
    
	//============================================
	// Private methods for executing undo and redo 
	//============================================
        
    private String executeUndo(Command command){ 
    	try{
    		String currFileContents = storage.display();
    		State stateAfterUndo = memory.getUndoState(currFileContents);
    		
    		if(stateAfterUndo == null){
        		return MESSAGE_NO_UNDO; 
        	}
    		
    		storage.overwriteFile(stateAfterUndo.getFileContents());
    		prevCommand = command; 
    		String userCmdUndid = stateAfterUndo.getUserCommand(); 
        	return String.format(MESSAGE_UNDO, getCommandStr(userCmdUndid));
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
    private String executeRedo(Command command){ 
    	try{
    		String currFileContents = storage.display();
        	State stateAfterRedo = memory.getRedoState(currFileContents);
        	
        	if(stateAfterRedo == null){
        		return MESSAGE_NO_REDO; 
        	}
        	
        	storage.overwriteFile(stateAfterRedo.getFileContents());
        	prevCommand = command;
        	String userCmdRedid = stateAfterRedo.getUserCommand(); 
        	return String.format(MESSAGE_REDO, getCommandStr(userCmdRedid));
    	}
    	catch(FileSystemException e){
    		return e.getMessage();
    	}
    	catch(Exception e){
    		return MESSAGE_ERROR_UNKNOWN;
    	}
    }
    
   	private State getState(Command command) {
   		try{
   			String prevFileContents = storage.display(); 
   	   		String userCommand = command.getUserInput();
   	   		State prevState = new State(prevFileContents, userCommand);
   	   		return prevState;
   		}
   		catch(Exception e){
   			LOGGER.log(Level.WARNING, MESSAGE_LOG_ERROR_GET_PREV_STATE);
   			return null; 
   		}
   	}
   	
	private boolean loadToMemoryStacks(Command command, State stateBeforeExecutingCommand) {
        clearRedo(command);
        return saveState(stateBeforeExecutingCommand);
	}
   	
	private boolean saveState(State prevState) {
		if(prevState != null){
        	memory.savePrevState(prevState);
        	return true;
        }
		else{
        	memory.clearUndoStack();
        	LOGGER.log(Level.WARNING, MESSAGE_LOG_ERROR_SAVE_STATE);
        	return false;
        }
	}
    
    private void clearRedo(Command command){
    	if(prevCommand.isUndoOrRedo() && !command.isUndoOrRedo()){
    		memory.clearRedoStack();
    	}
    	prevCommand = command; 
    }
   	
	private String addMemoryFeedback(String cmdFeedback, boolean isSaved) {
		if(isSaved){
        	return cmdFeedback;
        }
        else{
        	return cmdFeedback + MESSAGE_ERROR_UNDO;
        }
	}
 
	private String getCommandStr(String userString){
		String[] lineComponents = userString.split(REGEX_WHITESPACES);
		return lineComponents[INDEX_COMMAND]; 
	}
		
	//============================================
	// Private methods for executing set
	//============================================
	
	private String executeSet(Command command){ 
		try{
			String newAlias = command.getName(); 
			String oldAlias = command.getOriginalCommand();
			storage.addToAliasFile(newAlias, oldAlias);
			commandParser.setAlias(newAlias, oldAlias);
			return String.format(MESSAGE_SET, newAlias, oldAlias);
		}
		catch(FileSystemException e){
			return e.getMessage(); 
		}
		catch (Exception e) {
			return MESSAGE_ERROR_UNKNOWN; 
		} 
	}
	
	//============================================
	// Private methods for executing delete alias
	//============================================
	
	private String executeDeleteAlias(Command command){ 
		try{
			String alias = command.getName(); 
			storage.deleteFromAliasFile(alias);
			commandParser.deleteAlias(alias);
			return String.format(MESSAGE_DELETE_ALIAS, alias);
		}
		catch(FileSystemException e){
			return e.getMessage(); 
		}
		catch (Exception e) {
			return MESSAGE_ERROR_UNKNOWN; 
		}
	}
	
	//============================================
	// Private methods for executing save
	//============================================
	
	private String executeSave(Command command) {
		String newFilePath = command.getName(); 
		return storage.changeFileStorageLocation(newFilePath); 
	}
	
	//============================================
	// Private methods for handling invalid cmd
	//============================================
    
    private String handleInvalid(Command command){ 
    	String userInput = command.getUserInput(); 
    	String reason = (command.getName() != null)? command.getName() : EMPTYSTRING;
    	return String.format(MESSAGE_ERROR_INVALID_COMMAND, userInput, reason); 
    }
    
	//============================================
	// Private methods for View mtds  
	//============================================    
      
    private String[] getLinesInFile() throws FileSystemException{
    	String fileContents = storage.display();
    	if(fileContents.isEmpty()){ 
    		return new String[0];
    	}else{
    		return fileContents.split(NEWLINE);
    	}
    }
    
    private ArrayList<Integer> getDateContent(String[] linesInFile ,String type, Date date){
    	return filter.filterDate(linesInFile, type, date); 
    }
    
    private ArrayList<Integer> getOngoingEventContent(String[] linesInFile){ 
    	return filter.filterOngoingEvents(linesInFile);
    }
     
    private ArrayList<Integer> getAllStatus(String[] linesInFile ,String type, boolean isDone){
    	return filter.filterStatus(linesInFile, type, isDone); 
    }
    
    //============================================
  	// Public method used in testing only
  	//============================================
    
    public void overwriteFile(String textToOverwrite) throws FileSystemException{ 
    	storage.overwriteFile(textToOverwrite);
    }
    
    public void clearAliasFile() throws FileSystemException{ 
    	storage.clearAliasFile();
    }
}
```
###### backend\Memory.java
``` java
 */

package backend;

import java.util.Stack;

import struct.State;

public class Memory {
	
	private Stack<State> undoStack; 
	private Stack<State> redoStack; 
	
	//============================================
	// Constructor
	//============================================
	
	public Memory() {
		undoStack = new Stack<State>(); 
		redoStack = new Stack<State>(); 
	}
	
	//============================================
	// Public methods
	//============================================
	
	public void savePrevState(State prevState){ 
		undoStack.push(prevState);
	}
	
	public State getUndoState(String currFileContents){ 
		return getState(currFileContents, undoStack, redoStack);
	}
	
	public State getRedoState(String currFileContents){ 
		return getState(currFileContents, redoStack, undoStack);
	}
	
	public void clearUndoStack(){
		undoStack.clear();
	}
	
	public void clearRedoStack(){
		redoStack.clear();
	}
	
	//============================================
	// Private method
	//============================================

	private State getState(String currFileContents, Stack<State> stackPop, Stack<State> stackPush){ 
		if(stackPop.isEmpty()){
			return null; 
		}else{ 
			State prevState = stackPop.pop(); 
			State currState = new State(currFileContents, prevState.getUserCommand()); 
			stackPush.push(currState);
			return prevState;
		}
	}
	
}
```
###### gui\Handlers.java
``` java
 */

package gui;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import struct.Command;
import struct.View;

public class Handlers {

	private static final String COMMAND_SEARCH = "search";
	
	private static final String EMPTY_STRING = "";
	private static final String SPACE = " ";
	
	private static final boolean SEARCH_USER = false;
	private static final boolean SEARCH_BACKGROUND = true;
	
	private static LogicController handlerLogicControl = InterfaceController.getLogic();
	
    // ======================================================================
    // Getters to allow GUI components in InterfaceController to access the
    // private EventHandler classes
    // ======================================================================
	
    // EventHandlers
	protected static TextInputHandler getTextInputHandler() {
		return new TextInputHandler();
	}
	
	protected static KeyPressHandler getKeyPressHandler() {
		return new KeyPressHandler();
	}
	
	protected static TabPressHandler getTabPressHandler() {
		return new TabPressHandler();
	}
	
	protected static HotKeyHandler getHotKeyHandler() {
		return new HotKeyHandler();
	}
	
	protected static HelpHotKeyHandler getHelpHotKeyHandler() {
		return new HelpHotKeyHandler();
	}
	
	protected static ButtonHoverHandler getButtonHoverHandler(View buttonType) {
		return new ButtonHoverHandler(buttonType);
	}
	
	protected static ButtonClickHandler getButtonClickHandler(View buttonType) {
		return new ButtonClickHandler(buttonType);
	}
	
	protected static PathHoverHandler getPathHoverHandler(Label filepathLabel) {
		return new PathHoverHandler(filepathLabel);
	}
	
	protected static PathClickHandler getPathClickHandler() {
		return new PathClickHandler();
	}
	
	protected static UnresHoverHandler getUnresHoverHandler(Label allUnresAttention) {
		return new UnresHoverHandler(allUnresAttention);
	}
	
	protected static UnresClickHandler getUnresClickHandler() {
		return new UnresClickHandler();
	}
	
	protected static ConfigClickHandler getConfigClickHandler() {
		return new ConfigClickHandler();
	}
	
	protected static AutoCompleteSelectHandler getAutoCompleteSelectHandler() {
		return new AutoCompleteSelectHandler();
	}
	
    // ======================================================================
    // Private EventHandler class definitions
    // ======================================================================
	
	/**
	 * This class implements a handler for the text field to perform certain
	 * operations upon pressing the ENTER key
	 */
	private static class TextInputHandler implements EventHandler<ActionEvent> {
		private String lastSearchCommand = LogicController.NULL_STRING;
		
        @Override
        public void handle(ActionEvent event) {

        	// Get the text field from InterfaceController
        	TextField textField = InterfaceController.getTextField();
            String textFieldInput = textField.getText();
            
            // Add the input into command history
            LogicController.getHistory().add(textFieldInput);
            LogicController.getHistory().resetIndex();

            textField.setText(LogicController.NULL_STRING);

            // Do a preliminary parse to determine the type of operation
            Command.CommandType operationType = LogicController.getLogic().
            		getCommandType(textFieldInput);
            
            // Perform branching based on the operation type
            switch (operationType) {
	            case VIEW:
	            	// Run another parse of the command to get the destination view
	            	switch(LogicController.getLogic().getViewType(textFieldInput)) {
		            	case DEF :
		            		handlerLogicControl.changeView(View.DEFAULT);
		            		break;
		            	case ALL :
		            		handlerLogicControl.changeView(View.ALL);
		            		break;
		            	case HIST :
		            		handlerLogicControl.changeView(View.HISTORY);
		            		break;
		            	case UNRES :
		            		handlerLogicControl.changeView(View.UNRESOLVED);
		            		break;
		            	case SEARCH :
		            		handlerLogicControl.changeView(View.SEARCH);
		            		break;
		            	case DONE :
		            		handlerLogicControl.changeView(View.DONE);
		            		break;
		            	case HELP :
		            		handlerLogicControl.changeView(View.HELP);
		            		break;
		            	case OPENFILE :
		            		handlerLogicControl.openFileLocation();
		            		break;
		            	case CONFIG :
		            		handlerLogicControl.openConfigLocation();
		            		break;
		            	default:
		            		break;
		            	}
	            	break;
	            case EXIT:
	            	handlerLogicControl.changeView(View.EXIT);
	            	break;
	            case SEARCH:
	            	// Store the last search command to run the search again dynamically
	            	// upon the user's next operation
	            	// Modify the search query by replacing the first word with "search" to account
	            	// for aliases since there is no parsing here
	            	String[] textFieldInputSplit = textFieldInput.split(SPACE);
	            	textFieldInputSplit[0] = COMMAND_SEARCH;
	            	lastSearchCommand = EMPTY_STRING;
	            	for (int i = 0; i < textFieldInputSplit.length; i++) {
	            		lastSearchCommand += textFieldInputSplit[i] + SPACE;
	            	}
	            	lastSearchCommand = lastSearchCommand.substring(0, lastSearchCommand.length() - 1);
	            	handlerLogicControl.runCommand(operationType, textFieldInput, SEARCH_USER);
	            	handlerLogicControl.changeView(View.SEARCH);
	            	break;
	            // Only modify the user command for these operations by editing the 
	            // index from ViewIndexMap
	            case DELETE:
	            	handlerLogicControl.runCommand(
	            			operationType, 
	            			handlerLogicControl.mapToFileIndex(textFieldInput), 
	            			SEARCH_USER);
	            	runBackgroundUpdate();
	            	break;
	            case EDIT:
	            	handlerLogicControl.runCommand(
	            			operationType, 
	            			handlerLogicControl.mapToFileIndex(textFieldInput), 
	            			SEARCH_USER);
	            	runBackgroundUpdate();
	            	break;
	            case DONE:
	            	handlerLogicControl.runCommand(
	            			operationType, 
	            			handlerLogicControl.mapToFileIndex(textFieldInput), 
	            			SEARCH_USER);
	            	runBackgroundUpdate();
	            	break;
	            default:
	            	handlerLogicControl.runCommand(operationType, textFieldInput, SEARCH_USER);
	            	runBackgroundUpdate();
	            	break;
            }

        }

        /**
         * This method runs the background update to SEARCH view and automatically swaps
         * updates the view if the user is already in SEARCH view
         */
		private void runBackgroundUpdate() {
			// Run the last search and update the search view only if the user is in search
			if (!lastSearchCommand.equals(LogicController.NULL_STRING) && 
					InterfaceController.getCurrentView() == View.SEARCH) {
				handlerLogicControl.runCommand(
						Command.CommandType.SEARCH, lastSearchCommand, SEARCH_BACKGROUND);
				InterfaceController.updateMainInterface(View.SEARCH);
			}
			
			assert InterfaceController.getCurrentView() != View.SEARCH;
			
			// If the user is not in search view, do not switch to search view
			if (!lastSearchCommand.equals(LogicController.NULL_STRING) && 
					InterfaceController.getCurrentView() != View.SEARCH) {
				handlerLogicControl.runCommand(
						Command.CommandType.SEARCH, lastSearchCommand, SEARCH_BACKGROUND);
			}
		}
    }
	
	/** 
	 * This class implements a handler for key presses in the text field to run
	 * the LogicController.getHistory() methods when the user presses a UP or DOWN key
	 */
	private static class KeyPressHandler implements EventHandler<KeyEvent> {
        @Override
        public void handle(KeyEvent event) {
        	// If up key pressed
        	if (event.getCode() == KeyCode.UP) {
        		// Only register keypress when autocomplete is now showing
        		if (!AutoComplete.isShowing()) {
        			String prevCommand = LogicController.getHistory().getPrevious();
        			InterfaceController.getTextField().setText(prevCommand);
        			handlerLogicControl.setCaretToEnd(prevCommand);
        		}
        	}
            // If down key pressed
        	if (event.getCode() == KeyCode.DOWN) {
        		// Only register keypress when autocomplete is not showing
        		if (!AutoComplete.isShowing()) {
        			String nextCommand = LogicController.getHistory().getNext();
        			InterfaceController.getTextField().setText(nextCommand);
        			handlerLogicControl.setCaretToEnd(nextCommand);
        		}
            }
        }
    }
	
	/**
	 * This class implements a handler for the TAB key in the main stage in MainApp
	 * to control the display of the summary view
	 */
	private static class TabPressHandler implements EventHandler<KeyEvent> {
		@Override
		public void handle(KeyEvent event) {
			// Display the summary view
			if (event.getCode() == KeyCode.TAB) {
				if (!SummaryViewController.isShowing()) {
					SummaryViewController.startShowing();
					handlerLogicControl.changeView(View.SUMMARY);
				} else {
					SummaryViewController.stopShowing();
					InterfaceController.updateMainInterface(InterfaceController.getCurrentView());
				}
			}
		}
	}

	/** 
	 * This class implements a handler for all instances of hotkey combinations
	 * in MainApp's main stage
	 */
	private static class HotKeyHandler implements EventHandler<KeyEvent> {
		@Override
		public void handle(KeyEvent event) {
			if (event.isControlDown()) {
				switch (event.getCode()) {
					// For regular number keys
					case DIGIT1 :
						handlerLogicControl.changeView(View.DEFAULT);
						break;
					case DIGIT2 :
						handlerLogicControl.changeView(View.ALL);
						break;
					case DIGIT3 :
						handlerLogicControl.changeView(View.UNRESOLVED);
						break;
					case DIGIT4 :
						handlerLogicControl.changeView(View.DONE);
						break;
					case DIGIT5 :
						handlerLogicControl.changeView(View.SEARCH);
						break;
					case DIGIT6 :
						handlerLogicControl.changeView(View.HISTORY);
						break;
					case DIGIT7 :
						handlerLogicControl.changeView(View.HELP);
						break;
					// For users with a number pad
					case NUMPAD1 :
						handlerLogicControl.changeView(View.DEFAULT);
						break;
					case NUMPAD2 :
						handlerLogicControl.changeView(View.ALL);
						break;
					case NUMPAD3 :
						handlerLogicControl.changeView(View.HISTORY);
						break;
					case NUMPAD4 :
						handlerLogicControl.changeView(View.UNRESOLVED);
						break;
					case NUMPAD5 :
						handlerLogicControl.changeView(View.DONE);
						break;
					case NUMPAD6 :
						handlerLogicControl.changeView(View.SEARCH);
						break;
					case NUMPAD7 :
						handlerLogicControl.changeView(View.HELP);
						break;
					default:
						// Do nothing
						break;
				}
			} else {
				switch (event.getCode()) {
					case F1 :
						handlerLogicControl.changeView(View.HELP);
						break;
					// For opening text and config files
					case F2 :
						handlerLogicControl.openFileLocation();
						break;
					case F3 :
						handlerLogicControl.openConfigLocation();
						break;
					case F4 :
						InterfaceController.toggleAutoCompleteIndicator();
						handlerLogicControl.toggleAutoComplete();
						break;
					default:
						break;
				}
			}
		}
	}
	
	/**
	 * This class implements a handler for hotkeys registered by the help
	 * stage in MainApp instead of the regular stage
	 */
	private static class HelpHotKeyHandler implements EventHandler<KeyEvent> {
		@Override
		public void handle(KeyEvent event) {
			event.consume();
			if (event.isControlDown()) {
				switch (event.getCode()) {
					// For regular number key
					case DIGIT7:
						handlerLogicControl.changeView(View.HELP);
						break;
					case NUMPAD7:
						handlerLogicControl.changeView(View.HELP);
						break;
					default:
						// Do nothing
						break;
				}
			} else {
				if (event.getCode() == KeyCode.F1) {
					handlerLogicControl.changeView(View.HELP);
				}
			}
		}
	}
    
	/**
	 * This class implements a handler that changes the button images when
	 * a mouse is hovered over the button
	 */
    private static class ButtonHoverHandler implements EventHandler<MouseEvent> {
    	private View buttonType;
    	
    	ButtonHoverHandler(View buttonType) {
    		this.buttonType = buttonType;
    	}
    	
    	@Override
    	public void handle(MouseEvent event) {
    		// For handling mouse hovers
    		if (event.getEventType() == MouseEvent.MOUSE_ENTERED) {
    			ImageView hover;
    			switch(buttonType) {
	    			case DEFAULT:
	    				if (InterfaceController.getCurrentView() != View.DEFAULT) {
	    					hover = new ImageView(InterfaceController.PATH_DEFAULT_HOVER);
	    					InterfaceController.getHomeButton().getChildren().clear();
	    					InterfaceController.getHomeButton().getChildren().add(hover);
	    				}
	    				break;
	    			case ALL:
	    				if (InterfaceController.getCurrentView() != View.ALL) {
	    					hover = new ImageView(InterfaceController.PATH_ALL_HOVER);
	    					InterfaceController.getAllButton().getChildren().clear();
	    					InterfaceController.getAllButton().getChildren().add(hover);
	    				}
	    				break;
	    			case HISTORY:
	    				if (InterfaceController.getCurrentView() != View.HISTORY) {
	    					hover = new ImageView(InterfaceController.PATH_HIST_HOVER);
	    					InterfaceController.getHistButton().getChildren().clear();
	    					InterfaceController.getHistButton().getChildren().add(hover);
	    				}
	    				break;
	    			case UNRESOLVED:
	    				if (InterfaceController.getCurrentView() != View.UNRESOLVED) {
	    					hover = new ImageView(InterfaceController.PATH_UNRESOLVED_HOVER);
	    					InterfaceController.getUnresButton().getChildren().clear();
	    					InterfaceController.getUnresButton().getChildren().add(hover);
	    				}
	    				break;
	    			case DONE:
	    				if (InterfaceController.getCurrentView() != View.DONE) {
	    					hover = new ImageView(InterfaceController.PATH_DONE_HOVER);
	    					InterfaceController.getDoneButton().getChildren().clear();
	    					InterfaceController.getDoneButton().getChildren().add(hover);
	    				}
	    				break;
	    			case SEARCH:
	    				if (InterfaceController.getCurrentView() != View.SEARCH) {
	    					hover = new ImageView(InterfaceController.PATH_SEARCH_HOVER);
	    					InterfaceController.getSearchButton().getChildren().clear();
	    					InterfaceController.getSearchButton().getChildren().add(hover);
	    				}
	    				break;
	    			case HELP:
	    				// Do not change the button if help dialog is showing
	    				if (!MainApp.help.isShowing()) {
	    					hover = new ImageView(InterfaceController.PATH_HELP_HOVER);
	    					InterfaceController.getHelpButton().getChildren().clear();
	    					InterfaceController.getHelpButton().getChildren().add(hover);
	    				}
	    				break;
	    			default:
	    				break;
    			}
    		}
    		// For handling mouse not hovering
    		if (event.getEventType() == MouseEvent.MOUSE_EXITED) {
    			ImageView hover;
    			switch(buttonType) {
	    			case DEFAULT:
	    				if (InterfaceController.getCurrentView() != View.DEFAULT) {
	    					hover = new ImageView(InterfaceController.PATH_DEFAULT);
	    					InterfaceController.getHomeButton().getChildren().clear();
	    					InterfaceController.getHomeButton().getChildren().add(hover);
	    				}
	    				break;
	    			case ALL:
	    				if (InterfaceController.getCurrentView() != View.ALL) {
	    					hover = new ImageView(InterfaceController.PATH_ALL);
	    					InterfaceController.getAllButton().getChildren().clear();
	    					InterfaceController.getAllButton().getChildren().add(hover);
	    				}
	    				break;
	    			case HISTORY:
	    				if (InterfaceController.getCurrentView() != View.HISTORY) {
	    					hover = new ImageView(InterfaceController.PATH_HIST);
	    					InterfaceController.getHistButton().getChildren().clear();
	    					InterfaceController.getHistButton().getChildren().add(hover);
	    				}
	    				break;
	    			case UNRESOLVED:
	    				if (InterfaceController.getCurrentView() != View.UNRESOLVED) {
	    					hover = new ImageView(InterfaceController.PATH_UNRESOLVED);
	    					InterfaceController.getUnresButton().getChildren().clear();
	    					InterfaceController.getUnresButton().getChildren().add(hover);
	    				}
	    				break;
	    			case DONE:
	    				if (InterfaceController.getCurrentView() != View.DONE) {
	    					hover = new ImageView(InterfaceController.PATH_DONE);
	    					InterfaceController.getDoneButton().getChildren().clear();
	    					InterfaceController.getDoneButton().getChildren().add(hover);
	    				}
	    				break;
	    			case SEARCH:
	    				if (InterfaceController.getCurrentView() != View.SEARCH) {
	    					hover = new ImageView(InterfaceController.PATH_SEARCH);
	    					InterfaceController.getSearchButton().getChildren().clear();
	    					InterfaceController.getSearchButton().getChildren().add(hover);
	    				}
	    				break;
	    			case HELP:
	    				// Do not change the button if help dialog is showing
	    				if (!MainApp.help.isShowing()) {
	    					hover = new ImageView(InterfaceController.PATH_HELP);
	    					InterfaceController.getHelpButton().getChildren().clear();
	    					InterfaceController.getHelpButton().getChildren().add(hover);
	    				}
	    				break;
	    			default:
	    				break;
    			}
    		}
    	}
    }
    
    /**
     * This class implements a handler for the buttons when a mouse click is
     * registered by the mouse
     */
    private static class ButtonClickHandler implements EventHandler<MouseEvent> {
    	View buttonType;
    	
    	ButtonClickHandler(View buttonType) {
    		this.buttonType = buttonType;
    	}
    	
    	@Override
    	public void handle(MouseEvent event) {
    		// When a user clicks a button without pressing TAB to exit the summary view
    		// Sets the isShowing value in SummaryViewController
    		if (SummaryViewController.isShowing()) {
    			SummaryViewController.stopShowing();
    		}
    		handlerLogicControl.changeView(buttonType);
    	}
    }
    
    /**
     * This class implements a handler which underlines the filepath when hovered over
     */
    private static class PathHoverHandler implements EventHandler<MouseEvent> {
    	Label filepathLabel;
    	
    	PathHoverHandler(Label filepathLabel) {
    		this.filepathLabel = filepathLabel;
    	}
    	
    	@Override
    	public void handle(MouseEvent event) {
    		if (event.getEventType() == MouseEvent.MOUSE_ENTERED) {
    			filepathLabel.setStyle(InterfaceController.CSS_UNDERLINE);
    		}
    		if (event.getEventType() == MouseEvent.MOUSE_EXITED) {
    			filepathLabel.setStyle(InterfaceController.CSS_NO_UNDERLINE);
    		}
    	}
    }
    
    /**
     * This class implements a handler for registering mouse clicks in the filepath bar
     */
    private static class PathClickHandler implements EventHandler<MouseEvent> {
    	@Override
    	public void handle(MouseEvent event) {
    		handlerLogicControl.openFileLocation();
    	}
    }
    
    /**
     * This class implements a handler that underlines the prompt text in the summary 
     * view regarding unresolved tasks
     */
    private static class UnresHoverHandler implements EventHandler<MouseEvent> {
    	Label allUnresAttention;
    	
    	UnresHoverHandler(Label allUnresAttention) {
    		this.allUnresAttention = allUnresAttention;
    	}
    	
    	@Override
    	public void handle(MouseEvent event) {
    		if (event.getEventType() == MouseEvent.MOUSE_ENTERED) {
    			allUnresAttention.setStyle(InterfaceController.CSS_UNDERLINE);
    			allUnresAttention.setStyle(InterfaceController.CSS_UNDERLINE_ITALIC);
    		}
    		if (event.getEventType() == MouseEvent.MOUSE_EXITED) {
    			allUnresAttention.setStyle(InterfaceController.CSS_NO_UNDERLINE);
    			allUnresAttention.setStyle(InterfaceController.CSS_NO_UNDERLINE_ITALIC);
    		}
    	}
    }
    
    /**
     * This class implements a handler that registers mouse clicks on the prompt text
     * and performs a view switch when clicked
     */
    private static class UnresClickHandler implements EventHandler<MouseEvent> {
    	@Override
    	public void handle(MouseEvent event) {
    		SummaryViewController.stopShowing();
    		InterfaceController.updateMainInterface(View.UNRESOLVED);
    	}
    }
    
    /**
     * This class implements a handler that registers mouse clicks on the config
     * button in the filepath bar
     */
    private static class ConfigClickHandler implements EventHandler<MouseEvent> {
    	@Override
    	public void handle(MouseEvent event) {
    		handlerLogicControl.openConfigLocation();
    	}
    }
    
    /**
     * This class implements a handler in the autocomplete popup that registers
     * ENTER keypresses when the user wishes to select a particular keyword suggested
     * by autocomplete
     */
    private static class AutoCompleteSelectHandler implements EventHandler<KeyEvent> {
    	@Override
    	public void handle(KeyEvent event) {
    		if (event.getCode() == KeyCode.ENTER) {
    			InterfaceController.getTextField().setText(AutoComplete.getSelectedItem());
				String text = InterfaceController.getTextField().getText();
				handlerLogicControl.setCaretToEnd(text);
    			AutoComplete.closePopup();
    		}
    	}
    }
}
```
###### struct\Command.java
``` java
 */

package struct;

import java.util.ArrayList;

public class Command {
	
	public enum CommandType {
		ADD, DELETE, DELETEALIAS, EDIT, SEARCH, DONE, SET, SAVE, UNDO, REDO, VIEW, EXIT, INVALID
    }
	
	public enum DataType { 
		TASK, FLOATING_TASK, EVENT
	}
	
	public enum ViewType {
		ALL, DEF, HIST, UNRES, SEARCH, HELP, DONE, OPENFILE, CONFIG
	}
	
	private String userInput; 
	private CommandType commandType;
	private DataType dataType;
	private ViewType viewType;
	//name may contain arguments for commands instead of event or task name
	private String name;
	private int index;
	private Date dueDate; 
	private Date startDate;
	private Date endDate; 
	private String startTime; 
	private String endTime;
	private ArrayList<String> editList;
	private String originalCommand;
	
	//============================================
	// Constructors
	//============================================
	
	public Command() {
		
	}
	
	public Command(CommandType commandType) {
		this.commandType = commandType;
	}
	
	//============================================
	// Public Methods
	//============================================	
	
	public boolean isUndoOrRedo() {
		return this.commandType == CommandType.UNDO || 
				this.commandType == CommandType.REDO;
	}
	
	//============================================
	// Getters
	//============================================
	
	public String getUserInput() {
		return userInput;
	}

	public CommandType getCommandType() {
		return commandType;
	}

	public DataType getDataType() {
		return dataType;
	}
	
	public ViewType getViewType() {
		return viewType;
	}

	public String getName() {
		return name;
	}
	
	public int getIndex() {
		return index;
	}

	public Date getDueDate() {
		return dueDate;
	}

	public Date getStartDate() {
		return startDate;
	}

	public Date getEndDate() {
		return endDate;
	}

	public String getStartTime() {
		return startTime;
	}

	public String getEndTime() {
		return endTime;
	}
	
	public ArrayList<String> getEditList() {
		return editList;
	}
	
	public String getOriginalCommand() {
		return originalCommand;
	}
	
	//============================================
	// Setters
	//============================================
	
	public void setUserInput(String userInput) {
		this.userInput = userInput;
	}

	public void setCommandType(CommandType commandType) {
		this.commandType = commandType;
	}

	public void setDataType(DataType dataType) {
		this.dataType = dataType;
	}
	
	public void setViewType(ViewType viewType) {
		this.viewType = viewType;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public void setIndex(int index) {
		this.index = index;
	}

	public void setDueDate(Date dueDate) {
		this.dueDate = dueDate;
	}

	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}

	public void setEndDate(Date endDate) {
		this.endDate = endDate;
	}

	public void setStartTime(String startTime) {
		this.startTime = startTime;
	}

	public void setEndTime(String endTime) {
		this.endTime = endTime;
	}
	
	public void setEditList(ArrayList<String> editList) {
		this.editList = editList;
	}
	
	public void setOriginalCommand(String originalCommand) {
		this.originalCommand = originalCommand;
	}
}
```
###### struct\Event.java
``` java
 */

package struct;


public class Event extends TodoItem implements Comparable<Event>{

	private static final String SEMICOLON = ";";
	private static final String EMPTY_STRING = "";
	
	private static final String FORMAT_TO_STRING = "event;%s;%s;%s;%s;%s;%s";
	
	private static final String STRING_EVENT = "event";
	private static final String STRING_DONE = "done";
	private static final String STRING_NOT_DONE = "todo";
	
	private static final int PARAM_TYPE = 0;
	private static final int PARAM_NAME = 1;
	private static final int PARAM_DONE = 2;
	private static final int PARAM_START_DATE = 3;
	private static final int PARAM_START_TIME = 4;
	private static final int PARAM_END_DATE = 5;
	private static final int PARAM_END_TIME = 6;
	private static final int NUM_PARAM_EVENTS = 7;
	
	private static final int SAME_DATE = 0;
	private static final int SAME_TIME = 0;
	
    private Date eventStartDate, eventEndDate;
    private String eventStartTime, eventEndTime;
    
	//============================================
	// Constructors
	//============================================
    
    public Event() {
    	super();
        this.eventStartDate = new Date();
        this.eventEndDate = new Date();
        this.eventStartTime = EMPTY_STRING;
        this.eventEndTime = EMPTY_STRING;
    }
    
    public Event(String line){ 
    	line.trim();
    	String[] lineComponents = line.split(SEMICOLON);
    	
    	assert(lineComponents[PARAM_TYPE].equals(STRING_EVENT));
    	assert(lineComponents.length == NUM_PARAM_EVENTS);
    	
    	this.name = lineComponents[PARAM_NAME]; 
    	this.isDone = lineComponents[PARAM_DONE].equals(STRING_DONE); 
    	this.eventStartDate = new Date(lineComponents[PARAM_START_DATE]);
    	this.eventEndDate = new Date(lineComponents[PARAM_END_DATE]);
    	this.eventStartTime = lineComponents[PARAM_START_TIME];
    	this.eventEndTime = lineComponents[PARAM_END_TIME];
    }

	public Event(String name, boolean isDone, Date eventStartDate, Date eventEndDate, String eventStartTime, String eventEndTime) {
		super(name, isDone);
		this.eventStartDate = eventStartDate;
		this.eventEndDate = eventEndDate;
		this.eventStartTime = eventStartTime;
		this.eventEndTime = eventEndTime;
	}
	
	//============================================
	// Public Methods
	//============================================
	
	/**
	 * compareTo
	 * @return negative number if this < other 
	 * 		   positive number if this > other 
	 * 		   zero if this == other         
	 */
	public int compareTo(Event other){ 
		int compareStartDate = this.getEventStartDate().compareTo(other.getEventStartDate());
		int compareEndDate = this.getEventEndDate().compareTo(other.getEventEndDate());
		int compareStartTime = this.getEventStartTime().compareTo(other.getEventStartTime()); 
		int compareEndTime = this.getEventEndTime().compareTo(other.getEventEndTime());
		int compareName = this.getName().compareTo(other.getName());
		
		if(compareStartDate != SAME_DATE){ 
			return compareStartDate; 
		}else if (compareStartTime != SAME_TIME){ 
			return compareStartTime; 
		}else if (compareEndDate != SAME_DATE){ 
			return compareEndDate; 
		}else if (compareEndTime != SAME_TIME){ 
			return compareEndTime; 
		}else{
			return compareName; 
		}
	}
	
	/**
	 * toString 
	 * @return formatted string to write into txt file
	 */
	public String toString(){
		String status;
		if (this.isDone) {
			status = STRING_DONE;
		} else {
			status = STRING_NOT_DONE;
		}
		return String.format(FORMAT_TO_STRING, this.name, status, this.eventStartDate.formatDateShort(), 
				this.eventStartTime, this.eventEndDate.formatDateShort(), this.eventEndTime);
	}

	//============================================
	// Getters 
	//============================================
    public Date getEventStartDate() {
        return eventStartDate;
    }

    public Date getEventEndDate() {
        return eventEndDate;
    }

    public String getEventStartTime() {
        return eventStartTime;
    }

    public String getEventEndTime() {
        return eventEndTime;
    }

	//============================================
	// Setters 
	//============================================
    public void setEventStartDate(Date eventStartDate) {
        this.eventStartDate = eventStartDate;
    }

    public void setEventEndDate(Date eventEndDate) {
        this.eventEndDate = eventEndDate;
    }

    public void setEventStartTime(String eventStartTime) {
        this.eventStartTime = eventStartTime;
    }

    public void setEventEndTime(String eventEndTime) {
        this.eventEndTime = eventEndTime;
    }
}
```
###### struct\State.java
``` java
 */

package struct;

public class State {
	
	private String fileContents; 
	private String userCommand;
	
	//============================================
	// Constructors
	//============================================
	
	public State(String fileContents, String userCommand) {
		this.fileContents = fileContents;
		this.userCommand = userCommand;
	}
	
	//============================================
	// Getters
	//============================================

	public String getFileContents() {
		return fileContents;
	}

	public String getUserCommand() {
		return userCommand;
	}
}
```
###### struct\Task.java
``` java
 */

package struct;

public class Task extends TodoItem implements Comparable<Task>{

	private static final String SEMICOLON = ";";
	
	private static final String FORMAT_TO_STRING = "task;%s;%s;%s";
	
	private static final String STRING_TASK = "task";
	private static final String STRING_DONE = "done";
	private static final String STRING_NOT_DONE = "todo";
	
	private static final int PARAM_TYPE = 0;
	private static final int PARAM_NAME = 1;
	private static final int PARAM_TODO = 2;
	private static final int PARAM_DEADLINE = 3;
	private static final int NUM_PARAM_TASK = 4;
	
	private static final int SAME_DATE = 0;
	
    private Date deadline;
    
	//============================================
	// Constructors
	//============================================

    public Task() {
        super(); 
        this.deadline = new Date();
    }
    
    public Task(String line) {
    	line.trim();
    	String[] lineComponents = line.split(SEMICOLON);
    	
    	assert(lineComponents[PARAM_TYPE].equals(STRING_TASK));
    	assert(lineComponents.length == NUM_PARAM_TASK);

    	this.name = lineComponents[PARAM_NAME]; 
    	this.isDone = lineComponents[PARAM_TODO].equals(STRING_DONE); 
    	this.deadline = new Date(lineComponents[PARAM_DEADLINE]);
    	
    }
   
	public Task(String name, boolean isDone, Date deadline) {
		super(name, isDone);
		this.deadline = deadline;
	}
	
	//============================================
	// Public Methods
	//============================================
	
	/**
	 * compareTo
	 * @return negative number if this < other 
	 * 		   positive number if this > other 
	 * 		   zero if this == other         
	 */
	public int compareTo(Task other){
		int compareDate = this.getDeadline().compareTo(other.getDeadline());
		int compareName = this.getName().compareTo(other.getName());
		if(compareDate != SAME_DATE){
			return compareDate; 
		}else{
			return compareName; 
		}
	}
	
	/**
	 * toString 
	 * @return formatted string to write into txt file
	 */
	public String toString(){
		String status;
		if (this.isDone) {
			status = STRING_DONE;
		} else {
			status = STRING_NOT_DONE;
		}
		return String.format(FORMAT_TO_STRING, this.name, status, this.deadline.formatDateShort());
	}

	//============================================
	// Getters
	//============================================
    public Date getDeadline() {
        return deadline;
    }

	//============================================
	// Setters
	//============================================
    public void setDeadline(Date deadline) {
        this.deadline = deadline;
    }
}

```
###### test\LogicTest.java
``` java
public class LogicTest {
	
	@Test 
	/** Test getCommandType and getViewType**/
	public void testGet() throws FileSystemException{ 
		Logic logic = new Logic();
		
		//test getCommandType
		Command.CommandType commandType = logic.getCommandType("add sth"); 
		assertEquals(CommandType.ADD, commandType);
		
		//test getViewType 
		Command.ViewType viewType = logic.getViewType("all"); 
		assertEquals(ViewType.ALL, viewType);
	}
		
	@Test 
	/** Test valid add commands **/
	public void testAdd() throws FileSystemException{ 
		Logic logic = new Logic();
		
		// add float 
		String feedback = logic.executeCommand("add sth");
		assertEquals("Added float \"sth\" to list.", feedback);
		
		// add float with keyword in name
		feedback = logic.executeCommand("add sth \\by tomorrow");
		assertEquals("Added float \"sth by tomorrow\" to list.", feedback);
		
		// add task with deadline 
		feedback = logic.executeCommand("add deadline by 111116");
		assertEquals("Added task \"deadline\" to list. Due on Fri, 11 Nov 2016.", feedback);
		
		// add single-day event 
		feedback = logic.executeCommand("add single on 111116 from 1pm to 6pm"); 
		assertEquals("Added event \"single\" to list. Start: Fri, 11 Nov 2016 at 1300 End: Fri, 11 Nov 2016 at 1800.", feedback);
		
		// add event multiple day event
		feedback = logic.executeCommand("add cooking from 231016 7pm to 241016 8pm");
		assertEquals("Added event \"cooking\" to list. Start: Sun, 23 Oct 2016 at 1900 End: Mon, 24 Oct 2016 at 2000.", feedback);
	}
	
	@Test 
	/** Test invalid add commands **/
	public void testInvalidAdd() throws FileSystemException{
		Logic logic = new Logic();
		
		// Invalid deadline
		String feedback = logic.executeCommand("add hello by 3002");
		assertEquals("\"add hello by 3002\" is an invalid command. Invalid deadline.", feedback);
		
		// Start time later than end time for single-day event
		feedback = logic.executeCommand("add hello on 301216 from 5pm to 1am");
		assertEquals("\"add hello on 301216 from 5pm to 1am\" is an invalid command. "
				+ "Start time later than or equal to end time for single-day event.", feedback);
		
		// Start time equal to end time for single-day event
		feedback = logic.executeCommand("add hello on 301216 from 5pm to 5pm");
		assertEquals("\"add hello on 301216 from 5pm to 5pm\" is an invalid command. "
				+ "Start time later than or equal to end time for single-day event.", feedback);
		
		// Start date later than end date
		feedback = logic.executeCommand("add hello from tmr 1am to today 3am"); 
		assertEquals("\"add hello from tmr 1am to today 3am\" is an invalid command. "
				+ "Start date later than end date.", feedback);
		
		// Missing task name 
	} 
	
	@Test
	/** Test valid delete commands **/
	public void testDelete() throws FileSystemException{ 
		Logic logic = new Logic(); 
		logic.overwriteFile("float;hello;todo\n"
				+ "task;hellotask;todo;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		String feedback = logic.executeCommand("delete 2");
		assertEquals("Deleted task \"hellotask\" from list.", feedback);

	}
	
	@Test 
	/** Test invalid delete commands **/
	public void testInvalidDelete() throws FileSystemException{
		Logic logic = new Logic();
		
		// No such alias has been set 
		String feedback = logic.executeCommand("delete -1");
		assertEquals("\"delete -1\" is an invalid command. Alias -1 has not been set.", feedback);
		
		// Invalid index - index does not exist
		feedback = logic.executeCommand("delete 100000");
		assertEquals("Cannot find line 100000 in text file.", feedback);
		
		// Invalid index - missing index 
		feedback = logic.executeCommand("delete");
		assertEquals("\"delete\" is an invalid command. Index/alias command required.", feedback);
		
	}
	
	@Test
	/** Test valid edit commands **/
	public void testEdit() throws FileSystemException{ 
		Logic logic = new Logic(); 
		logic.overwriteFile("float;hello;todo\n"
				+ "float;hello2;done\n"
				+ "task;hellotask;todo;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		
		/** edit task **/
		// edit name of task 
		String feedback = logic.executeCommand("edit 3 name newtaskname"); 
		assertEquals("Edited task \"newtaskname\".", feedback);
		
		// edit date of task 
		feedback = logic.executeCommand("edit 3 date 101116"); 
		assertEquals("Edited task \"newtaskname\".", feedback);
		
		// edit all fields of task together 
		feedback = logic.executeCommand("edit 3 name editalltask date 101116"); 
		assertEquals("Edited task \"editalltask\".", feedback);
		
		/** edit event **/ 
		// edit name of event 
		feedback = logic.executeCommand("edit 4 name neweventname"); 
		assertEquals("Edited event \"neweventname\".", feedback);
		
		// edit all fields of event together 
		feedback = logic.executeCommand("edit 4 name editallevent startd 121116 startt 3 endd 131116 endt 4"); 
		assertEquals("Edited event \"editallevent\".", feedback);
		
		/** edit float **/ 
		// edit name of float
		feedback = logic.executeCommand("edit 1 name anewname"); 
		assertEquals("Edited float \"anewname\".", feedback);
		
		// convert float to task 
		feedback = logic.executeCommand("edit 1 name convertedtask date 101116"); 
		assertEquals("Converted float \"anewname\" to task \"convertedtask\".", feedback);
		
		// convert float to event
		feedback = logic.executeCommand("edit 1 name convertedevent startd 101116 startt 3 endd 111116 endt 4"); 
		assertEquals("Converted float \"hello2\" to event \"convertedevent\".", feedback);
	}
	
	@Test 
	/** Test invalid edit commands **/
	public void testInvalidEdit() throws FileSystemException{
		Logic logic = new Logic(); 
		logic.overwriteFile("float;hello;todo\n"
				+ "task;hellotask;done;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		
		/** invalid conversions **/
		// invalid - convert from task to event 
		String feedback = logic.executeCommand("edit 2 startd 101116 startt 3 endd 111116 endt 4"); 
		assertEquals("A task cannot be converted to a event.", feedback);
		
		// invalid - convert from event to task 
		feedback = logic.executeCommand("edit 3 date 101116"); 
		assertEquals("A event cannot be converted to a task.", feedback);
		
		// invalid - insufficient args to convert from float to event 
		feedback = logic.executeCommand("edit 1 startd 101116 endd 101116"); 
		assertEquals("Not enough arguments for conversion.", feedback);
		
		/** illogical edits **/ 
		// edit deadline to a date that has past 
		feedback = logic.executeCommand("edit 2 date 111106"); 
		assertEquals("\"edit 2 date 111106\" is an invalid command. Invalid deadline.", feedback);
							
		// edit start date to become later than end date
		feedback = logic.executeCommand("edit 3 startd 141116"); 
		assertEquals("Invalid edit. Start date later than end date.", feedback);
	
		// edit start time to become later than end time for single day events 
		feedback = logic.executeCommand("edit 3 startt 2100"); 
		assertEquals("Invalid edit. Start time later than or equal to end time for single-day event.", feedback);
		
	}
	
	@Test
	/** Test valid done commands **/
	public void testDone() throws FileSystemException{ 
		Logic logic = new Logic(); 
		logic.overwriteFile("float;hello;todo\n"
				+ "task;hellotask;todo;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		
		// valid - lower boundary case 
		String feedback = logic.executeCommand("done 1"); 
		assertEquals("Done float \"hello\".", feedback);
		
		// valid - upper boundary case 
		feedback = logic.executeCommand("done 3"); 
		assertEquals("Done event \"helloevent\".", feedback);
	}
	
	@Test
	/** Test invalid done commands **/
	public void testInvalidtDone() throws FileSystemException{ 
		Logic logic = new Logic(); 
		logic.overwriteFile("float;hello;done\n"
				+ "task;hellotask;todo;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		
		// invalid - mark done a task that is already done
		String feedback = logic.executeCommand("done 1"); 
		assertEquals("Error encountered: the float \"hello\" has already been completed.", feedback);
		
		// invalid index - less than lower boundary 
		feedback = logic.executeCommand("done -1"); 
		assertEquals("\"done -1\" is an invalid command. Invalid index.", feedback);
		
		// invalid index - greater than upper boundary 
		feedback = logic.executeCommand("done 4"); 
		assertEquals("Cannot find line 4 in text file.", feedback);
	}
	
	@Test
	/** Test valid search commands **/
	public void testSearch() throws FileSystemException{ 
		Logic logic = new Logic();
		logic.overwriteFile("float;hello;done\n"
				+ "float;goodbye;todo\n"
				+ "task;task hello;todo;111116\n"
				+ "event;helloevent;todo;111116;1500;111116;2000");
		
		// search with results 
		String feedback = logic.executeCommand("search hello");
		assertEquals("Showing results for \"hello\"\n"
				+ "TASK\nFri, 11 Nov 2016\ntodo 3. task hello\n"
				+ "FLOAT\ndone 1. hello\n"
				+ "EVENT\nFri, 11 Nov 2016\ntodo 4. helloevent;Start: 3:00 PM;End: Fri, 11 Nov 16 8:00 PM", feedback);
		
		// search no results 
		feedback = logic.executeCommand("search xxxxx"); 
		assertEquals("Showing results for \"xxxxx\"\n"
				+ "TASK\nThere are no items to display.\n"
				+ "FLOAT\nThere are no items to display.\n"
				+ "EVENT\nThere are no items to display.", feedback);
		
		// search empty file 
		logic.overwriteFile(""); 
		feedback = logic.executeCommand("search hello"); 
		assertEquals("Showing results for \"hello\"\n"
				+ "TASK\nThere are no items to display.\n"
				+ "FLOAT\nThere are no items to display.\n"
				+ "EVENT\nThere are no items to display.", feedback);
	}
	
	@Test
	/** Test undo and redo commands **/
	public void testUndoandRedo() throws FileSystemException{ 
		Logic logic = new Logic();
		
		// no commands to undo
		String feedback = logic.executeCommand("undo"); 
		assertEquals("There are no commands to undo.", feedback); 
		
		// undo and redo multiple commands
		logic.overwriteFile("");
		logic.executeCommand("add sth"); 
		logic.executeCommand("add task by 111216"); 
		logic.executeCommand("delete 1");
		
		feedback = logic.executeCommand("undo"); 
		assertEquals("Undid a \"delete\" command.", feedback); 
		feedback = logic.executeCommand("undo"); 
		assertEquals("Undid a \"add\" command.", feedback); 
		feedback = logic.executeCommand("redo"); 
		assertEquals("Redid a \"add\" command.", feedback); 
		feedback = logic.executeCommand("redo"); 
		assertEquals("Redid a \"delete\" command.", feedback); 
		
		// check if redo stack is cleared correctly 
		logic.executeCommand("add 1"); 
		logic.executeCommand("add 2"); 
		logic.executeCommand("delete 1");
		logic.executeCommand("undo"); 
		logic.executeCommand("undo"); 
		logic.executeCommand("add 3"); 
		feedback = logic.executeCommand("redo"); 
		assertEquals("There are no commands to redo.", feedback); 
	}
	
	@Test
	/** Test set commands **/
	public void testSet() throws FileSystemException{ 
		Logic logic = new Logic();
		logic.clearAliasFile(); 
		
		// valid set command
		String feedback = logic.executeCommand("set + as add"); 
		assertEquals("Set new alias \"+\" for \"add\".", feedback); 
		
		//try using alias
		feedback = logic.executeCommand("+ sth"); 
		assertEquals("Added float \"sth\" to list.", feedback); 
	}
	
	@Test
	/** Test invalid set commands **/
	public void testInvalidSet() throws FileSystemException{ 
		Logic logic = new Logic();
		logic.clearAliasFile();
		
		// invalid alias - set alias that is already a command keyword
		String feedback = logic.executeCommand("set add as delete"); 
		assertEquals("\"set add as delete\" is an invalid command. "
				+ "Input alias is a either a registered command and cannot be used or an alias-in-use.", feedback); 
		
		// invalid alias - set alias that already exists 
		logic.executeCommand("set create as add"); 
		feedback = logic.executeCommand("set create as delete"); 
		assertEquals("\"set create as delete\" is an invalid command. "
				+ "Input alias is a either a registered command and cannot be used or an alias-in-use.", feedback); 
	}
	
	@Test
	/** Test delete alias commands **/
	public void testDeleteAlias() throws FileSystemException{ 
		Logic logic = new Logic();
		logic.clearAliasFile();
		
		// valid delete alias command 
		logic.executeCommand("set del as delete");
		String feedback = logic.executeCommand("delete del"); 
		assertEquals("Deleted alias \"del\".", feedback); 
	}
	
	@Test
	/** Test invalid delete alias commands **/
	public void testInvalidDeleteAlias() throws FileSystemException{ 
		Logic logic = new Logic();
		logic.clearAliasFile();
		
		// invalid delete alias - delete alias that was not set 
		String feedback = logic.executeCommand("delete insert"); 
		assertEquals("\"delete insert\" is an invalid command. Alias insert has not been set.", feedback); 
	}
	
	@Test 
	/** Test save command **/
	public void testSave() throws FileSystemException{ 
		Logic logic = new Logic();
		
		//get original filepath
		String originalUrl = logic.getFilepath(); 
		int fileNameIndex = originalUrl.lastIndexOf("\\whattodo.txt");
		String originalBaseUrl = originalUrl.substring(0, fileNameIndex); 
		
		// valid - save to same location
		String feedback = logic.executeCommand("save " + originalBaseUrl); 
		assertEquals("Your file location remains unchanged.", feedback); 
		
		// valid - save to new location 
		feedback = logic.executeCommand("save c:\\test"); 
		assertEquals("You are now writing to \"c:\\test\\whattodo.txt\"", feedback); 
		
		//save to original location after testing 
		logic.executeCommand("save " + originalBaseUrl); 
	}
		
	@Test
	public void testInvalidUserCommand() throws FileSystemException{
		Logic logic = new Logic();
		
		String feedback = logic.executeCommand("zzz");
		assertEquals("\"zzz\" is an invalid command. Invalid user command.", feedback);
	}
	
	@Test
	public void testCorruptedFile() throws FileSystemException{
		Logic logic = new Logic();
		
		logic.overwriteFile(";;");
		String feedback = logic.executeCommand("add zzz");
		assertEquals("0.Unknown error encountered - file may be corrupted", feedback);
		
		//ensure the file is not corrupted at the end of tests
		logic.overwriteFile("");
	}
	
}
```
